{"version":3,"sources":["node_modules/subjx/dist/js/subjx.dev.common.js","node_modules/subjx/index.js","src/index.js","node_modules/parcel-bundler/src/builtins/bundle-url.js","node_modules/parcel-bundler/src/builtins/css-loader.js"],"names":["module","exports","require","_subjx2","_interopRequireDefault","obj","__esModule","default","_typeof","Symbol","iterator","constructor","prototype","_regeneratorRuntime","Op","Object","hasOwn","hasOwnProperty","defineProperty","key","desc","value","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","create","context","Context","makeInvokeMethod","tryCatch","fn","arg","type","call","ContinueSentinel","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","method","_invoke","AsyncIterator","PromiseImpl","invoke","resolve","reject","record","result","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","state","Error","doneResult","delegate","delegateResult","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","done","methodName","undefined","return","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","val","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","_catch","thrown","delegateYield","asyncGeneratorStep","gen","_next","_throw","_asyncToGenerator","args","arguments","apply","ownKeys","enumerableOnly","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","_objectSpread","target","source","_defineProperty","getOwnPropertyDescriptors","defineProperties","_toPropertyKey","_toPrimitive","String","input","hint","prim","toPrimitive","res","Number","zoom_value_formula","document","getElementById","onclick","cacluatePosition","onchange","changeZoomCanvas","selected_index","selectedIndex","console","log","defaultSelectedZoomCanvas","checkAllImagesLoaded","transformToFit","images","querySelectorAll","maxWidth","image","width","clientWidth","Math","max","height","clientHeight","concat","container","offsets_world","scaleValue","style","transform","event","transformOrigin","pagesOffsetObject","xDraggable","meta_data","margin_gap","array_xDraggable","index","draggable_element","draggable_element_main","page","temp_meta_data_top","parseInt","$","css","split","j","snapshots_name","current_page_image_height","image_height","current_page_image_width","image_width","image_document_element","querySelector","offsets","getBoundingClientRect","offsets_document_image","top","left","ceil","documents_top","xElem","subjx","options","snap","x","y","angle","cursorMove","cursorRotate","cursorResize","rotatable","methods","onInit","elements","onMove","_ref","clientX","clientY","dx","dy","onResize","_ref2","onRotate","_ref3","delta","onDrop","_ref4","onDestroy","el","drag","clone","stack","appendTo","e","parent","offset","drag_div","createElement","setAttribute","id","drag_img","background","opacity","border","borderRadius","appendChild","on","_callee","_callee$","_context","imgs","len","counter","img","incrementCounter","addEventListener","fitToWidth","bundleURL","getBundleURLCached","getBundleURL","matches","match","getBaseURL","url","replace","bundle","updateLink","link","newLink","cloneNode","onload","remove","href","Date","now","parentNode","insertBefore","nextSibling","cssTimeout","reloadCSS","setTimeout","links"],"mappings":"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AF5BpB,AE+BA;AF9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"src.a2b27638.js","sourceRoot":"..","sourcesContent":["/*@license\n* Drag/Rotate/Resize Library\n* Released under the MIT license, 2018-2020\n* Karen Sarksyan\n* nichollascarter@gmail.com\n*/\n'use strict';\n\nconst requestAnimFrame = \r\n    window.requestAnimationFrame ||\r\n    window.mozRequestAnimationFrame ||\r\n    window.webkitRequestAnimationFrame ||\r\n    window.msRequestAnimationFrame ||\r\n    function (f) {\r\n        return setTimeout(f, 1000 / 60);\r\n    };\r\n\r\nconst cancelAnimFrame =\r\n    window.cancelAnimationFrame ||\r\n    window.mozCancelAnimationFrame ||\r\n    function (requestID) {\r\n        clearTimeout(requestID);\r\n    };\r\n\r\nconst {\r\n    forEach,\r\n    slice: arrSlice,\r\n    map: arrMap,\r\n    reduce: arrReduce\r\n} = Array.prototype;\r\n/* eslint-disable no-console */\r\nconst { warn } = console;\r\n/* eslint-disable no-console */\r\n\r\nfunction isDef(val) {\r\n    return val !== undefined && val !== null;\r\n}\r\n\r\nfunction isUndef(val) {\r\n    return val === undefined || val === null;\r\n}\r\n\r\nfunction isFunc(val) {\r\n    return typeof val === 'function';\r\n}\r\n\r\nfunction createMethod(fn) {\r\n    return isFunc(fn)\r\n        ? function () {\r\n            fn.call(this, ...arguments);\r\n        }\r\n        : () => { };\r\n}\n\nclass Helper {\n\n    constructor(params) {\n        if (typeof params === 'string') {\n            const selector = document.querySelectorAll(params);\n            this.length = selector.length;\n            for (let count = 0; count < this.length; count++) {\n                this[count] = selector[count];\n            }\n        } else if (typeof params === 'object' &&\n            (params.nodeType === 1 || params === document)) {\n            this[0] = params;\n            this.length = 1;\n        } else if (params instanceof Helper) {\n            this.length = params.length;\n            for (let count = 0; count < this.length; count++) {\n                this[count] = params[count];\n            }\n        } else if (isIterable(params)) {\n            this.length = 0;\n            for (let count = 0; count < this.length; count++) {\n                if (params.nodeType === 1) {\n                    this[count] = params[count];\n                    this.length++;\n                }\n            }\n        } else {\n            throw new Error(`Passed parameter must be selector/element/elementArray`);\n        }\n    }\n\n    css(prop) {\n        const _getStyle = obj => {\n            let len = obj.length;\n\n            while (len--) {\n                if (obj[len].currentStyle) {\n                    return obj[len].currentStyle[prop];\n                } else if (document.defaultView && document.defaultView.getComputedStyle) {\n                    return document.defaultView.getComputedStyle(obj[len], '')[prop];\n                } else {\n                    return obj[len].style[prop];\n                }\n            }\n        };\n\n        const _setStyle = (obj, options) => {\n            let len = obj.length;\n\n            while (len--) {\n                for (const property in options) {\n                    obj[len].style[property] = options[property];\n                }\n            }\n            return obj.style;\n        };\n\n        const methods = {\n            setStyle(options) {\n                return _setStyle(this, options);\n            },\n            getStyle() {\n                return _getStyle(this);\n            }\n        };\n\n        if (typeof prop === 'string') {\n            return methods.getStyle.apply(this, arrSlice.call(arguments, 1));\n        } else if (typeof prop === 'object' || !prop) {\n            return methods.setStyle.apply(this, arguments);\n        } else {\n            warn(`Method ${prop} does not exist`);\n        }\n        return false;\n    }\n\n    on() {\n        let len = this.length;\n\n        while (len--) {\n            if (!this[len].events) {\n                this[len].events = {};\n                this[len].events[arguments[0]] = [];\n            }\n\n            if (typeof (arguments[1]) !== 'string') {\n                if (document.addEventListener) {\n                    this[len].addEventListener(\n                        arguments[0], \n                        arguments[1], \n                        arguments[2] || { passive: false }\n                    );\n                } else if (document.attachEvent) {\n                    this[len].attachEvent(`on${arguments[0]}`, arguments[1]);\n                } else {\n                    this[len][`on${arguments[0]}`] = arguments[1];\n                }\n            } else {\n                listenerDelegate(\n                    this[len], \n                    arguments[0], \n                    arguments[1], \n                    arguments[2], \n                    arguments[3], \n                    true\n                );\n            }\n        }\n        return this;\n    }\n\n    off() {\n        let len = this.length;\n\n        while (len--) {\n            if (!this[len].events) {\n                this[len].events = {};\n                this[len].events[arguments[0]] = [];\n            }\n\n            if (typeof (arguments[1]) !== 'string') {\n                if (document.removeEventListener) {\n                    this[len].removeEventListener(arguments[0], arguments[1], arguments[2]);\n                } else if (document.detachEvent) {\n                    this[len].detachEvent(`on${arguments[0]}`, arguments[1]);\n                } else {\n                    this[len][`on${arguments[0]}`] = null;\n                }\n            } else {\n                listenerDelegate(this[len], arguments[0], arguments[1], arguments[2], arguments[3], false);\n            }\n        }\n\n        return this;\n    }\n\n    is(selector) {\n        if (isUndef(selector)) return false;\n        \n        const _sel = helper(selector);\n        let len = this.length;\n\n        while (len--) {\n            if (this[len] === _sel[len]) return true;\n        }\n        return false;\n    }\n\n}\n\nfunction listenerDelegate(el, evt, sel, handler, options, act) {\n    const doit = function (event) {\n        let t = event.target;\n        while (t && t !== this) {\n            if (t.matches(sel)) {\n                handler.call(t, event);\n            }\n            t = t.parentNode;\n        }\n    };\n\n    if (act === true) {\n        if (document.addEventListener) {\n            el.addEventListener(evt, doit, options || { passive: false });\n        } else if (document.attachEvent) {\n            el.attachEvent(`on${evt}`, doit);\n        } else {\n            el[`on${evt}`] = doit;\n        }\n    } else {\n        if (document.removeEventListener) {\n            el.removeEventListener(evt, doit, options || { passive: false });\n        } else if (document.detachEvent) {\n            el.detachEvent(`on${evt}`, doit);\n        } else {\n            el[`on${evt}`] = null;\n        }\n    }\n}\n\nfunction isIterable(obj) {\n    return isDef(obj) &&\n        typeof obj === 'object' &&\n        (\n            Array.isArray(obj) ||\n            (\n                isDef(window.Symbol) &&\n                typeof obj[window.Symbol.iterator] === 'function'\n            ) ||\n            isDef(obj.forEach) ||\n            (\n                typeof (obj.length) === \"number\" &&\n                (obj.length === 0 ||\n                    (obj.length > 0 &&\n                        (obj.length - 1) in obj)\n                )\n            )\n        );\n}\n\nfunction helper(params) {\n    return new Helper(params);\n}\n\nclass Observable {\r\n\r\n    constructor() {\n        this.observers = {};\n    }\r\n\r\n    subscribe(eventName, sub) {\n        const obs = this.observers;\r\n\r\n        if (isUndef(obs[eventName])) {\n            Object.defineProperty(obs, eventName, {\r\n                value: []\r\n            });\n        }\r\n\r\n        obs[eventName].push(sub);\r\n\r\n        return this;\n    }\r\n\r\n    unsubscribe(eventName, f) {\n        const obs = this.observers;\r\n\r\n        if (isDef(obs[eventName])) {\n            const index = obs[eventName].indexOf(f);\r\n            obs[eventName].splice(index, 1);\n        }\r\n\r\n        return this;\n    }\r\n\r\n    notify(eventName, source, data) {\n        if (isUndef(this.observers[eventName])) return;\r\n\r\n        this.observers[eventName].forEach(observer => {\n            if (source === observer) return;\r\n            switch (eventName) {\n\r\n                case 'onmove':\r\n                    observer.notifyMove(data);\r\n                    break;\r\n                case 'onrotate':\r\n                    observer.notifyRotate(data);\r\n                    break;\r\n                case 'onresize':\r\n                    observer.notifyResize(data);\r\n                    break;\r\n                case 'onapply':\r\n                    observer.notifyApply(data);\r\n                    break;\r\n                case 'ongetstate':\r\n                    observer.notifyGetState(data);\r\n                    break;\r\n            \n            }\n        });\n    }\r\n\n}\n\nclass Event {\r\n\r\n    constructor(name) {\r\n        this.name = name;\r\n        this.callbacks = [];\r\n    }\r\n\r\n    registerCallback(cb) {\r\n        this.callbacks.push(cb);\r\n    }\r\n\r\n    removeCallback(cb) {\r\n        const ix = this.callbacks(cb);\r\n        this.callbacks.splice(ix, 1);\r\n    }\r\n\r\n}\r\n\r\nclass EventDispatcher {\r\n\r\n    constructor() {\r\n        this.events = {};\r\n    }\r\n\r\n    registerEvent(eventName) {\r\n        this.events[eventName] = new Event(eventName);\r\n    }\r\n\r\n    emit(ctx, eventName, eventArgs) {\r\n        this.events[eventName].callbacks.forEach((cb) => {\r\n            cb.call(ctx, eventArgs);\r\n        });\r\n    };\r\n    \r\n    addEventListener(eventName, cb) {\r\n        this.events[eventName].registerCallback(cb);\r\n    }\r\n\r\n    removeEventListener(eventName, cb) {\r\n        this.events[eventName].removeCallback(cb);\r\n    }\r\n\r\n}\n\nclass SubjectModel {\r\n\r\n    constructor(el) {\r\n        this.el = el;\r\n        this.storage = null;\r\n        this.proxyMethods = null;\r\n\r\n        this.eventDispatcher = new EventDispatcher();\r\n\r\n        this._onMouseDown = this._onMouseDown.bind(this);\r\n        this._onTouchStart = this._onTouchStart.bind(this);\r\n        this._onMouseMove = this._onMouseMove.bind(this);\r\n        this._onTouchMove = this._onTouchMove.bind(this);\r\n        this._onMouseUp = this._onMouseUp.bind(this);\r\n        this._onTouchEnd = this._onTouchEnd.bind(this);\r\n        this._animate = this._animate.bind(this);\r\n    }\r\n\r\n    enable(options) {\r\n        this._processOptions(options);\r\n        this._init(this.el);\r\n        this.proxyMethods.onInit.call(this, this.el);\r\n    }\r\n\r\n    disable() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _init() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _destroy() {\r\n        throwNotImplementedError();\r\n    }\r\n    \r\n    _processOptions() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _start() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _moving() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _end() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _animate() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _drag({ dx, dy, ...rest }) {\r\n        const transform = this._processMove(dx, dy);\r\n\r\n        const finalArgs = {\r\n            dx,\r\n            dy,\r\n            transform,\r\n            ...rest\r\n        };\r\n\r\n        this.proxyMethods.onMove.call(this, finalArgs);\r\n        this._emitEvent('drag', finalArgs);\r\n    }\r\n\r\n    _draw() {\r\n        this._animate();\r\n    }\r\n\r\n    _onMouseDown(e) {\r\n        this._start(e);\r\n        helper(document)\r\n            .on('mousemove', this._onMouseMove)\r\n            .on('mouseup', this._onMouseUp);\r\n    }\r\n\r\n    _onTouchStart(e) {\r\n        this._start(e.touches[0]);\r\n        helper(document)\r\n            .on('touchmove', this._onTouchMove)\r\n            .on('touchend', this._onTouchEnd);\r\n    }\r\n\r\n    _onMouseMove(e) {\r\n        if (e.preventDefault) {\r\n            e.preventDefault();\r\n        }\r\n        this._moving(\r\n            e,\r\n            this.el\r\n        );\r\n    }\r\n\r\n    _onTouchMove(e) {\r\n        if (e.preventDefault) {\r\n            e.preventDefault();\r\n        }\r\n        this._moving(\r\n            e.touches[0],\r\n            this.el\r\n        );\r\n    }\r\n\r\n    _onMouseUp(e) {\r\n        helper(document)\r\n            .off('mousemove', this._onMouseMove)\r\n            .off('mouseup', this._onMouseUp);\r\n\r\n        this._end(\r\n            e,\r\n            this.el\r\n        );\r\n    }\r\n\r\n    _onTouchEnd(e) {\r\n        helper(document)\r\n            .off('touchmove', this._onTouchMove)\r\n            .off('touchend', this._onTouchEnd);\r\n\r\n        if (e.touches.length === 0) {\r\n            this._end(\r\n                e.changedTouches[0],\r\n                this.el\r\n            );\r\n        }\r\n    }\r\n\r\n    _emitEvent() {\r\n        this.eventDispatcher.emit(this, ...arguments);\r\n    }\r\n\r\n    on(name, cb) {\r\n        this.eventDispatcher.addEventListener(name, cb);\r\n        return this;\r\n    }\r\n\r\n    off(name, cb) {\r\n        this.eventDispatcher.removeEventListener(name, cb);\r\n        return this;\r\n    }\r\n\r\n}\r\n\r\nfunction throwNotImplementedError() {\r\n    throw Error(`Method not implemented`);\r\n}\n\nconst EVENTS = [\r\n    'dragStart',\r\n    'drag',\r\n    'dragEnd',\r\n    'resizeStart',\r\n    'resize',\r\n    'resizeEnd',\r\n    'rotateStart',\r\n    'rotate',\r\n    'rotateEnd',\r\n    'setPointStart',\r\n    'setPointEnd'\r\n];\n\nconst RAD = Math.PI / 180;\r\n\r\nfunction snapToGrid(value, snap) {\r\n    if (snap === 0) {\r\n        return value;\r\n    } else {\r\n        const result = snapCandidate(value, snap);\r\n\r\n        if (result - value < snap) {\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\nfunction snapCandidate(value, gridSize) {\r\n    if (gridSize === 0) return value;\r\n    return Math.round(value / gridSize) * gridSize;\r\n}\r\n\r\nfunction floatToFixed(val, size = 6) {\r\n    return Number(val.toFixed(size));\r\n}\n\nfunction getOffset(node) {\r\n    return node.getBoundingClientRect();\r\n}\r\n\r\nfunction getTransform(el) {\r\n    const transform = el.css('-webkit-transform') ||\r\n        el.css('-moz-transform') ||\r\n        el.css('-ms-transform') ||\r\n        el.css('-o-transform') ||\r\n        el.css('transform') ||\r\n        'none';\r\n    return transform;\r\n}\r\n\r\nfunction parseMatrix(value) {\r\n    const transform = value.match(/[+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g);\r\n\r\n    if (transform) {\r\n        return transform.map(item => {\r\n            return parseFloat(item);\r\n        });\r\n    } else {\r\n        return [1, 0, 0, 1, 0, 0];\r\n    }\r\n}\r\n\r\nfunction addClass(node, cls) {\r\n    if (!cls) return;\r\n\r\n    if (node.classList) {\r\n        if (cls.indexOf(' ') > -1) {\r\n            cls.split(/\\s+/).forEach(cl => {\r\n                return node.classList.add(cl);\r\n            });\r\n        } else {\r\n            return node.classList.add(cls);\r\n        }\r\n    }\r\n    return node;\r\n}\r\n\r\nfunction removeClass(node, cls) {\r\n    if (!cls) return;\r\n\r\n    if (node.classList) {\r\n        if (cls.indexOf(' ') > -1) {\r\n            cls.split(/\\s+/).forEach(cl => {\r\n                return node.classList.remove(cl);\r\n            });\r\n        } else {\r\n            return node.classList.remove(cls);\r\n        }\r\n    }\r\n    return node;\r\n}\r\n\r\nfunction objectsCollide(a, b) {\r\n    const {\r\n            top: aTop,\r\n            left: aLeft\r\n        } = getOffset(a),\r\n        {\r\n            top: bTop,\r\n            left: bLeft\r\n        } = getOffset(b),\r\n        _a = helper(a),\r\n        _b = helper(b);\r\n\r\n    return !(\r\n        ((aTop < bTop) ||\r\n            (aTop + parseFloat(_a.css('height'))) > (bTop + parseFloat(_b.css('height')))) ||\r\n        ((aLeft < bLeft) ||\r\n            (aLeft + parseFloat(_a.css('width'))) > (bLeft + parseFloat(_b.css('width'))))\r\n    );\r\n}\r\n\r\nfunction matrixToCSS(arr) {\r\n    const style = `matrix(${arr.join()})`;\r\n\r\n    return {\r\n        transform: style,\r\n        webkitTranform: style,\r\n        mozTransform: style,\r\n        msTransform: style,\r\n        otransform: style\r\n    };\r\n}\n\nclass Transformable extends SubjectModel {\r\n\r\n    constructor(el, options, observable) {\r\n        super(el);\r\n        if (this.constructor === Transformable) {\r\n            throw new TypeError('Cannot construct Transformable instances directly');\r\n        }\r\n        this.observable = observable;\r\n\r\n        EVENTS.forEach((eventName) => {\r\n            this.eventDispatcher.registerEvent(eventName);\r\n        });\r\n        \r\n        this.enable(options);\r\n    }\r\n\r\n    _cursorPoint() {\r\n        throw Error(`'_cursorPoint()' method not implemented`);\r\n    }\r\n\r\n    _rotate({ radians, ...rest }) {\r\n        const resultMtrx = this._processRotate(radians);\r\n        const finalArgs = {\r\n            transform: resultMtrx,\r\n            delta: radians,\r\n            ...rest\r\n        };\r\n        this.proxyMethods.onRotate.call(this, finalArgs);\r\n        this._emitEvent('rotate', finalArgs);\r\n    }\r\n\r\n    _resize({ dx, dy, ...rest }) {\r\n        const finalValues = this._processResize(dx, dy);\r\n        const finalArgs = {\r\n            ...finalValues,\r\n            dx,\r\n            dy,\r\n            ...rest\r\n        };\r\n        this.proxyMethods.onResize.call(this, finalArgs);\r\n        this._emitEvent('resize', finalArgs);\r\n    }\r\n\r\n    _processOptions(options) {\r\n        const { el } = this;\r\n\r\n        addClass(el, 'sjx-drag');\r\n\r\n        const _snap = {\r\n            x: 10,\r\n            y: 10,\r\n            angle: 10 * RAD\r\n        };\r\n\r\n        const _each = {\r\n            move: false,\r\n            resize: false,\r\n            rotate: false\r\n        };\r\n\r\n        let _restrict = null,\r\n            _proportions = false,\r\n            _axis = 'xy',\r\n            _cursorMove = 'auto',\r\n            _cursorResize = 'auto',\r\n            _cursorRotate = 'auto',\r\n            _themeColor = '#00a8ff',\r\n            _rotationPoint = false,\r\n            _draggable = true,\r\n            _resizable = true,\r\n            _rotatable = true,\r\n            _onInit = () => { },\r\n            _onMove = () => { },\r\n            _onRotate = () => { },\r\n            _onResize = () => { },\r\n            _onDrop = () => { },\r\n            _onDestroy = () => { };\r\n\r\n        let _container = el.parentNode;\r\n\r\n        if (isDef(options)) {\r\n            const {\r\n                snap,\r\n                each,\r\n                axis,\r\n                cursorMove,\r\n                cursorResize,\r\n                cursorRotate,\r\n                rotationPoint,\r\n                restrict,\r\n                draggable,\r\n                resizable,\r\n                rotatable,\r\n                onInit,\r\n                onDrop,\r\n                onMove,\r\n                onResize,\r\n                onRotate,\r\n                onDestroy,\r\n                container,\r\n                proportions,\r\n                themeColor\r\n            } = options;\r\n\r\n            if (isDef(snap)) {\r\n                const { x, y, angle } = snap;\r\n\r\n                _snap.x = isUndef(x) ? 10 : x;\r\n                _snap.y = isUndef(y) ? 10 : y;\r\n                _snap.angle = isUndef(angle)\r\n                    ? _snap.angle\r\n                    : angle * RAD;\r\n            }\r\n\r\n            if (isDef(each)) {\r\n                const { move, resize, rotate } = each;\r\n\r\n                _each.move = move || false;\r\n                _each.resize = resize || false;\r\n                _each.rotate = rotate || false;\r\n            }\r\n\r\n            if (isDef(restrict)) {\r\n                _restrict = restrict === 'parent'\r\n                    ? el.parentNode\r\n                    : helper(restrict)[0] || document;\r\n            }\r\n\r\n            _themeColor = themeColor || '#00a8ff';\r\n            _cursorMove = cursorMove || 'auto';\r\n            _cursorResize = cursorResize || 'auto';\r\n            _cursorRotate = cursorRotate || 'auto';\r\n            _axis = axis || 'xy';\r\n\r\n            _container = isDef(container) && helper(container)[0]\r\n                ? helper(container)[0]\r\n                : _container;\r\n\r\n            _rotationPoint = rotationPoint || false;\r\n            _proportions = proportions || false;\r\n\r\n            _draggable = isDef(draggable) ? draggable : true;\r\n            _resizable = isDef(resizable) ? resizable : true;\r\n            _rotatable = isDef(rotatable) ? rotatable : true;\r\n\r\n            _onInit = createMethod(onInit);\r\n            _onDrop = createMethod(onDrop);\r\n            _onMove = createMethod(onMove);\r\n            _onResize = createMethod(onResize);\r\n            _onRotate = createMethod(onRotate);\r\n            _onDestroy = createMethod(onDestroy);\r\n        }\r\n\r\n        this.options = {\r\n            axis: _axis,\r\n            themeColor: _themeColor,\r\n            cursorMove: _cursorMove,\r\n            cursorRotate: _cursorRotate,\r\n            cursorResize: _cursorResize,\r\n            rotationPoint: _rotationPoint,\r\n            restrict: _restrict,\r\n            container: _container,\r\n            snap: _snap,\r\n            each: _each,\r\n            proportions: _proportions,\r\n            draggable: _draggable,\r\n            resizable: _resizable,\r\n            rotatable: _rotatable\r\n        };\r\n\r\n        this.proxyMethods = {\r\n            onInit: _onInit,\r\n            onDrop: _onDrop,\r\n            onMove: _onMove,\r\n            onResize: _onResize,\r\n            onRotate: _onRotate,\r\n            onDestroy: _onDestroy\r\n        };\r\n\r\n        this.subscribe(_each);\r\n    }\r\n\r\n    _animate() {\r\n        const self = this;\r\n        const {\r\n            observable,\r\n            storage,\r\n            options\r\n        } = self;\r\n\r\n        if (isUndef(storage)) return;\r\n\r\n        storage.frame = requestAnimFrame(self._animate);\r\n\r\n        if (!storage.doDraw) return;\r\n        storage.doDraw = false;\r\n\r\n        let {\r\n            dox,\r\n            doy,\r\n            clientX,\r\n            clientY,\r\n            doDrag,\r\n            doResize,\r\n            doRotate,\r\n            doSetCenter,\r\n            revX,\r\n            revY\r\n        } = storage;\r\n\r\n        const {\r\n            snap,\r\n            each: {\r\n                move: moveEach,\r\n                resize: resizeEach,\r\n                rotate: rotateEach\r\n            },\r\n            restrict,\r\n            draggable,\r\n            resizable,\r\n            rotatable\r\n        } = options;\r\n\r\n        if (doResize && resizable) {\r\n            const {\r\n                transform,\r\n                cx,\r\n                cy\r\n            } = storage;\r\n\r\n            const { x, y } = this._pointToElement(\r\n                {\r\n                    x: clientX,\r\n                    y: clientY\r\n                }\r\n            );\r\n\r\n            let dx = dox\r\n                ? snapToGrid(x - cx, snap.x / transform.scX)\r\n                : 0;\r\n\r\n            let dy = doy\r\n                ? snapToGrid(y - cy, snap.y / transform.scY)\r\n                : 0;\r\n\r\n            dx = dox ? (revX ? - dx : dx) : 0,\r\n            dy = doy ? (revY ? - dy : dy) : 0;\r\n\r\n            const args = {\r\n                dx,\r\n                dy,\r\n                clientX,\r\n                clientY\r\n            };\r\n\r\n            self._resize(args);\r\n\r\n            if (resizeEach) {\r\n                observable.notify(\r\n                    'onresize',\r\n                    self,\r\n                    args\r\n                );\r\n            }\r\n        }\r\n\r\n        if (doDrag && draggable) {\r\n            const {\r\n                restrictOffset,\r\n                elementOffset,\r\n                nx,\r\n                ny\r\n            } = storage;\r\n\r\n            if (isDef(restrict)) {\r\n                if ((clientX - restrictOffset.left) < nx - elementOffset.left) {\r\n                    clientX = nx - elementOffset.left + restrictOffset.left;\r\n                }\r\n\r\n                if ((clientY - restrictOffset.top) < ny - elementOffset.top) {\r\n                    clientY = ny - elementOffset.top + restrictOffset.top;\r\n                }\r\n            }\r\n\r\n            const dx = dox\r\n                ? snapToGrid(clientX - nx, snap.x)\r\n                : 0;\r\n\r\n            const dy = doy\r\n                ? snapToGrid(clientY - ny, snap.y)\r\n                : 0;\r\n\r\n            const args = {\r\n                dx,\r\n                dy,\r\n                clientX,\r\n                clientY\r\n            };\r\n\r\n            self._drag(\r\n                args\r\n            );\r\n\r\n            if (moveEach) {\r\n                observable.notify('onmove',\r\n                    self,\r\n                    args\r\n                );\r\n            }\r\n        }\r\n\r\n        if (doRotate && rotatable) {\r\n            const {\r\n                pressang,\r\n                center\r\n            } = storage;\r\n\r\n            const radians = Math.atan2(\r\n                clientY - center.y,\r\n                clientX - center.x\r\n            ) - pressang;\r\n\r\n            const args = {\r\n                clientX,\r\n                clientY\r\n            };\r\n\r\n            self._rotate(\r\n                {\r\n                    radians: snapToGrid(radians, snap.angle),\r\n                    ...args\r\n                }\r\n            );\r\n\r\n            if (rotateEach) {\r\n                observable.notify('onrotate',\r\n                    self,\r\n                    {\r\n                        radians,\r\n                        ...args\r\n                    }\r\n                );\r\n            }\r\n        }\r\n\r\n        if (doSetCenter && rotatable) {\r\n            const {\r\n                bx,\r\n                by\r\n            } = storage;\r\n\r\n            const { x, y } = this._pointToControls(\r\n                {\r\n                    x: clientX,\r\n                    y: clientY\r\n                }\r\n            );\r\n\r\n            self._moveCenterHandle(\r\n                x - bx,\r\n                y - by\r\n            );\r\n        }\r\n    }\r\n\r\n    _start(e) {\r\n        const {\r\n            observable,\r\n            storage,\r\n            options: { axis, restrict, each },\r\n            el\r\n        } = this;\r\n\r\n        const computed = this._compute(e);\r\n\r\n        Object.keys(computed).forEach(prop => {\r\n            storage[prop] = computed[prop];\r\n        });\r\n\r\n        const {\r\n            onRightEdge,\r\n            onBottomEdge,\r\n            onTopEdge,\r\n            onLeftEdge,\r\n            handle,\r\n            factor,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        } = computed;\r\n\r\n        const doResize =\r\n            onRightEdge ||\r\n            onBottomEdge ||\r\n            onTopEdge ||\r\n            onLeftEdge;\r\n\r\n        const {\r\n            handles\r\n        } = storage;\r\n\r\n        const {\r\n            rotator,\r\n            center,\r\n            radius\r\n        } = handles;\r\n\r\n        if (isDef(radius)) {\r\n            removeClass(radius, 'sjx-hidden');\r\n        }\r\n\r\n        const doRotate = handle.is(rotator),\r\n            doSetCenter = isDef(center)\r\n                ? handle.is(center)\r\n                : false;\r\n\r\n        const doDrag = !(doRotate || doResize || doSetCenter);\r\n\r\n        const {\r\n            clientX,\r\n            clientY\r\n        } = e;\r\n\r\n        const {\r\n            x,\r\n            y\r\n        } = this._cursorPoint(\r\n            {\r\n                clientX,\r\n                clientY\r\n            }\r\n        );\r\n\r\n        const {\r\n            x: nx,\r\n            y: ny\r\n        } = this._pointToElement({ x, y });\r\n\r\n        const {\r\n            x: bx,\r\n            y: by\r\n        } = this._pointToControls({ x, y });\r\n\r\n        const newStorageValues = {\r\n            clientX,\r\n            clientY,\r\n            nx: x,\r\n            ny: y,\r\n            cx: nx,\r\n            cy: ny,\r\n            bx,\r\n            by,\r\n            doResize,\r\n            doDrag,\r\n            doRotate,\r\n            doSetCenter,\r\n            onExecution: true,\r\n            cursor: null,\r\n            elementOffset: getOffset(el),\r\n            restrictOffset: isDef(restrict)\r\n                ? getOffset(restrict)\r\n                : null,\r\n            dox: /\\x/.test(axis) && (doResize\r\n                ?\r\n                handle.is(handles.ml) ||\r\n                handle.is(handles.mr) ||\r\n                handle.is(handles.tl) ||\r\n                handle.is(handles.tr) ||\r\n                handle.is(handles.bl) ||\r\n                handle.is(handles.br)\r\n                : true),\r\n            doy: /\\y/.test(axis) && (doResize\r\n                ?\r\n                handle.is(handles.br) ||\r\n                handle.is(handles.bl) ||\r\n                handle.is(handles.bc) ||\r\n                handle.is(handles.tr) ||\r\n                handle.is(handles.tl) ||\r\n                handle.is(handles.tc)\r\n                : true)\r\n        };\r\n\r\n        this.storage = {\r\n            ...storage,\r\n            ...newStorageValues\r\n        };\r\n\r\n        const eventArgs = {\r\n            clientX,\r\n            clientY\r\n        };\r\n\r\n        if (doResize) {\r\n            this._emitEvent('resizeStart', eventArgs);\r\n        } else if (doRotate) {\r\n            this._emitEvent('rotateStart', eventArgs);\r\n        } else if (doDrag) {\r\n            this._emitEvent('dragStart', eventArgs);\r\n        }\r\n\r\n        const {\r\n            move,\r\n            resize,\r\n            rotate\r\n        } = each;\r\n\r\n        const actionName = doResize\r\n            ? 'resize'\r\n            : (doRotate? 'rotate' : 'drag');\r\n        \r\n        const triggerEvent = \r\n            (doResize && resize) ||\r\n            (doRotate && rotate) ||\r\n            (doDrag && move);\r\n\r\n        observable.notify(\r\n            'ongetstate',\r\n            this,\r\n            {   \r\n                clientX,\r\n                clientY,\r\n                actionName,\r\n                triggerEvent,\r\n                factor,\r\n                revX,\r\n                revY,\r\n                doW,\r\n                doH\r\n            }\r\n        );\r\n        \r\n        this._draw();\r\n    }\r\n\r\n    _moving(e) {\r\n        const {\r\n            storage,\r\n            options\r\n        } = this;\r\n\r\n        const {\r\n            x,\r\n            y\r\n        } = this._cursorPoint(e);\r\n\r\n        storage.e = e;\r\n        storage.clientX = x;\r\n        storage.clientY = y;\r\n        storage.doDraw = true;\r\n\r\n        let {\r\n            doRotate,\r\n            doDrag,\r\n            doResize,\r\n            cursor\r\n        } = storage;\r\n\r\n        const {\r\n            cursorMove,\r\n            cursorResize,\r\n            cursorRotate\r\n        } = options;\r\n\r\n        if (isUndef(cursor)) {\r\n            if (doDrag) {\r\n                cursor = cursorMove;\r\n            } else if (doRotate) {\r\n                cursor = cursorRotate;\r\n            } else if (doResize) {\r\n                cursor = cursorResize;\r\n            }\r\n            helper(document.body).css({ cursor });\r\n        }\r\n    }\r\n\r\n    _end({ clientX, clientY }) {\r\n        const {\r\n            options: { each },\r\n            observable,\r\n            storage,\r\n            proxyMethods\r\n        } = this;\r\n\r\n        const {\r\n            doResize,\r\n            doDrag,\r\n            doRotate,\r\n            //doSetCenter,\r\n            frame,\r\n            handles: { radius }\r\n        } = storage;\r\n\r\n        const actionName = doResize\r\n            ? 'resize'\r\n            : (doDrag ? 'drag' : 'rotate');\r\n\r\n        storage.doResize = false;\r\n        storage.doDrag = false;\r\n        storage.doRotate = false;\r\n        storage.doSetCenter = false;\r\n        storage.doDraw = false;\r\n        storage.onExecution = false;\r\n        storage.cursor = null;\r\n\r\n        this._apply(actionName);\r\n\r\n        const eventArgs = {\r\n            clientX, \r\n            clientY\r\n        };\r\n\r\n        proxyMethods.onDrop.call(this, eventArgs);\r\n\r\n        if (doResize) {\r\n            this._emitEvent('resizeEnd', eventArgs);\r\n        } else if (doRotate) {\r\n            this._emitEvent('rotateEnd', eventArgs);\r\n        } else if (doDrag) {\r\n            this._emitEvent('dragEnd', eventArgs);\r\n        }\r\n\r\n        const {\r\n            move,\r\n            resize,\r\n            rotate\r\n        } = each;\r\n\r\n        const triggerEvent = \r\n            (doResize && resize) ||\r\n            (doRotate && rotate) ||\r\n            (doDrag && move);\r\n\r\n        observable.notify(\r\n            'onapply',\r\n            this,\r\n            {\r\n                clientX, \r\n                clientY,\r\n                actionName,\r\n                triggerEvent\r\n            }\r\n        );\r\n\r\n        cancelAnimFrame(frame);\r\n\r\n        helper(document.body).css({ cursor: 'auto' });\r\n        if (isDef(radius)) {\r\n            addClass(radius, 'sjx-hidden');\r\n        }  \r\n    }\r\n\r\n    _compute(e) {\r\n        const {\r\n            handles\r\n        } = this.storage;\r\n\r\n        const handle = helper(e.target);\r\n\r\n        const {\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH,\r\n            ...rest\r\n        } = this._checkHandles(handle, handles);\r\n\r\n        const _computed = this._getState({\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        });\r\n\r\n        const {\r\n            x: clientX,\r\n            y: clientY\r\n        } = this._cursorPoint(e);\r\n\r\n        const pressang = Math.atan2(\r\n            clientY - _computed.center.y,\r\n            clientX - _computed.center.x\r\n        );\r\n\r\n        return {\r\n            ..._computed,\r\n            ...rest,\r\n            handle,\r\n            pressang\r\n        };\r\n    }\r\n\r\n    _checkHandles(handle, handles) {\r\n        const { tl, tc, tr, bl, br, bc, ml, mr } = handles;\r\n        const isTL = isDef(tl) ? handle.is(tl) : false,\r\n            isTC = isDef(tc) ? handle.is(tc) : false,\r\n            isTR = isDef(tr) ? handle.is(tr) : false,\r\n            isBL = isDef(bl) ? handle.is(bl) : false,\r\n            isBC = isDef(bc) ? handle.is(bc) : false,\r\n            isBR = isDef(br) ? handle.is(br) : false,\r\n            isML = isDef(ml) ? handle.is(ml) : false,\r\n            isMR = isDef(mr) ? handle.is(mr) : false;\r\n\r\n        //reverse axis\r\n        const revX = isTL || isML || isBL || isTC,\r\n            revY = isTL || isTR || isTC || isML;\r\n\r\n        const onTopEdge = isTC || isTR || isTL,\r\n            onLeftEdge = isTL || isML || isBL,\r\n            onRightEdge = isTR || isMR || isBR,\r\n            onBottomEdge = isBR || isBC || isBL;\r\n\r\n        const doW = isML || isMR,\r\n            doH = isTC || isBC;\r\n\r\n        return {\r\n            revX,\r\n            revY,\r\n            onTopEdge,\r\n            onLeftEdge,\r\n            onRightEdge,\r\n            onBottomEdge,\r\n            doW,\r\n            doH\r\n        };\r\n    }\r\n\r\n    notifyMove() {\r\n        this._drag(...arguments);\r\n    }\r\n\r\n    notifyRotate({ radians, ...rest }) {\r\n        const {\r\n            snap: { angle }\r\n        } = this.options;\r\n\r\n        this._rotate(\r\n            {\r\n                radians: snapToGrid(radians, angle),\r\n                ...rest\r\n            }\r\n        );\r\n    }\r\n\r\n    notifyResize() {\r\n        this._resize(...arguments);\r\n    }\r\n\r\n    notifyApply({ clientX, clientY, actionName, triggerEvent }) {\r\n        this.proxyMethods.onDrop.call(this, { clientX, clientY });\r\n        if (triggerEvent) {\r\n            this._apply(actionName);\r\n            this._emitEvent(`${actionName}End`, { clientX, clientY });\r\n        }\r\n    }\r\n\r\n    notifyGetState({ clientX, clientY, actionName, triggerEvent, ...rest}) {\r\n        if (triggerEvent) {\r\n            const recalc = this._getState(\r\n                rest\r\n            );\r\n    \r\n            this.storage = {\r\n                ...this.storage,\r\n                ...recalc\r\n            };\r\n            this._emitEvent(`${actionName}Start`, { clientX, clientY });\r\n        }\r\n    }\r\n\r\n    subscribe({ resize, move, rotate }) {\r\n        const { observable: ob } = this;\r\n\r\n        if (move || resize || rotate) {\r\n            ob.subscribe('ongetstate', this)\r\n                .subscribe('onapply', this);\r\n        }\r\n\r\n        if (move) {\r\n            ob.subscribe('onmove', this);\r\n        }\r\n        if (resize) {\r\n            ob.subscribe('onresize', this);\r\n        }\r\n        if (rotate) {\r\n            ob.subscribe('onrotate', this);\r\n        }\r\n    }\r\n\r\n    unsubscribe() {\r\n        const { observable: ob } = this;\r\n\r\n        ob.unsubscribe('ongetstate', this)\r\n            .unsubscribe('onapply', this)\r\n            .unsubscribe('onmove', this)\r\n            .unsubscribe('onresize', this)\r\n            .unsubscribe('onrotate', this);\r\n    }\r\n\r\n    disable() {\r\n        const {\r\n            storage,\r\n            proxyMethods,\r\n            el\r\n        } = this;\r\n\r\n        if (isUndef(storage)) return;\r\n\r\n        // unexpected case\r\n        if (storage.onExecution) {\r\n            this._end();\r\n            helper(document)\r\n                .off('mousemove', this._onMouseMove)\r\n                .off('mouseup', this._onMouseUp)\r\n                .off('touchmove', this._onTouchMove)\r\n                .off('touchend', this._onTouchEnd);\r\n        }\r\n\r\n        removeClass(el, 'sjx-drag');\r\n\r\n        this._destroy();\r\n        this.unsubscribe();\r\n\r\n        proxyMethods.onDestroy.call(this, el);\r\n        delete this.storage;\r\n    }\r\n\r\n    exeDrag({ dx, dy }) {\r\n        const { draggable } = this.options;\r\n        if (!draggable) return;\r\n    \r\n        this.storage = {\r\n            ...this.storage,\r\n            ...this._getState({ \r\n                revX: false, \r\n                revY: false, \r\n                doW: false, \r\n                doH: false \r\n            })\r\n        };\r\n\r\n        this._drag({ dx, dy });\r\n        this._apply('drag');\r\n    }\r\n\r\n    exeResize({ dx, dy, revX, revY, doW, doH }) {\r\n        const { resizable } = this.options;\r\n        if (!resizable) return;\r\n\r\n        this.storage = {\r\n            ...this.storage,\r\n            ...this._getState({ \r\n                revX: revX || false,\r\n                revY: revY || false,\r\n                doW: doW || false,\r\n                doH: doH || false\r\n            })\r\n        };\r\n\r\n        this._resize({ dx, dy });\r\n        this._apply('resize');\r\n    }\r\n\r\n    exeRotate({ delta }) {\r\n        const { rotatable } = this.options;\r\n        if (!rotatable) return;\r\n\r\n        this.storage = {\r\n            ...this.storage,\r\n            ...this._getState({ \r\n                revX: false, \r\n                revY: false, \r\n                doW: false, \r\n                doH: false \r\n            })\r\n        };\r\n\r\n        this._rotate({ radians: delta });\r\n        this._apply('rotate');\r\n    }\r\n\r\n}\n\nfunction matrixTransform({ x, y }, matrix) {\r\n    const [a, b, c, d, e, f] = matrix;\r\n\r\n    return {\r\n        x: a * x + c * y + e,\r\n        y: b * x + d * y + f\r\n    };\r\n}\r\n\r\n//http://blog.acipo.com/matrix-inversion-in-javascript/\r\nfunction matrixInvert(ctm) {\r\n    // I use Guassian Elimination to calculate the inverse:\r\n    // (1) 'augment' the matrix (left) by the identity (on the right)\r\n    // (2) Turn the matrix on the left into the identity by elemetry row ops\r\n    // (3) The matrix on the right is the inverse (was the identity matrix)\r\n    // There are 3 elemtary row ops: (I combine b and c in my code)\r\n    // (a) Swap 2 rows\r\n    // (b) Multiply a row by a scalar\r\n    // (c) Add 2 rows\r\n\r\n    const M = [\r\n        [ctm[0], ctm[2], ctm[4]],\r\n        [ctm[1], ctm[3], ctm[5]],\r\n        [0, 0, 1]\r\n    ];\r\n\r\n    //if the matrix isn't square: exit (error)\r\n    if (M.length !== M[0].length) {\r\n        return;\r\n    }\r\n\r\n    //create the identity matrix (I), and a copy (C) of the original\r\n    const dim = M.length;\r\n\r\n    const I = [],\r\n        C = [];\r\n\r\n    for (let i = 0; i < dim; i += 1) {\r\n        // Create the row\r\n        I[I.length] = [];\r\n        C[C.length] = [];\r\n        for (let j = 0; j < dim; j += 1) {\r\n            //if we're on the diagonal, put a 1 (for identity)\r\n            if (i == j) {\r\n                I[i][j] = 1;\r\n            } else {\r\n                I[i][j] = 0;\r\n            }\r\n\r\n            // Also, make the copy of the original\r\n            C[i][j] = M[i][j];\r\n        }\r\n    }\r\n\r\n    // Perform elementary row operations\r\n    for (let i = 0; i < dim; i += 1) {\r\n        // get the element e on the diagonal\r\n        let e = C[i][i];\r\n\r\n        // if we have a 0 on the diagonal (we'll need to swap with a lower row)\r\n        if (e === 0) {\r\n            //look through every row below the i'th row\r\n            for (let ii = i + 1; ii < dim; ii += 1) {\r\n                //if the ii'th row has a non-0 in the i'th col\r\n                if (C[ii][i] !== 0) {\r\n                    //it would make the diagonal have a non-0 so swap it\r\n                    for (let j = 0; j < dim; j++) {\r\n                        e = C[i][j]; //temp store i'th row\r\n                        C[i][j] = C[ii][j]; //replace i'th row by ii'th\r\n                        C[ii][j] = e; //repace ii'th by temp\r\n                        e = I[i][j]; //temp store i'th row\r\n                        I[i][j] = I[ii][j]; //replace i'th row by ii'th\r\n                        I[ii][j] = e; //repace ii'th by temp\r\n                    }\r\n                    //don't bother checking other rows since we've swapped\r\n                    break;\r\n                }\r\n            }\r\n            //get the new diagonal\r\n            e = C[i][i];\r\n            //if it's still 0, not invertable (error)\r\n            if (e === 0) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Scale this row down by e (so we have a 1 on the diagonal)\r\n        for (let j = 0; j < dim; j++) {\r\n            C[i][j] = C[i][j] / e; //apply to original matrix\r\n            I[i][j] = I[i][j] / e; //apply to identity\r\n        }\r\n\r\n        // Subtract this row (scaled appropriately for each row) from ALL of\r\n        // the other rows so that there will be 0's in this column in the\r\n        // rows above and below this one\r\n        for (let ii = 0; ii < dim; ii++) {\r\n            // Only apply to other rows (we want a 1 on the diagonal)\r\n            if (ii == i) {\r\n                continue;\r\n            }\r\n\r\n            // We want to change this element to 0\r\n            e = C[ii][i];\r\n\r\n            // Subtract (the row above(or below) scaled by e) from (the\r\n            // current row) but start at the i'th column and assume all the\r\n            // stuff left of diagonal is 0 (which it should be if we made this\r\n            // algorithm correctly)\r\n            for (let j = 0; j < dim; j++) {\r\n                C[ii][j] -= e * C[i][j]; //apply to original matrix\r\n                I[ii][j] -= e * I[i][j]; //apply to identity\r\n            }\r\n        }\r\n    }\r\n\r\n    //we've done all operations, C should be the identity\r\n    //matrix I should be the inverse:\r\n    return [\r\n        I[0][0], I[1][0],\r\n        I[0][1], I[1][1],\r\n        I[0][2], I[1][2]\r\n    ];\r\n}\r\n\r\nfunction multiplyMatrix(\r\n    [a1, b1, c1, d1, e1, f1], \r\n    [a2, b2, c2, d2, e2, f2]\r\n) {\r\n    const m1 = [\r\n        [a1, c1, e1],\r\n        [b1, d1, f1],\r\n        [0, 0, 1]\r\n    ];\r\n\r\n    const m2 = [\r\n        [a2, c2, e2],\r\n        [b2, d2, f2],\r\n        [0, 0, 1]\r\n    ];\r\n\r\n    const result = [];\r\n\r\n    for (let j = 0; j < m2.length; j++) {\r\n        result[j] = [];\r\n        for (let k = 0; k < m1[0].length; k++) {\r\n            let sum = 0;\r\n            for (let i = 0; i < m1.length; i++) {\r\n                sum += m1[i][k] * m2[j][i];\r\n            }\r\n            result[j].push(sum);\r\n        }\r\n    }\r\n\r\n    return [\r\n        result[0][0], result[1][0],\r\n        result[0][1], result[1][1],\r\n        result[0][2], result[1][2]\r\n    ];\r\n}\r\n\r\nfunction rotatedTopLeft(\r\n    x,\r\n    y,\r\n    width,\r\n    height,\r\n    rotationAngle,\r\n    revX,\r\n    revY,\r\n    doW,\r\n    doH\r\n) {\r\n    const hw = parseFloat(width) / 2,\r\n        hh = parseFloat(height) / 2;\r\n\r\n    const cx = x + hw,\r\n        cy = y + hh;\r\n\r\n    const dx = x - cx,\r\n        dy = y - cy;\r\n\r\n    const originalTopLeftAngle = Math.atan2(doW ? 0 : dy, doH ? 0 : dx);\r\n    const rotatedTopLeftAngle = originalTopLeftAngle + rotationAngle;\r\n\r\n    const radius = Math.sqrt(Math.pow(doH ? 0 : hw, 2) + Math.pow(doW ? 0 : hh, 2));\r\n\r\n    let cos = Math.cos(rotatedTopLeftAngle),\r\n        sin = Math.sin(rotatedTopLeftAngle);\r\n\r\n    cos = revX === true ? -cos : cos;\r\n    sin = revY === true ? -sin : sin;\r\n\r\n    const rx = cx + radius * cos,\r\n        ry = cy + radius * sin;\r\n\r\n    return {\r\n        left: floatToFixed(rx),\r\n        top: floatToFixed(ry)\r\n    };\r\n}\n\nconst MIN_SIZE = 2;\r\nconst CENTER_DELTA = 7;\r\n\r\nclass Draggable extends Transformable {\r\n\r\n    _init(el) {\r\n        const {\r\n            rotationPoint,\r\n            container,\r\n            resizable,\r\n            rotatable\r\n        } = this.options;\r\n\r\n        const {\r\n            left,\r\n            top,\r\n            width,\r\n            height\r\n        } = el.style;\r\n\r\n        const wrapper = document.createElement('div');\r\n        addClass(wrapper, 'sjx-wrapper');\r\n        container.appendChild(wrapper);\r\n\r\n        const $el = helper(el);\r\n\r\n        const w = width || $el.css('width'),\r\n            h = height || $el.css('height'),\r\n            t = top || $el.css('top'),\r\n            l = left || $el.css('left');\r\n\r\n        const css = {\r\n            top: t,\r\n            left: l,\r\n            width: w,\r\n            height: h,\r\n            transform: getTransform($el)\r\n        };\r\n\r\n        const controls = document.createElement('div');\r\n        addClass(controls, 'sjx-controls');\r\n\r\n        const resizingHandles = {\r\n            tl: ['sjx-hdl', 'sjx-hdl-t', 'sjx-hdl-l', 'sjx-hdl-tl'],\r\n            tr: ['sjx-hdl', 'sjx-hdl-t', 'sjx-hdl-r', 'sjx-hdl-tr'],\r\n            br: ['sjx-hdl', 'sjx-hdl-b', 'sjx-hdl-r', 'sjx-hdl-br'],\r\n            bl: ['sjx-hdl', 'sjx-hdl-b', 'sjx-hdl-l', 'sjx-hdl-bl'],\r\n            tc: ['sjx-hdl', 'sjx-hdl-t', 'sjx-hdl-c', 'sjx-hdl-tc'],\r\n            bc: ['sjx-hdl', 'sjx-hdl-b', 'sjx-hdl-c', 'sjx-hdl-bc'],\r\n            ml: ['sjx-hdl', 'sjx-hdl-m', 'sjx-hdl-l', 'sjx-hdl-ml'],\r\n            mr: ['sjx-hdl', 'sjx-hdl-m', 'sjx-hdl-r', 'sjx-hdl-mr']\r\n        };\r\n\r\n        const rotationHandles = {\r\n            normal: ['sjx-normal'],\r\n            rotator: ['sjx-hdl', 'sjx-hdl-m', 'sjx-rotator']\r\n        };\r\n\r\n        const handles = {\r\n            ...(rotatable && rotationHandles),\r\n            ...(resizable && resizingHandles),\r\n            center: rotationPoint && rotatable ? ['sjx-hdl', 'sjx-hdl-m', 'sjx-hdl-c', 'sjx-hdl-mc'] : undefined\r\n        };\r\n\r\n        Object.keys(handles).forEach(key => {\r\n            const data = handles[key];\r\n            if (isUndef(data)) return;\r\n            const handler = createHandler(data);\r\n            handles[key] = handler;\r\n            controls.appendChild(handler);\r\n        });\r\n\r\n        if (isDef(handles.center)) {\r\n            const cHandle = helper(handles.center);\r\n            cHandle.css({\r\n                left: `${el.getAttribute('data-cx')}px`,\r\n                top: `${el.getAttribute('data-cy')}px`\r\n            });\r\n        }\r\n\r\n        wrapper.appendChild(controls);\r\n\r\n        const $controls = helper(controls);\r\n        $controls.css(css);\r\n\r\n        this.storage = {\r\n            controls,\r\n            handles,\r\n            radius: undefined,\r\n            parent: el.parentNode\r\n        };\r\n\r\n        $controls\r\n            .on('mousedown', this._onMouseDown)\r\n            .on('touchstart', this._onTouchStart);\r\n    }\r\n\r\n    _destroy() {\r\n        const {\r\n            controls\r\n        } = this.storage;\r\n\r\n        helper(controls)\r\n            .off('mousedown', this._onMouseDown)\r\n            .off('touchstart', this._onTouchStart);\r\n\r\n        const wrapper = controls.parentNode;\r\n        wrapper.parentNode.removeChild(wrapper);\r\n    }\r\n\r\n    _pointToElement({ x, y }) {\r\n        const {\r\n            transform\r\n        } = this.storage;\r\n\r\n        const ctm = [...transform.matrix];\r\n        ctm[4] = ctm[5] = 0;\r\n\r\n        return this._applyMatrixToPoint(\r\n            matrixInvert(ctm),\r\n            x,\r\n            y\r\n        );\r\n    }\r\n\r\n    _pointToControls(data) {\r\n        return this._pointToElement(data);\r\n    }\r\n\r\n    _applyMatrixToPoint(matrix, x, y) {\r\n        return matrixTransform(\r\n            {\r\n                x,\r\n                y\r\n            },\r\n            matrix\r\n        );\r\n    }\r\n\r\n    _cursorPoint({ clientX, clientY }) {\r\n        const {\r\n            container\r\n        } = this.options;\r\n\r\n        const globalMatrix = parseMatrix(\r\n            getTransform(helper(container))\r\n        );\r\n\r\n        return matrixTransform(\r\n            {\r\n                x: clientX,\r\n                y: clientY\r\n            },\r\n            matrixInvert(\r\n                globalMatrix\r\n            )\r\n        );\r\n    }\r\n\r\n    _apply() {\r\n        const {\r\n            el,\r\n            storage\r\n        } = this;\r\n\r\n        const {\r\n            // cached,\r\n            controls,\r\n            // transform,\r\n            handles\r\n        } = storage;\r\n\r\n        const $controls = helper(controls);\r\n\r\n        const cw = parseFloat($controls.css('width')),\r\n            ch = parseFloat($controls.css('height'));\r\n\r\n        const hW = cw / 2,\r\n            hH = ch / 2;\r\n\r\n        const {\r\n            center: cHandle\r\n        } = handles;\r\n\r\n        const isDefCenter = isDef(cHandle);\r\n\r\n        const centerX = isDefCenter\r\n            ? parseFloat(helper(cHandle).css('left'))\r\n            : hW;\r\n        const centerY = isDefCenter\r\n            ? parseFloat(helper(cHandle).css('top'))\r\n            : hH;\r\n\r\n        el.setAttribute('data-cx', centerX);\r\n        el.setAttribute('data-cy', centerY);\r\n\r\n        // if (isUndef(cached)) return;\r\n\r\n        // const $el = helper(el);\r\n\r\n        // const { dx, dy } = cached;\r\n\r\n        // const css = matrixToCSS(transform.matrix);\r\n\r\n        // const left = parseFloat(\r\n        //     el.style.left || $el.css('left')\r\n        // );\r\n\r\n        // const top = parseFloat(\r\n        //     el.style.top || $el.css('top')\r\n        // );\r\n\r\n        // css.left = `${left + dx}px`;\r\n        // css.top = `${top + dy}px`;\r\n\r\n        // $el.css(css);\r\n        // $controls.css(css);\r\n\r\n        this.storage.cached = null;\r\n    }\r\n\r\n    _processResize(dx, dy) {\r\n        const {\r\n            el,\r\n            storage,\r\n            options: { proportions }\r\n        } = this;\r\n\r\n        const {\r\n            controls,\r\n            coords,\r\n            cw,\r\n            ch,\r\n            transform,\r\n            refang,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        } = storage;\r\n\r\n        const ratio = doW || (!doW && !doH)\r\n            ? (cw + dx) / cw\r\n            : (ch + dy) / ch;\r\n\r\n        const newWidth = proportions ? cw * ratio : cw + dx,\r\n            newHeight = proportions ? ch * ratio : ch + dy;\r\n\r\n        if (newWidth < MIN_SIZE || newHeight < MIN_SIZE) return;\r\n\r\n        const matrix = [...transform.matrix];\r\n\r\n        const newCoords = rotatedTopLeft(\r\n            matrix[4],\r\n            matrix[5],\r\n            newWidth,\r\n            newHeight,\r\n            refang,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        );\r\n\r\n        const nx = coords.left - newCoords.left,\r\n            ny = coords.top - newCoords.top;\r\n\r\n        matrix[4] += nx;\r\n        matrix[5] += ny;\r\n\r\n        const css = matrixToCSS(matrix);\r\n\r\n        css.width = `${newWidth}px`;\r\n        css.height = `${newHeight}px`;\r\n\r\n        helper(controls).css(css);\r\n        helper(el).css(css);\r\n\r\n        storage.cached = {\r\n            dx: nx,\r\n            dy: ny\r\n        };\r\n        \r\n        return {\r\n            width: newWidth,\r\n            height: newHeight,\r\n            ox: nx,\r\n            oy: ny\r\n        };\r\n    }\r\n\r\n    _processMove(dx, dy) {\r\n        const {\r\n            el,\r\n            storage\r\n        } = this;\r\n\r\n        const {\r\n            controls,\r\n            transform: {\r\n                matrix,\r\n                parentMatrix\r\n            }\r\n        } = storage;\r\n\r\n        const pctm = [...parentMatrix];\r\n        pctm[4] = pctm[5] = 0;\r\n\r\n        const nMatrix = [...matrix];\r\n\r\n        nMatrix[4] = matrix[4] + dx;\r\n        nMatrix[5] = matrix[5] + dy;\r\n\r\n        const css = matrixToCSS(nMatrix);\r\n\r\n        helper(controls).css(css);\r\n        helper(el).css(css);\r\n\r\n        storage.cached = {\r\n            dx,\r\n            dy\r\n        };\r\n\r\n        return nMatrix;\r\n    }\r\n\r\n    _processRotate(radians) {\r\n        const {\r\n            el,\r\n            storage: {\r\n                controls,\r\n                transform,\r\n                center\r\n            }\r\n        } = this;\r\n\r\n        const {\r\n            matrix,\r\n            parentMatrix\r\n        } = transform;\r\n\r\n        const cos = floatToFixed(Math.cos(radians), 4),\r\n            sin = floatToFixed(Math.sin(radians), 4);\r\n\r\n        const translateMatrix = [\r\n            1,\r\n            0,\r\n            0,\r\n            1,\r\n            center.cx,\r\n            center.cy\r\n        ];\r\n\r\n        const rotMatrix = [\r\n            cos,\r\n            sin,\r\n            -sin,\r\n            cos,\r\n            0,\r\n            0\r\n        ];\r\n\r\n        const pctm = [...parentMatrix];\r\n        pctm[4] = pctm[5] = 0;\r\n\r\n        const resRotMatrix = multiplyMatrix(\r\n            matrixInvert(pctm),\r\n            multiplyMatrix(rotMatrix, pctm)\r\n        );\r\n\r\n        const nMatrix = multiplyMatrix(\r\n            multiplyMatrix(translateMatrix, resRotMatrix),\r\n            matrixInvert(translateMatrix)\r\n        );\r\n\r\n        const resMatrix = multiplyMatrix(nMatrix, matrix);\r\n\r\n        const css = matrixToCSS(resMatrix);\r\n\r\n        helper(controls).css(css);\r\n        helper(el).css(css);\r\n\r\n        return resMatrix;\r\n    }\r\n\r\n    _getState(params) {\r\n        const {\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        } = params;\r\n\r\n        const factor = revX !== revY\r\n            ? -1\r\n            : 1;\r\n\r\n        const {\r\n            el,\r\n            storage: {\r\n                handles,\r\n                controls,\r\n                parent\r\n            },\r\n            options: { container }\r\n        } = this;\r\n\r\n        const {\r\n            center: cHandle\r\n        } = handles;\r\n\r\n        const $controls = helper(controls);\r\n\r\n        const containerMatrix = parseMatrix(\r\n            getTransform(helper(container))\r\n        );\r\n\r\n        const matrix = parseMatrix(\r\n            getTransform(helper(controls))\r\n        );\r\n\r\n        const pMatrix = parseMatrix(\r\n            getTransform(helper(parent))\r\n        );\r\n\r\n        const refang = Math.atan2(\r\n            matrix[1], matrix[0]\r\n        ) * factor;\r\n\r\n        const parentMatrix = parent !== container\r\n            ? multiplyMatrix(\r\n                pMatrix,\r\n                containerMatrix\r\n            )\r\n            : containerMatrix;\r\n\r\n        const transform = {\r\n            matrix,\r\n            parentMatrix,\r\n            scX: Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]),\r\n            scY: Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3])\r\n        };\r\n\r\n        const cw = parseFloat($controls.css('width')),\r\n            ch = parseFloat($controls.css('height'));\r\n\r\n        // getting current coordinates considering rotation angle                                                                                                  \r\n        const coords = rotatedTopLeft(\r\n            matrix[4],\r\n            matrix[5],\r\n            cw,\r\n            ch,\r\n            refang,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        );\r\n\r\n        const hW = cw / 2,\r\n            hH = ch / 2;\r\n\r\n        const offset_ = getOffset(el),\r\n            isDefCenter = isDef(cHandle);\r\n\r\n        const centerX = isDefCenter\r\n            ? parseFloat(helper(cHandle).css('left'))\r\n            : hW;\r\n        const centerY = isDefCenter\r\n            ? parseFloat(helper(cHandle).css('top'))\r\n            : hH;\r\n\r\n        const cDelta = isDefCenter ? CENTER_DELTA : 0;\r\n\r\n        const { x: el_x, y: el_y } = matrixTransform(\r\n            {\r\n                x: offset_.left,\r\n                y: offset_.top\r\n            },\r\n            matrixInvert(parentMatrix)\r\n        );\r\n\r\n        return {\r\n            transform,\r\n            cw,\r\n            ch,\r\n            coords,\r\n            center: {\r\n                x: el_x + centerX - cDelta,\r\n                y: el_y + centerY - cDelta,\r\n                cx: -centerX + hW - cDelta,\r\n                cy: -centerY + hH - cDelta,\r\n                hx: centerX,\r\n                hy: centerY\r\n            },\r\n            factor,\r\n            refang,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        };\r\n    }\r\n\r\n    _moveCenterHandle(x, y) {\r\n        const { \r\n            handles: { center }, \r\n            center: { hx, hy }\r\n        } = this.storage;\r\n\r\n        const left = `${hx + x}px`,\r\n            top = `${hy + y}px`;\r\n\r\n        helper(center).css(\r\n            {\r\n                left,\r\n                top\r\n            }\r\n        );\r\n    }\r\n\r\n    resetCenterPoint() {\r\n        const {\r\n            handles: { center }\r\n        } = this.storage;\r\n\r\n        helper(center).css(\r\n            {\r\n                left: null,\r\n                top: null\r\n            }\r\n        );\r\n    }\r\n\r\n    fitControlsToSize() {}\r\n\r\n    get controls() {\r\n        return this.storage.controls;\r\n    }\r\n\r\n}\r\n\r\nfunction createHandler(classList) {\r\n    const element = document.createElement('div');\r\n    classList.forEach(cls => {\r\n        addClass(element, cls);\r\n    });\r\n    return element;\r\n}\n\nconst svgPoint = createSVGElement('svg').createSVGPoint();\r\nconst floatRE = /[+-]?\\d+(\\.\\d+)?/g;\r\n\r\nconst ALLOWED_ELEMENTS = [\r\n    'circle', 'ellipse',\r\n    'image', 'line',\r\n    'path', 'polygon',\r\n    'polyline', 'rect',\r\n    'text', 'g'\r\n];\r\n\r\nfunction checkChildElements(element) {\r\n    const arrOfElements = [];\r\n\r\n    if (isGroup(element)) {\r\n        forEach.call(element.childNodes, item => {\r\n            if (item.nodeType === 1) {\r\n                const tagName = item.tagName.toLowerCase();\r\n\r\n                if (ALLOWED_ELEMENTS.indexOf(tagName) !== -1) {\r\n                    if (tagName === 'g') {\r\n                        arrOfElements.push(...checkChildElements(item));\r\n                    }\r\n                    arrOfElements.push(item);\r\n                }\r\n            }\r\n        });\r\n    } else {\r\n        arrOfElements.push(element);\r\n    }\r\n\r\n    return arrOfElements;\r\n}\r\n\r\nfunction createSVGElement(name) {\r\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\r\n}\r\n\r\nfunction createSVGMatrix() {\r\n    return createSVGElement('svg').createSVGMatrix();\r\n}\r\n\r\nfunction getTransformToElement(toElement, g) {\r\n    const gTransform = g.getScreenCTM() || createSVGMatrix();\r\n    return gTransform.inverse().multiply(\r\n        toElement.getScreenCTM() || createSVGMatrix()\r\n    );\r\n}\r\n\r\nfunction matrixToString(m) {\r\n    const { a, b, c, d, e, f } = m;\r\n    return `matrix(${a},${b},${c},${d},${e},${f})`;\r\n}\r\n\r\nfunction pointTo(ctm, x, y) {\r\n    svgPoint.x = x;\r\n    svgPoint.y = y;\r\n    return svgPoint.matrixTransform(ctm);\r\n}\r\n\r\nfunction cloneMatrix(b) {\r\n    const a = createSVGMatrix();\r\n\r\n    a.a = b.a;\r\n    a.b = b.b;\r\n    a.c = b.c;\r\n    a.d = b.d;\r\n    a.e = b.e;\r\n    a.f = b.f;\r\n\r\n    return a;\r\n}\r\n\r\nfunction checkElement(el) {\r\n    const tagName = el.tagName.toLowerCase();\r\n\r\n    if (ALLOWED_ELEMENTS.indexOf(tagName) === -1) {\r\n        warn(\r\n            'Selected element is not allowed to transform. Allowed elements:\\n' +\r\n            'circle, ellipse, image, line, path, polygon, polyline, rect, text, g'\r\n        );\r\n        return false;\r\n    } else {\r\n        return true;\r\n    }\r\n}\r\n\r\nfunction isIdentity(matrix) {\r\n    const { a, b, c, d, e, f } = matrix;\r\n    return a === 1 &&\r\n        b === 0 &&\r\n        c === 0 &&\r\n        d === 1 &&\r\n        e === 0 &&\r\n        f === 0;\r\n}\r\n\r\nfunction createPoint(svg, x, y) {\r\n    if (isUndef(x) || isUndef(y)) {\r\n        return null;\r\n    }\r\n    const pt = svg.createSVGPoint();\r\n    pt.x = x;\r\n    pt.y = y;\r\n    return pt;\r\n}\r\n\r\nfunction isGroup(element) {\r\n    return element.tagName.toLowerCase() === 'g';\r\n}\r\n\r\nfunction parsePoints(pts) {\r\n    return pts.match(floatRE).reduce(\r\n        (result, value, index, array) => {\r\n            if (index % 2 === 0) {\r\n                result.push(array.slice(index, index + 2));\r\n            }\r\n            return result;\r\n        },\r\n        []\r\n    );\r\n}\n\nconst dRE = /\\s*([achlmqstvz])([^achlmqstvz]*)\\s*/gi;\r\nconst sepRE = /\\s*,\\s*|\\s+/g;\r\n\r\nfunction parsePath(path) {\r\n    let match = dRE.lastIndex = 0;\r\n\r\n    const serialized = [];\r\n\r\n    while ((match = dRE.exec(path))) {\r\n        const cmd = match[1];\r\n        const upCmd = cmd.toUpperCase();\r\n\r\n        // normalize the data\r\n        const data = match[2]\r\n            .replace(/([^e])-/g, '$1 -')\r\n            .replace(/ +/g, ' ');\r\n\r\n        serialized.push({\r\n            relative: cmd !== upCmd,\r\n            key: upCmd,\r\n            cmd: cmd,\r\n            values: data.trim().split(sepRE).map(val => {\r\n                if (!isNaN(val)) {\r\n                    return Number(val);\r\n                }\r\n            })\r\n        });\r\n    }\r\n\r\n    return serialized;\r\n}\r\n\r\nfunction movePath(params) {\r\n    const {\r\n        path,\r\n        dx,\r\n        dy\r\n    } = params;\r\n\r\n    try {\r\n        const serialized = parsePath(path);\r\n\r\n        let str = '';\r\n        let space = ' ';\r\n\r\n        let firstCommand = true;\r\n\r\n        for (let i = 0, len = serialized.length; i < len; i++) {\r\n            const item = serialized[i];\r\n\r\n            const {\r\n                values,\r\n                key: cmd,\r\n                relative\r\n            } = item;\r\n\r\n            const coordinates = [];\r\n\r\n            switch (cmd) {\r\n\r\n                case 'M': {\r\n                    for (let k = 0, len = values.length; k < len; k += 2) {\r\n                        let [x, y] = values.slice(k, k + 2);\r\n\r\n                        if (!(relative && !firstCommand)) {\r\n                            x += dx;\r\n                            y += dy;\r\n                        }\r\n\r\n                        coordinates.push(\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        firstCommand = false;\r\n                    }\r\n                    break;\r\n                }              \r\n                case 'A': {\r\n                    for (let k = 0, len = values.length; k < len; k += 7) {\r\n                        const set = values.slice(k, k + 7);\r\n\r\n                        if (!relative) {\r\n                            set[5] += dx;\r\n                            set[6] += dy;\r\n                        }\r\n\r\n                        coordinates.push(...set);\r\n                    }\r\n                    break;\r\n                }\r\n                case 'C': {\r\n                    for (let k = 0, len = values.length; k < len; k += 6) {\r\n                        const set = values.slice(k, k + 6);\r\n\r\n                        if (!relative) {\r\n                            set[0] += dx;\r\n                            set[1] += dy;\r\n                            set[2] += dx;\r\n                            set[3] += dy;\r\n                            set[4] += dx;\r\n                            set[5] += dy;\r\n                        }\r\n\r\n                        coordinates.push(...set);\r\n                    }\r\n                    break;\r\n                }\r\n                case 'H': {\r\n                    for (let k = 0, len = values.length; k < len; k += 1) {\r\n                        const set = values.slice(k, k + 1);\r\n\r\n                        if (!relative) {\r\n                            set[0] += dx;\r\n                        }\r\n\r\n                        coordinates.push(set[0]);\r\n                    }\r\n\r\n                    break;\r\n                }\r\n                case 'V': {\r\n                    for (let k = 0, len = values.length; k < len; k += 1) {\r\n                        const set = values.slice(k, k + 1);\r\n\r\n                        if (!relative) {\r\n                            set[0] += dy;\r\n                        }\r\n                        coordinates.push(set[0]);\r\n                    }\r\n\r\n                    break;\r\n                }\r\n                case 'L':\r\n                case 'T': {\r\n                    for (let k = 0, len = values.length; k < len; k += 2) {\r\n                        let [x, y] = values.slice(k, k + 2);\r\n\r\n                        if (!relative) {\r\n                            x += dx;\r\n                            y += dy;\r\n                        }\r\n\r\n                        coordinates.push(\r\n                            x,\r\n                            y\r\n                        );\r\n                    }\r\n                    break;\r\n                }\r\n                case 'Q':\r\n                case 'S': {\r\n                    for (let k = 0, len = values.length; k < len; k += 4) {\r\n                        let [x1, y1, x2, y2] = values.slice(k, k + 4);\r\n\r\n                        if (!relative) {\r\n                            x1 += dx;\r\n                            y1 += dy;\r\n                            x2 += dx;\r\n                            y2 += dy;\r\n                        }\r\n\r\n                        coordinates.push(\r\n                            x1,\r\n                            y1,\r\n                            x2,\r\n                            y2\r\n                        );\r\n                    }\r\n                    break;\r\n                }\r\n                case 'Z': {\r\n                    values[0] = '';\r\n                    space = '';\r\n                    break;\r\n                }\r\n\r\n            }\r\n\r\n            str += item.cmd + coordinates.join(',') + space;\r\n        }\r\n\r\n        return str;\r\n    } catch (err) {\r\n        warn('Path parsing error: ' + err);\r\n    }\r\n}\r\n\r\nfunction resizePath(params) {\r\n    const {\r\n        path,\r\n        localCTM\r\n    } = params;\r\n\r\n    try {\r\n        const serialized = parsePath(path);\r\n\r\n        let str = '';\r\n        let space = ' ';\r\n\r\n        const res = [];\r\n\r\n        let firstCommand = true;\r\n\r\n        for (let i = 0, len = serialized.length; i < len; i++) {\r\n            const item = serialized[i];\r\n\r\n            const {\r\n                values,\r\n                key: cmd,\r\n                relative\r\n            } = item;\r\n\r\n            switch (cmd) {\r\n\r\n                case 'A': {\r\n                //A rx ry x-axis-rotation large-arc-flag sweep-flag x y\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 7) {\r\n                        const [rx, ry, x_axis_rot, large_arc_flag, sweep_flag, x, y] =\r\n                            values.slice(k, k + 7);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n\r\n                        mtrx.e = mtrx.f = 0;\r\n\r\n                        const {\r\n                            x: newRx,\r\n                            y: newRy\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            rx,\r\n                            ry\r\n                        );\r\n\r\n                        coordinates.unshift(\r\n                            floatToFixed(newRx),\r\n                            floatToFixed(newRy),\r\n                            x_axis_rot,\r\n                            large_arc_flag,\r\n                            sweep_flag\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'C': {\r\n                //C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 6) {\r\n                        const [x1, y1, x2, y2, x, y] = values.slice(k, k + 6);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX1,\r\n                            y: resY1\r\n                        } = pointTo(\r\n                            mtrx,                          \r\n                            x1,\r\n                            y1\r\n                        );\r\n\r\n                        const {\r\n                            x: resX2,\r\n                            y: resY2\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x2,\r\n                            y2\r\n                        );\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX1),\r\n                            floatToFixed(resY1),\r\n                            floatToFixed(resX2),\r\n                            floatToFixed(resY2),\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                // this command makes impossible free transform within group\r\n                // todo: use proportional resizing only or need to be converted to L\r\n                case 'H': {\r\n                // H x (or h dx)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 1) {\r\n                        const [x] = values.slice(k, k + 1);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            0\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                // this command makes impossible free transform within group\r\n                // todo: use proportional resizing only or need to be converted to L\r\n                case 'V': {\r\n                // V y (or v dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 1) {\r\n                        const [y] = values.slice(k, k + 1);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            0,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resY)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'T':\r\n                case 'L': {\r\n                // T x y (or t dx dy)\r\n                // L x y (or l dx dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 2) {\r\n                        const [x, y] = values.slice(k, k + 2);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'M': {\r\n                // M x y (or dx dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 2) {\r\n                        const [x, y] = values.slice(k, k + 2);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative && !firstCommand) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n\r\n                        firstCommand = false;\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'Q': {\r\n                //Q x1 y1, x y (or q dx1 dy1, dx dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 4) {\r\n                        const [x1, y1, x, y] = values.slice(k, k + 4);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX1,\r\n                            y: resY1\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x1,\r\n                            y1\r\n                        );\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX1),\r\n                            floatToFixed(resY1),\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'S': {\r\n                //S x2 y2, x y (or s dx2 dy2, dx dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 4) {\r\n                        const [x2, y2, x, y] = values.slice(k, k + 4);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX2,\r\n                            y: resY2\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x2,\r\n                            y2\r\n                        );\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX2),\r\n                            floatToFixed(resY2),\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'Z': {\r\n                    res.push(['']);\r\n                    space = '';\r\n                    break;\r\n                }\r\n\r\n            }\r\n\r\n            str += item.cmd + res[i].join(',') + space;\r\n        }\r\n\r\n        return str;\r\n    } catch (err) {\r\n        warn('Path parsing error: ' + err);\r\n    }\r\n}\n\nconst MIN_SIZE$1 = 5;\r\nconst ROT_OFFSET = 50;\r\n\r\nclass DraggableSVG extends Transformable {\r\n\r\n    _init(el) {\r\n        const {\r\n            rotationPoint,\r\n            container,\r\n            themeColor,\r\n            resizable,\r\n            rotatable\r\n        } = this.options;\r\n\r\n        const wrapper = createSVGElement('g');\r\n        addClass(wrapper, 'sjx-svg-wrapper');\r\n        container.appendChild(wrapper);\r\n\r\n        const {\r\n            width: cw,\r\n            height: ch,\r\n            x: cx,\r\n            y: cy\r\n        } = el.getBBox();\r\n\r\n        const elCTM = getTransformToElement(el, container);\r\n        const box = createSVGElement('rect');\r\n\r\n        const attrs = [\r\n            ['width', cw],\r\n            ['height', ch],\r\n            ['x', cx],\r\n            ['y', cy],\r\n            ['fill', themeColor],\r\n            ['fill-opacity', 0.1],\r\n            ['stroke', themeColor],\r\n            ['stroke-dasharray', '3 3'],\r\n            ['vector-effect', 'non-scaling-stroke'],\r\n            ['transform', matrixToString(elCTM)]\r\n        ];\r\n\r\n        attrs.forEach(([key, value]) => {\r\n            box.setAttribute(key, value);\r\n        });\r\n\r\n        const handlesGroup = createSVGElement('g'),\r\n            normalLineGroup = createSVGElement('g'),\r\n            group = createSVGElement('g');\r\n\r\n        addClass(group, 'sjx-svg-box-group');\r\n        addClass(handlesGroup, 'sjx-svg-handles');\r\n        addClass(normalLineGroup, 'sjx-svg-normal-group');\r\n\r\n        group.appendChild(box);\r\n        wrapper.appendChild(group);\r\n        wrapper.appendChild(normalLineGroup);\r\n        wrapper.appendChild(handlesGroup);\r\n\r\n        const {\r\n            x: bX,\r\n            y: bY,\r\n            width: bW,\r\n            height: bH\r\n        } = box.getBBox();\r\n\r\n        const centerX = el.getAttribute('data-cx'),\r\n            centerY = el.getAttribute('data-cy');\r\n\r\n        const boxCTM = getTransformToElement(box, box.parentNode),\r\n            boxCenter = pointTo(boxCTM, bX + bW / 2, bY + bH / 2),\r\n            boxTL = pointTo(boxCTM, bX, bY),\r\n            boxTR = pointTo(boxCTM, bX + bW, bY),\r\n            boxMR = pointTo(boxCTM, bX + bW, bY + bH / 2);\r\n\r\n        const resizingHandles = {\r\n            tl: boxTL,\r\n            tr: boxTR,\r\n            br: pointTo(boxCTM, bX + bW, bY + bH),\r\n            bl: pointTo(boxCTM, bX, bY + bH),\r\n            tc: pointTo(boxCTM, bX + bW / 2, bY),\r\n            bc: pointTo(boxCTM, bX + bW / 2, bY + bH),\r\n            ml: pointTo(boxCTM, bX, bY + bH / 2),\r\n            mr: boxMR\r\n        };\r\n\r\n        let rotationHandles = {},\r\n            rotator = null;\r\n\r\n        if (rotatable) {\r\n            const theta = Math.atan2(\r\n                boxTL.y - boxTR.y,\r\n                boxTL.x - boxTR.x\r\n            );\r\n\r\n            rotator = {\r\n                x: boxMR.x - ROT_OFFSET * Math.cos(theta),\r\n                y: boxMR.y - ROT_OFFSET * Math.sin(theta)\r\n            }; \r\n\r\n            const normalLine = createSVGElement('line');\r\n\r\n            normalLine.x1.baseVal.value = boxMR.x;\r\n            normalLine.y1.baseVal.value = boxMR.y;\r\n            normalLine.x2.baseVal.value = rotator.x;\r\n            normalLine.y2.baseVal.value = rotator.y;\r\n\r\n            setLineStyle(normalLine, themeColor);\r\n            normalLineGroup.appendChild(normalLine);\r\n\r\n            let radius = null;\r\n\r\n            if (rotationPoint) {\r\n                radius = createSVGElement('line');\r\n\r\n                addClass(radius, 'sjx-hidden');\r\n\r\n                radius.x1.baseVal.value = boxCenter.x;\r\n                radius.y1.baseVal.value = boxCenter.y;\r\n                radius.x2.baseVal.value = centerX || boxCenter.x;\r\n                radius.y2.baseVal.value = centerY || boxCenter.y;\r\n\r\n                setLineStyle(radius, '#fe3232');\r\n                radius.setAttribute('opacity', 0.5);\r\n\r\n                normalLineGroup.appendChild(radius);\r\n            }\r\n\r\n            rotationHandles = {\r\n                normal: normalLine,\r\n                radius\r\n            };\r\n        }\r\n\r\n        const handles = {\r\n            ...(resizable && resizingHandles),\r\n            rotator,\r\n            center: rotationPoint && rotatable ? createPoint(container, centerX, centerY) || boxCenter : undefined\r\n        };\r\n\r\n        Object.keys(handles).forEach(key => {\r\n            const data = handles[key];\r\n            if (isUndef(data)) return;\r\n            const { x, y } = data;\r\n            const color = key === 'center'\r\n                ? '#fe3232'\r\n                : themeColor;\r\n\r\n            handles[key] = createHandler$1(\r\n                x,\r\n                y,\r\n                color,\r\n                key\r\n            );\r\n            handlesGroup.appendChild(handles[key]);\r\n        });\r\n\r\n        this.storage = {\r\n            wrapper,\r\n            box,\r\n            handles: {\r\n                ...handles,\r\n                ...rotationHandles\r\n            },\r\n            parent: el.parentNode,\r\n            center: {}\r\n        };\r\n\r\n        helper(wrapper)\r\n            .on('mousedown', this._onMouseDown)\r\n            .on('touchstart', this._onTouchStart);\r\n    }\r\n\r\n    _destroy() {\r\n        const {\r\n            wrapper\r\n        } = this.storage;\r\n\r\n        helper(wrapper)\r\n            .off('mousedown', this._onMouseDown)\r\n            .off('touchstart', this._onTouchStart);\r\n\r\n        wrapper.parentNode.removeChild(wrapper);\r\n    }\r\n\r\n    _cursorPoint({ clientX, clientY }) {\r\n        const {\r\n            container\r\n        } = this.options;\r\n\r\n        return pointTo(\r\n            container.getScreenCTM().inverse(),\r\n            clientX,\r\n            clientY\r\n        );\r\n    }\r\n\r\n    _pointToElement({ x, y }) {\r\n        const {\r\n            transform\r\n        } = this.storage;\r\n\r\n        const { ctm } = transform;\r\n        const matrix = ctm.inverse();\r\n\r\n        matrix.e = matrix.f = 0;\r\n\r\n        return this._applyMatrixToPoint(\r\n            matrix,\r\n            x,\r\n            y\r\n        );\r\n    }\r\n\r\n    _pointToControls({ x, y }) {\r\n        const {\r\n            transform\r\n        } = this.storage;\r\n\r\n        const { boxCTM } = transform;\r\n        const matrix = boxCTM.inverse();\r\n\r\n        matrix.e = matrix.f = 0;\r\n\r\n        return this._applyMatrixToPoint(\r\n            matrix,\r\n            x,\r\n            y\r\n        );\r\n    }\r\n\r\n    _applyMatrixToPoint(matrix, x, y) {\r\n        const {\r\n            container\r\n        } = this.options;\r\n\r\n        const pt = container.createSVGPoint();\r\n        pt.x = x;\r\n        pt.y = y;\r\n        return pt.matrixTransform(matrix);\r\n    }\r\n\r\n    _apply(actionName) {\r\n        const {\r\n            el: element,\r\n            storage,\r\n            options: { container }\r\n        } = this;\r\n\r\n        const {\r\n            box,\r\n            handles,\r\n            cached,\r\n            transform \r\n        } = storage;\r\n\r\n        const {\r\n            matrix,\r\n            boxCTM,\r\n            bBox,\r\n            ctm\r\n        } = transform;\r\n\r\n        const eBBox = element.getBBox();\r\n\r\n        const {\r\n            x: elX,\r\n            y: elY,\r\n            width: elW,\r\n            height: elH\r\n        } = eBBox;\r\n\r\n        const rotationPoint = isDef(handles.center)\r\n            ? pointTo(\r\n                boxCTM,\r\n                handles.center.cx.baseVal.value,\r\n                handles.center.cy.baseVal.value\r\n            )\r\n            : pointTo(\r\n                matrix,\r\n                elX + elW / 2,\r\n                elY + elH / 2\r\n            );\r\n\r\n        element.setAttribute('data-cx', rotationPoint.x);\r\n        element.setAttribute('data-cy', rotationPoint.y);\r\n\r\n        if (isUndef(cached)) return;\r\n\r\n        const {\r\n            scaleX,\r\n            scaleY,\r\n            dx,\r\n            dy,\r\n            ox,\r\n            oy\r\n        } = cached;\r\n\r\n        if (actionName === 'drag') {\r\n            if (dx === 0 && dy === 0) return;\r\n\r\n            const eM = createSVGMatrix();\r\n\r\n            eM.e = dx;\r\n            eM.f = dy;\r\n\r\n            const translateMatrix = eM.multiply(matrix)\r\n                .multiply(eM.inverse());\r\n\r\n            element.setAttribute(\r\n                'transform',\r\n                matrixToString(translateMatrix)\r\n            );\r\n\r\n            if (isGroup(element)) {\r\n                const els = checkChildElements(element);\r\n\r\n                els.forEach(child => {\r\n                    const pt = container.createSVGPoint();\r\n                    const ctm = getTransformToElement(element.parentNode, container).inverse();\r\n                    pt.x = ox;\r\n                    pt.y = oy;\r\n                    ctm.e = ctm.f = 0;\r\n                    const newPT = pt.matrixTransform(ctm);\r\n\r\n                    const eM = createSVGMatrix();\r\n\r\n                    eM.e = dx;\r\n                    eM.f = dy;\r\n\r\n                    const translateMatrix = eM.multiply(\r\n                        getTransformToElement(child, child.parentNode)\r\n                    ).multiply(eM.inverse());\r\n\r\n                    if (!isIdentity(translateMatrix)) {\r\n                        child.setAttribute(\r\n                            'transform',\r\n                            matrixToString(translateMatrix)\r\n                        );\r\n                    }\r\n\r\n                    if (!isGroup(child)) {\r\n                        applyTranslate(child, {\r\n                            x: newPT.x,\r\n                            y: newPT.y\r\n                        });\r\n                    }\r\n                });\r\n            } else {\r\n                applyTranslate(element, {\r\n                    x: dx,\r\n                    y: dy\r\n                });\r\n            }\r\n        }\r\n\r\n        if (actionName === 'resize') {\r\n            const {\r\n                x,\r\n                y,\r\n                width: newWidth,\r\n                height: newHeight\r\n            } = box.getBBox();\r\n\r\n            applyTransformToHandles(\r\n                storage,\r\n                {\r\n                    x,\r\n                    y,\r\n                    width: newWidth,\r\n                    height: newHeight,\r\n                    boxMatrix: null\r\n                }\r\n            );\r\n\r\n            if (isGroup(element)) {\r\n                const els = checkChildElements(element);\r\n\r\n                els.forEach(child => {\r\n                    if (!isGroup(child)) {\r\n                        applyResize(child, {\r\n                            scaleX,\r\n                            scaleY,\r\n                            defaultCTM: child.__ctm__,\r\n                            bBox: bBox,\r\n                            container,\r\n                            storage\r\n                        });\r\n                    }\r\n                });\r\n            } else {\r\n                applyResize(element, {\r\n                    scaleX,\r\n                    scaleY,\r\n                    defaultCTM: ctm,\r\n                    bBox: bBox,\r\n                    container,\r\n                    storage\r\n                });\r\n            }\r\n\r\n            element.setAttribute(\r\n                'transform',\r\n                matrixToString(matrix)\r\n            );\r\n        }\r\n\r\n        this.storage.cached = null;\r\n    }\r\n\r\n    _processResize(dx, dy) {\r\n        const {\r\n            el,\r\n            storage,\r\n            options: { proportions }\r\n        } = this;\r\n\r\n        const {\r\n            left,\r\n            top,\r\n            cw,\r\n            ch,\r\n            transform,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        } = storage;\r\n\r\n        const {\r\n            matrix,\r\n            scMatrix,\r\n            trMatrix,\r\n            scaleX: ptX,\r\n            scaleY: ptY\r\n        } = transform;\r\n\r\n        let {\r\n            width: newWidth,\r\n            height: newHeight\r\n        } = el.getBBox(); //box\r\n\r\n        const ratio = doW || (!doW && !doH)\r\n            ? (cw + dx) / cw\r\n            : (ch + dy) / ch;\r\n\r\n        newWidth = proportions ? cw * ratio : cw + dx;\r\n        newHeight = proportions ? ch * ratio : ch + dy;\r\n\r\n        if (Math.abs(newWidth) < MIN_SIZE$1 || Math.abs(newHeight) < MIN_SIZE$1) return;\r\n\r\n        const scaleX = newWidth / cw,\r\n            scaleY = newHeight / ch;\r\n\r\n        // setup scale matrix\r\n        scMatrix.a = scaleX;\r\n        scMatrix.b = 0;\r\n        scMatrix.c = 0;\r\n        scMatrix.d = scaleY;\r\n        scMatrix.e = 0;\r\n        scMatrix.f = 0;\r\n\r\n        // translate compensation matrix\r\n        trMatrix.e = ptX;\r\n        trMatrix.f = ptY;\r\n\r\n        //now must to do: translate(x y) scale(sx sy) translate(-x -y)\r\n        const scaleMatrix = trMatrix\r\n            .multiply(scMatrix)\r\n            .multiply(trMatrix.inverse());\r\n\r\n        const res = matrix.multiply(scaleMatrix);\r\n\r\n        el.setAttribute(\r\n            'transform',\r\n            matrixToString(res)\r\n        );\r\n\r\n        const deltaW = newWidth - cw,\r\n            deltaH = newHeight - ch;\r\n\r\n        const newX = left - deltaW * (doH ? 0.5 : (revX ? 1 : 0)),\r\n            newY = top - deltaH * (doW ? 0.5 : (revY ? 1 : 0));\r\n\r\n        this.storage.cached = {\r\n            scaleX,\r\n            scaleY\r\n        };\r\n\r\n        const finalValues = {\r\n            x: newX,\r\n            y: newY,\r\n            width: newWidth,\r\n            height: newHeight\r\n        };\r\n\r\n        applyTransformToHandles(\r\n            storage,\r\n            {\r\n                ...finalValues,\r\n                boxMatrix: null\r\n            }\r\n        );\r\n\r\n        return finalValues;\r\n    }\r\n\r\n    _processMove(dx, dy) {\r\n        const {\r\n            transform,\r\n            wrapper,\r\n            center\r\n        } = this.storage;\r\n\r\n        const {\r\n            matrix,\r\n            trMatrix,\r\n            scMatrix,\r\n            wrapperMatrix,\r\n            parentMatrix\r\n        } = transform;\r\n\r\n        scMatrix.e = dx;\r\n        scMatrix.f = dy;\r\n\r\n        const moveWrapperMtrx = scMatrix.multiply(wrapperMatrix);\r\n\r\n        wrapper.setAttribute(\r\n            'transform',\r\n            matrixToString(moveWrapperMtrx)\r\n        );\r\n\r\n        parentMatrix.e = parentMatrix.f = 0;\r\n        const { x, y } = pointTo(\r\n            parentMatrix.inverse(),\r\n            dx,\r\n            dy\r\n        );\r\n\r\n        trMatrix.e = x;\r\n        trMatrix.f = y;\r\n\r\n        const moveElementMtrx = trMatrix.multiply(matrix);\r\n\r\n        this.el.setAttribute(\r\n            'transform',\r\n            matrixToString(moveElementMtrx)\r\n        );\r\n\r\n        this.storage.cached = {\r\n            dx: x,\r\n            dy: y,\r\n            ox: dx,\r\n            oy: dy\r\n        };\r\n\r\n        if (center.isShifted) {\r\n            const radiusMatrix = wrapperMatrix.inverse();\r\n            radiusMatrix.e = radiusMatrix.f = 0;\r\n            const { x: nx, y: ny } = pointTo(\r\n                radiusMatrix,\r\n                dx,\r\n                dy\r\n            );\r\n\r\n            this._moveCenterHandle(-nx, -ny);\r\n        }\r\n\r\n        return moveElementMtrx;\r\n    }\r\n\r\n    _processRotate(radians) {\r\n        const {\r\n            center,\r\n            transform,\r\n            wrapper\r\n        } = this.storage;\r\n\r\n        const {\r\n            matrix,\r\n            wrapperMatrix,\r\n            parentMatrix,\r\n            trMatrix,\r\n            scMatrix,\r\n            rotMatrix\r\n        } = transform;\r\n\r\n        const cos = floatToFixed(Math.cos(radians)),\r\n            sin = floatToFixed(Math.sin(radians));\r\n\r\n        // rotate(a cx cy) is equivalent to translate(cx cy) rotate(a) translate(-cx -cy)\r\n        trMatrix.e = center.x;\r\n        trMatrix.f = center.y;\r\n\r\n        rotMatrix.a = cos;\r\n        rotMatrix.b = sin;\r\n        rotMatrix.c = - sin;\r\n        rotMatrix.d = cos;\r\n\r\n        const wrapMatrix = trMatrix.multiply(rotMatrix)\r\n            .multiply(trMatrix.inverse())\r\n            .multiply(wrapperMatrix);\r\n\r\n        wrapper.setAttribute(\r\n            'transform',\r\n            matrixToString(wrapMatrix)\r\n        );\r\n\r\n        scMatrix.e = center.el_x;\r\n        scMatrix.f = center.el_y;\r\n\r\n        parentMatrix.e = parentMatrix.f = 0;\r\n        const resRotMatrix = parentMatrix.inverse()\r\n            .multiply(rotMatrix)\r\n            .multiply(parentMatrix);\r\n\r\n        const rotateMatrix = scMatrix.multiply(resRotMatrix)\r\n            .multiply(scMatrix.inverse());\r\n\r\n        const elMatrix = rotateMatrix.multiply(matrix);\r\n\r\n        this.el.setAttribute(\r\n            'transform',\r\n            matrixToString(elMatrix)\r\n        );\r\n\r\n        return elMatrix;\r\n    }\r\n\r\n    _getState({ revX, revY, doW, doH }) {\r\n        const {\r\n            el: element,\r\n            storage,\r\n            options: { container }\r\n        } = this;\r\n\r\n        const {\r\n            box,\r\n            wrapper,\r\n            parent,\r\n            handles: { center: cHandle }\r\n        } = storage;\r\n\r\n        const eBBox = element.getBBox();\r\n\r\n        const {\r\n            x: el_x,\r\n            y: el_y,\r\n            width: el_w,\r\n            height: el_h\r\n        } = eBBox;\r\n\r\n        const {\r\n            width: cw,\r\n            height: ch,\r\n            x: c_left,\r\n            y: c_top\r\n        } = box.getBBox();\r\n\r\n        const elMatrix = getTransformToElement(element, parent),\r\n            ctm = getTransformToElement(element, container),\r\n            boxCTM = getTransformToElement(box.parentNode, container);\r\n\r\n        const parentMatrix = getTransformToElement(parent, container);\r\n\r\n        const scaleX = el_x + el_w * (doH ? 0.5 : revX ? 1 : 0),\r\n            scaleY = el_y + el_h * (doW ? 0.5 : revY ? 1 : 0);\r\n\r\n        const transform = {\r\n            matrix: elMatrix,\r\n            ctm,\r\n            boxCTM,\r\n            parentMatrix,\r\n            wrapperMatrix: getTransformToElement(wrapper, wrapper.parentNode),\r\n            trMatrix: createSVGMatrix(),\r\n            scMatrix: createSVGMatrix(),\r\n            rotMatrix: createSVGMatrix(),\r\n            scaleX,\r\n            scaleY,\r\n            scX: Math.sqrt(ctm.a * ctm.a + ctm.b * ctm.b),\r\n            scY: Math.sqrt(ctm.c * ctm.c + ctm.d * ctm.d),\r\n            bBox: eBBox\r\n        };\r\n\r\n        const boxCenterX = c_left + cw / 2,\r\n            boxCenterY = c_top + ch / 2;\r\n\r\n        const centerX = cHandle\r\n                ? cHandle.cx.baseVal.value\r\n                : boxCenterX,\r\n            centerY = cHandle\r\n                ? cHandle.cy.baseVal.value\r\n                : boxCenterY;\r\n\r\n        // c-handle's coordinates\r\n        const { x: bcx, y: bcy } = pointTo(\r\n            boxCTM,\r\n            centerX,\r\n            centerY\r\n        );\r\n\r\n        // element's center coordinates\r\n        const { x: elcx, y: elcy } = isDef(cHandle)\r\n            ? pointTo(\r\n                parentMatrix.inverse(),\r\n                bcx,\r\n                bcy\r\n            )\r\n            : pointTo(\r\n                elMatrix,\r\n                el_x + el_w / 2,\r\n                el_y + el_h / 2\r\n            );\r\n\r\n        // box's center coordinates\r\n        const { x: rcx, y: rcy } = pointTo(\r\n            getTransformToElement(box, container),\r\n            boxCenterX,\r\n            boxCenterY\r\n        );\r\n\r\n        checkChildElements(element).forEach(child => {\r\n            child.__ctm__ = getTransformToElement(child, container);\r\n        });\r\n\r\n        return {\r\n            transform,\r\n            cw,\r\n            ch,\r\n            center: {\r\n                x: cHandle ? bcx : rcx,\r\n                y: cHandle ? bcy : rcy,\r\n                el_x: elcx,\r\n                el_y: elcy,\r\n                hx: cHandle ? cHandle.cx.baseVal.value : null,\r\n                hy: cHandle ? cHandle.cy.baseVal.value : null,\r\n                isShifted: (floatToFixed(rcx, 3) !== floatToFixed(bcx, 3)) &&\r\n                    (floatToFixed(rcy, 3) !== floatToFixed(bcy, 3))\r\n            },\r\n            left: c_left,\r\n            top: c_top,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        };\r\n    }\r\n\r\n    _moveCenterHandle(x, y) {\r\n        const {\r\n            handles: { center, radius },\r\n            center: { hx, hy }\r\n        } = this.storage;\r\n\r\n        if (isUndef(center)) return;\r\n\r\n        const mx = hx + x,\r\n            my = hy + y;\r\n\r\n        center.cx.baseVal.value = mx;\r\n        center.cy.baseVal.value = my;\r\n\r\n        radius.x2.baseVal.value = mx;\r\n        radius.y2.baseVal.value = my;\r\n    }\r\n\r\n    resetCenterPoint() {\r\n        const {\r\n            box,\r\n            handles: { center, radius }\r\n        } = this.storage;\r\n\r\n        const {\r\n            width: cw,\r\n            height: ch,\r\n            x: c_left,\r\n            y: c_top\r\n        } = box.getBBox();\r\n\r\n        const matrix = getTransformToElement(box, box.parentNode);\r\n\r\n        const { x: cx, y: cy } = pointTo(\r\n            matrix,\r\n            c_left + cw / 2,\r\n            c_top + ch / 2\r\n        );\r\n\r\n        center.cx.baseVal.value = cx;\r\n        center.cy.baseVal.value = cy;\r\n        center.isShifted = false;\r\n\r\n        radius.x2.baseVal.value = cx;\r\n        radius.y2.baseVal.value = cy;\r\n    }\r\n\r\n    fitControlsToSize() {\r\n        const { \r\n            el, \r\n            storage: { box, wrapper }, \r\n            options: { container }\r\n        } = this;\r\n\r\n        const {\r\n            width,\r\n            height,\r\n            x,\r\n            y\r\n        } = el.getBBox();\r\n\r\n        const containerMatrix = getTransformToElement(\r\n            el,\r\n            container\r\n        );\r\n        \r\n        wrapper.removeAttribute('transform');\r\n        box.setAttribute('transform', matrixToString(containerMatrix));\r\n\r\n        applyTransformToHandles(\r\n            this.storage,\r\n            {\r\n                x,\r\n                y,\r\n                width,\r\n                height,\r\n                boxMatrix: containerMatrix\r\n            }\r\n        );\r\n    }\r\n\r\n    get controls() {\r\n        return this.storage.wrapper;\r\n    }\r\n\r\n}\r\n\r\nfunction applyTranslate(element, { x, y }) {\r\n    const attrs = [];\r\n\r\n    switch (element.tagName.toLowerCase()) {\r\n\r\n        case 'text': {\r\n            const resX = isDef(element.x.baseVal[0])\r\n                ? element.x.baseVal[0].value + x\r\n                : (Number(element.getAttribute('x')) || 0) + x;\r\n            const resY = isDef(element.y.baseVal[0])\r\n                ? element.y.baseVal[0].value + y\r\n                : (Number(element.getAttribute('y')) || 0) + y;\r\n\r\n            attrs.push(\r\n                ['x', resX],\r\n                ['y', resY]\r\n            );\r\n            break;\r\n        }\r\n        case 'use':\r\n        case 'image':\r\n        case 'rect': {\r\n            const resX = isDef(element.x.baseVal.value)\r\n                ? element.x.baseVal.value + x\r\n                : (Number(element.getAttribute('x')) || 0) + x;\r\n            const resY = isDef(element.y.baseVal.value)\r\n                ? element.y.baseVal.value + y\r\n                : (Number(element.getAttribute('y')) || 0) + y;\r\n\r\n            attrs.push(\r\n                ['x', resX],\r\n                ['y', resY]\r\n            );\r\n            break;\r\n        }\r\n        case 'circle':\r\n        case 'ellipse': {\r\n            const resX = element.cx.baseVal.value + x,\r\n                resY = element.cy.baseVal.value + y;\r\n\r\n            attrs.push(\r\n                ['cx', resX],\r\n                ['cy', resY]\r\n            );\r\n            break;\r\n        }\r\n        case 'line': {\r\n            const resX1 = element.x1.baseVal.value + x,\r\n                resY1 = element.y1.baseVal.value + y,\r\n                resX2 = element.x2.baseVal.value + x,\r\n                resY2 = element.y2.baseVal.value + y;\r\n\r\n            attrs.push(\r\n                ['x1', resX1],\r\n                ['y1', resY1],\r\n                ['x2', resX2],\r\n                ['y2', resY2]\r\n            );\r\n            break;\r\n        }\r\n        case 'polygon':\r\n        case 'polyline': {\r\n            const points = parsePoints(element.getAttribute('points'));\r\n            const result = points.map(item => {\r\n                item[0] = Number(item[0]) + x;\r\n                item[1] = Number(item[1]) + y;\r\n\r\n                return item.join(' ');\r\n            }).join(' ');\r\n\r\n            attrs.push(\r\n                ['points', result]\r\n            );\r\n            break;\r\n        }\r\n        case 'path': {\r\n            const path = element.getAttribute('d');\r\n\r\n            attrs.push(['d', movePath(\r\n                {\r\n                    path,\r\n                    dx: x,\r\n                    dy: y\r\n                }\r\n            )]);\r\n            break;\r\n        }\r\n\r\n    }\r\n\r\n    attrs.forEach(item => {\r\n        element.setAttribute(item[0], item[1]);\r\n    });\r\n}\r\n\r\nfunction applyResize(element, data) {\r\n    const {\r\n        scaleX,\r\n        scaleY,\r\n        bBox,\r\n        defaultCTM,\r\n        container\r\n    } = data;\r\n\r\n    const {\r\n        width: boxW,\r\n        height: boxH\r\n    } = bBox;\r\n\r\n    const attrs = [];\r\n\r\n    const ctm = getTransformToElement(element, container);\r\n    const localCTM = defaultCTM.inverse().multiply(ctm);\r\n\r\n    switch (element.tagName.toLowerCase()) {\r\n\r\n        case 'text': {\r\n            const x = isDef(element.x.baseVal[0])\r\n                ? element.x.baseVal[0].value\r\n                : (Number(element.getAttribute('x')) || 0);\r\n            const y = isDef(element.y.baseVal[0])\r\n                ? element.y.baseVal[0].value\r\n                : (Number(element.getAttribute('y')) || 0);\r\n\r\n            const {\r\n                x: resX,\r\n                y: resY\r\n            } = pointTo(\r\n                localCTM,\r\n                x,\r\n                y\r\n            );\r\n\r\n            attrs.push(\r\n                ['x', resX + (scaleX < 0 ? boxW : 0)],\r\n                ['y', resY + (scaleY < 0 ? boxH : 0)]\r\n            );\r\n            break;\r\n        }\r\n        case 'circle': {\r\n            const r = element.r.baseVal.value,\r\n                cx = element.cx.baseVal.value,\r\n                cy = element.cy.baseVal.value,\r\n                newR = r * (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\r\n\r\n            const {\r\n                x: resX,\r\n                y: resY\r\n            } = pointTo(\r\n                localCTM,\r\n                cx,\r\n                cy\r\n            );\r\n\r\n            attrs.push(\r\n                ['r', newR],\r\n                ['cx', resX],\r\n                ['cy', resY]\r\n            );\r\n            break;\r\n        }\r\n        case 'image':\r\n        case 'rect': {\r\n            const width = element.width.baseVal.value,\r\n                height = element.height.baseVal.value,\r\n                x = element.x.baseVal.value,\r\n                y = element.y.baseVal.value;\r\n\r\n            const {\r\n                x: resX,\r\n                y: resY\r\n            } = pointTo(\r\n                localCTM,\r\n                x,\r\n                y\r\n            );\r\n\r\n            const newWidth = Math.abs(width * scaleX),\r\n                newHeight = Math.abs(height * scaleY);\r\n\r\n            attrs.push(\r\n                ['x', resX - (scaleX < 0 ? newWidth : 0)],\r\n                ['y', resY - (scaleY < 0 ? newHeight : 0)],\r\n                ['width', newWidth],\r\n                ['height', newHeight]\r\n            );\r\n            break;\r\n        }\r\n        case 'ellipse': {\r\n            const rx = element.rx.baseVal.value,\r\n                ry = element.ry.baseVal.value,\r\n                cx = element.cx.baseVal.value,\r\n                cy = element.cy.baseVal.value;\r\n\r\n            const {\r\n                x: cx1,\r\n                y: cy1\r\n            } = pointTo(\r\n                localCTM,\r\n                cx,\r\n                cy\r\n            );\r\n\r\n            const scaleMatrix = createSVGMatrix();\r\n\r\n            scaleMatrix.a = scaleX;\r\n            scaleMatrix.d = scaleY;\r\n\r\n            const {\r\n                x: nRx,\r\n                y: nRy\r\n            } = pointTo(\r\n                scaleMatrix,\r\n                rx,\r\n                ry\r\n            );\r\n\r\n            attrs.push(\r\n                ['rx', Math.abs(nRx)],\r\n                ['ry', Math.abs(nRy)],\r\n                ['cx', cx1],\r\n                ['cy', cy1]\r\n            );\r\n            break;\r\n        }\r\n        case 'line': {\r\n            const resX1 = element.x1.baseVal.value,\r\n                resY1 = element.y1.baseVal.value,\r\n                resX2 = element.x2.baseVal.value,\r\n                resY2 = element.y2.baseVal.value;\r\n\r\n            const {\r\n                x: resX1_,\r\n                y: resY1_\r\n            } = pointTo(\r\n                localCTM,\r\n                resX1,\r\n                resY1\r\n            );\r\n\r\n            const {\r\n                x: resX2_,\r\n                y: resY2_\r\n            } = pointTo(\r\n                localCTM,\r\n                resX2,\r\n                resY2\r\n            );\r\n\r\n            attrs.push(\r\n                ['x1', resX1_],\r\n                ['y1', resY1_],\r\n                ['x2', resX2_],\r\n                ['y2', resY2_]\r\n            );\r\n            break;\r\n        }\r\n        case 'polygon':\r\n        case 'polyline': {\r\n            const points = parsePoints(element.getAttribute('points'));\r\n            const result = points.map(item => {\r\n                const {\r\n                    x,\r\n                    y\r\n                } = pointTo(\r\n                    localCTM,\r\n                    Number(item[0]),\r\n                    Number(item[1])\r\n                );\r\n\r\n                item[0] = x;\r\n                item[1] = y;\r\n\r\n                return item.join(' ');\r\n            }).join(' ');\r\n\r\n            attrs.push(['points', result]);\r\n            break;\r\n        }\r\n        case 'path': {\r\n            const path = element.getAttribute('d');\r\n\r\n            attrs.push(['d', resizePath(\r\n                {\r\n                    path,\r\n                    localCTM\r\n                }\r\n            )]);\r\n            break;\r\n        }\r\n\r\n    }\r\n\r\n    attrs.forEach(([key, value]) => {\r\n        element.setAttribute(key, value);\r\n    });\r\n}\r\n\r\nfunction applyTransformToHandles(\r\n    storage,\r\n    data\r\n) {\r\n    const {\r\n        box,\r\n        handles,\r\n        center\r\n    } = storage;\r\n\r\n    let {\r\n        x,\r\n        y,\r\n        width,\r\n        height,\r\n        boxMatrix\r\n    } = data;\r\n\r\n    const hW = width / 2,\r\n        hH = height / 2;\r\n\r\n    const forced = boxMatrix !== null;\r\n\r\n    const boxCTM = !forced\r\n        ? getTransformToElement(\r\n            box,\r\n            box.parentNode\r\n        )\r\n        : boxMatrix;\r\n\r\n    const boxCenter = pointTo(boxCTM, x + hW, y + hH);\r\n\r\n    const attrs = {\r\n        tl: pointTo(boxCTM, x, y),\r\n        tr: pointTo(boxCTM, x + width, y),\r\n        br: pointTo(boxCTM, x + width, y + height),\r\n        bl: pointTo(boxCTM, x, y + height),\r\n        tc: pointTo(boxCTM, x + hW, y),\r\n        bc: pointTo(boxCTM, x + hW, y + height),\r\n        ml: pointTo(boxCTM, x, y + hH),\r\n        mr: pointTo(boxCTM, x + width, y + hH),\r\n        rotator: {},\r\n        center: isDef(handles.center) && !center.isShifted ? boxCenter : undefined\r\n    };\r\n\r\n    // if (forced) { \r\n    //     attrs.center = pointTo(\r\n    //         boxCTM, \r\n    //         center.x, \r\n    //         center.y\r\n    //     );\r\n    //     console.log(attrs.center);\r\n    // }\r\n\r\n    const theta = Math.atan2(\r\n        attrs.tl.y - attrs.tr.y,\r\n        attrs.tl.x - attrs.tr.x\r\n    );\r\n\r\n    attrs.rotator.x = attrs.mr.x - ROT_OFFSET * Math.cos(theta);\r\n    attrs.rotator.y = attrs.mr.y - ROT_OFFSET * Math.sin(theta);\r\n\r\n    const {\r\n        normal,\r\n        radius\r\n    } = handles;\r\n\r\n    if (isDef(normal)) {\r\n        normal.x1.baseVal.value = attrs.mr.x;\r\n        normal.y1.baseVal.value = attrs.mr.y;\r\n        normal.x2.baseVal.value = attrs.rotator.x;\r\n        normal.y2.baseVal.value = attrs.rotator.y;\r\n    }\r\n   \r\n    if (isDef(radius)) {\r\n        radius.x1.baseVal.value = boxCenter.x;\r\n        radius.y1.baseVal.value = boxCenter.y;\r\n        if (!center.isShifted) {\r\n            radius.x2.baseVal.value = boxCenter.x;\r\n            radius.y2.baseVal.value = boxCenter.y;\r\n        }\r\n    }\r\n\r\n    x += width < 0 ? width : 0;\r\n    y += height < 0 ? height : 0;\r\n\r\n    const boxAttrs = {\r\n        x,\r\n        y,\r\n        width: Math.abs(width),\r\n        height: Math.abs(height)\r\n    };\r\n\r\n    Object.keys(boxAttrs).forEach(attr => {\r\n        box.setAttribute(attr, boxAttrs[attr]);\r\n    });\r\n\r\n    Object.keys(attrs).forEach(key => {\r\n        const hdl = handles[key];\r\n        const attr = attrs[key];\r\n        if (isUndef(attr) || isUndef(hdl)) return;\r\n        hdl.setAttribute('cx', attr.x);\r\n        hdl.setAttribute('cy', attr.y);\r\n    });\r\n}\r\n\r\nfunction createHandler$1(l, t, color, key) {\r\n    const handler = createSVGElement('circle');\r\n    addClass(handler, `sjx-svg-hdl-${key}`);\r\n\r\n    const items = {\r\n        cx: l,\r\n        cy: t,\r\n        r: 5.5,\r\n        fill: color,\r\n        stroke: '#fff',\r\n        'fill-opacity': 1,\r\n        'vector-effect': 'non-scaling-stroke',\r\n        'stroke-width': 1\r\n    };\r\n\r\n    Object.keys(items).map(key => {\r\n        handler.setAttribute(key, items[key]);\r\n    });\r\n\r\n    return handler;\r\n}\r\n\r\nfunction setLineStyle(line, color) {\r\n    line.setAttribute('stroke', color);\r\n    line.setAttribute('stroke-dasharray', '3 3');\r\n    line.setAttribute('vector-effect', 'non-scaling-stroke');\r\n}\n\n// factory method for creating draggable elements\r\nfunction drag(options, obInstance) {\r\n    if (this.length) {\r\n        const Ob = (isDef(obInstance) && obInstance instanceof Observable)\r\n            ? obInstance\r\n            : new Observable();\r\n\r\n        return arrReduce.call(this, (result, item) => {\r\n            if (!(item instanceof SVGElement)) {\r\n                result.push(\r\n                    new Draggable(item, options, Ob)\r\n                );\r\n            } else {\r\n                if (checkElement(item)) {\r\n                    result.push(\r\n                        new DraggableSVG(item, options, Ob)\r\n                    );\r\n                }\r\n            }\r\n            return result;\r\n        }, []);\r\n    }\r\n}\n\nclass Cloneable extends SubjectModel {\r\n\r\n    constructor(el, options) {\r\n        super(el);\r\n        this.enable(options);\r\n    }\r\n\r\n    _init() {\r\n        const { \r\n            el, \r\n            options \r\n        } = this;\r\n        const $el = helper(el);\r\n\r\n        const {\r\n            style,\r\n            appendTo\r\n        } = options;\r\n\r\n        const css = {\r\n            position: 'absolute',\r\n            'z-index': '2147483647',\r\n            ...style\r\n        };\r\n\r\n        this.storage = {\r\n            css,\r\n            parent: isDef(appendTo) ? helper(appendTo)[0] : document.body\r\n        };\r\n\r\n        $el.on('mousedown', this._onMouseDown)\r\n            .on('touchstart', this._onTouchStart);\r\n\r\n        EVENTS.slice(0, 3).forEach((eventName) => {\r\n            this.eventDispatcher.registerEvent(eventName);\r\n        });\r\n    }\r\n\r\n    _processOptions(options) {\r\n        let _style = {},\r\n            _appendTo = null,\r\n            _stack = document,\r\n            _onInit = () => {},\r\n            _onMove = () => {},\r\n            _onDrop = () => {},\r\n            _onDestroy = () => {};\r\n        \r\n        if (isDef(options)) {\r\n            const {\r\n                style,\r\n                appendTo,\r\n                stack,\r\n                onInit,\r\n                onMove,\r\n                onDrop,\r\n                onDestroy\r\n            } = options;\r\n\r\n            _style = (isDef(style) && typeof style === 'object') ? style : _style;\r\n            _appendTo = appendTo || null;\r\n    \r\n            const dropZone = isDef(stack) \r\n                ? helper(stack)[0] \r\n                : document;\r\n    \r\n            _onInit = createMethod(onInit);\r\n            _onMove = createMethod(onMove);\r\n            _onDrop = isFunc(onDrop)\r\n                ? function(evt) {\r\n                    const {\r\n                        clone\r\n                    } = this.storage;\r\n    \r\n                    const result = objectsCollide(\r\n                        clone,\r\n                        dropZone\r\n                    );\r\n    \r\n                    if (result) {\r\n                        onDrop.call(this, evt, this.el, clone);\r\n                    }\r\n                }\r\n                : () => {};\r\n            _onDestroy = createMethod(onDestroy);\r\n        }\r\n        \r\n        this.options = {\r\n            style: _style,\r\n            appendTo: _appendTo,\r\n            stack: _stack\r\n        };\r\n\r\n        this.proxyMethods = {\r\n            onInit: _onInit,\r\n            onDrop: _onDrop,\r\n            onMove: _onMove,\r\n            onDestroy: _onDestroy\r\n        };\r\n    }\r\n\r\n    _start({ clientX, clientY }) {\r\n        const { \r\n            storage,\r\n            el\r\n        } = this;\r\n    \r\n        const {\r\n            parent,\r\n            css\r\n        } = storage; \r\n    \r\n        const { left, top } = getOffset(parent);\r\n    \r\n        css.left = `${(clientX - left)}px`;\r\n        css.top = `${(clientY - top)}px`;\r\n    \r\n        const clone = el.cloneNode(true);\r\n        helper(clone).css(css);\r\n    \r\n        storage.clientX = clientX;\r\n        storage.clientY = clientY;\r\n        storage.cx = clientX;\r\n        storage.cy = clientY;\r\n        storage.clone = clone;\r\n    \r\n        helper(parent)[0].appendChild(clone);\r\n        this._draw();\r\n    }\r\n\r\n    _moving({ clientX, clientY }) {    \r\n        const { storage } = this;\r\n    \r\n        storage.clientX = clientX;\r\n        storage.clientY = clientY;\r\n        storage.doDraw = true;\r\n        storage.doMove = true;\r\n    }\r\n    \r\n    _end(e) {\r\n        const { storage } = this;\r\n    \r\n        const {\r\n            clone,\r\n            frameId\r\n        } = storage;\r\n    \r\n        storage.doDraw = false;\r\n        cancelAnimFrame(frameId);\r\n    \r\n        if (isUndef(clone)) return;\r\n    \r\n        this.proxyMethods.onDrop.call(this, e);\r\n        clone.parentNode.removeChild(clone);\r\n    \r\n        delete storage.clone;\r\n    }\r\n\r\n    _animate() {\r\n        const { storage } = this;\r\n    \r\n        storage.frameId = requestAnimFrame(this._animate);\r\n\r\n        const {\r\n            doDraw,\r\n            clientX,\r\n            clientY,\r\n            cx,\r\n            cy\r\n        } = storage;\r\n\r\n        if (!doDraw) return;\r\n        storage.doDraw = false;\r\n\r\n        this._drag(\r\n            { \r\n                dx: clientX - cx,\r\n                dy: clientY - cy\r\n            }\r\n        );\r\n    }\r\n\r\n    _processMove(dx, dy) {\r\n        const {\r\n            clone\r\n        } = this.storage;\r\n\r\n        const translate = `translate(${dx}px, ${dy}px)`;\r\n\r\n        helper(clone).css({\r\n            transform: translate,\r\n            webkitTranform: translate,\r\n            mozTransform: translate,\r\n            msTransform: translate,\r\n            otransform: translate \r\n        });\r\n    }\r\n    \r\n    _destroy() {\r\n        const {\r\n            storage,\r\n            proxyMethods,\r\n            el\r\n        } = this;\r\n\r\n        if (isUndef(storage)) return;\r\n        helper(el)\r\n            .off('mousedown', this._onMouseDown)\r\n            .off('touchstart', this._onTouchStart);\r\n\r\n        proxyMethods.onDestroy.call(this, el);\r\n        delete this.storage;\r\n    }\r\n\r\n    disable() {\r\n        this._destroy();\r\n    }\r\n\r\n}\n\nfunction clone(options) {\n    if (this.length) {\n        return arrMap.call(this, item => {\n            return new Cloneable(item, options);\n        });\n    }\n}\n\nclass Subjx extends Helper {\r\n\r\n    drag() {\r\n        return drag.call(this, ...arguments);\r\n    }\r\n\r\n    clone() {\r\n        return clone.call(this, ...arguments);\r\n    }\r\n\r\n}\n\nfunction subjx(params) {\r\n    return new Subjx(params);\r\n}\r\n\r\nObject.defineProperty(subjx, 'createObservable', {\r\n    value: () => {\r\n        return new Observable();\r\n    }\r\n});\r\n\r\nObject.defineProperty(subjx, 'Subjx', {\r\n    value: Subjx\r\n});\r\n\r\nObject.defineProperty(subjx, 'Observable', {\r\n    value: Observable\r\n});\n\nmodule.exports = subjx;\n","'use strict';\r\n\r\nif (process.env.NODE_ENV === 'production') {\r\n    module.exports = require('./dist/js/subjx.common.js');\r\n} else {\r\n    module.exports = require('./dist/js/subjx.dev.common.js');\r\n}","import \"subjx/dist/style/subjx.css\";\r\n\r\nimport subjx from \"subjx\";\r\n\r\nvar zoom_value_formula = 1;\r\n\r\n// self executing function here\r\n(function() {\r\n    // your page initialization code here\r\n    // the DOM will be available here\r\n\r\n    document.getElementById(\"cacluate_position\").onclick = cacluatePosition;\r\n    document.getElementById(\"zoom_canvas\").onchange = changeZoomCanvas;\r\n\r\n    const selected_index = document.getElementById(\"zoom_canvas\").selectedIndex;\r\n    console.log(\"selected_index \", selected_index)\r\n    defaultSelectedZoomCanvas(selected_index);\r\n\r\n    checkAllImagesLoaded();\r\n\r\n\r\n})();\r\n\r\nfunction transformToFit() {\r\n    const images = document.querySelectorAll(\".image_element\");\r\n    console.log(\"images \", images);\r\n    let maxWidth = 0;\r\n    images.forEach((image) => {\r\n      const width = image.clientWidth;\r\n      maxWidth = Math.max(maxWidth, width);\r\n      const height = image.clientHeight;\r\n      console.log(`Image width: ${width}px, height: ${height}px`);\r\n    });\r\n    let container = document.getElementById(\"stack\");\r\n    let offsets_world = document.getElementById(\"world\");\r\n    let scaleValue = 1;\r\n    // if(maxWidth>container.clientWidth){\r\n      scaleValue = container.clientWidth / maxWidth;\r\n    if (scaleValue <= 1) {\r\n      // scaleValue = container.clientWidth / maxWidth - 0.01;\r\n      offsets_world.style.transform = `scale(${scaleValue-0.01})`;\r\n    } else {\r\n      // scaleValue = container.clientWidth / maxWidth - 0.2;\r\n      \r\n      offsets_world.style.transform = `scale(${scaleValue -0.1})`;\r\n    }\r\n    zoom_value_formula = 1 / scaleValue;\r\n    // }\r\n    // else{\r\n    //     scaleValue=maxWidth;\r\n    // offsets_world.style.transform = `scale(${scaleValue})`;\r\n    // }\r\n  \r\n    // if(scaleValue>0){\r\n    // zoom_value_formula = 1/scaleValue;\r\n    // }\r\n    // console.log(container.clientWidth/maxWidth-0.01)\r\n  }\r\nfunction changeZoomCanvas(event) {\r\n    console.log(\"doSomething\", event);\r\n\r\n    const selected_index = event.target.selectedIndex;\r\n    console.log(\"selected_index \", selected_index);\r\n\r\n    defaultSelectedZoomCanvas(selected_index)\r\n}\r\n\r\nfunction defaultSelectedZoomCanvas(selected_index) {\r\n\r\n    let offsets_world = document.getElementById('world');\r\n\r\n    offsets_world.style.transformOrigin = '0px 0px';\r\n    if (selected_index == 0) {\r\n        zoom_value_formula = 2.5;\r\n        offsets_world.style.transform = 'scale(0.4)';\r\n    } else if (selected_index == 1) {\r\n        zoom_value_formula = 2;\r\n        offsets_world.style.transform = 'scale(0.5)';\r\n    } else if (selected_index == 2) {\r\n        zoom_value_formula = 1.667;\r\n        offsets_world.style.transform = 'scale(0.6)';\r\n    } else if (selected_index == 3) {\r\n        zoom_value_formula = 1.43;\r\n        offsets_world.style.transform = 'scale(0.7)';\r\n    } else if (selected_index == 4) {\r\n        zoom_value_formula = 1.25;\r\n        offsets_world.style.transform = 'scale(0.8)';\r\n    } else if (selected_index == 5) {\r\n        zoom_value_formula = 1.1;\r\n        offsets_world.style.transform = 'scale(0.9)';\r\n    } else if (selected_index == 6) {\r\n        zoom_value_formula = 1;\r\n        offsets_world.style.transform = 'scale(1)';\r\n        transformToFit()\r\n    } else if (selected_index == 7) {\r\n        zoom_value_formula = 0.82;\r\n        offsets_world.style.transform = 'scale(1.2)';\r\n    }\r\n}\r\n\r\nfunction cacluatePosition() {\r\n\r\n    var pagesOffsetObject = [{\"height\":3329.05078125,\"snapshots_name\":\"1448/samplepdf-1632023123525/images/sample-1.png\",\"image_height\":3303.70361328125,\"image_width\":2553.70361328125},{\"height\":3329.05078125,\"snapshots_name\":\"1448/samplepdf-1632023123525/images/sample-2.png\",\"image_height\":3303.70361328125,\"image_width\":2553.70361328125},{\"height\":1065.0462646484375,\"snapshots_name\":\"1448/SampleJPGImagekbmbjpg-1632023123544/images/SampleJPGImage_200kbmb-1.png\",\"image_height\":1039.6990966796875,\"image_width\":1039.6990966796875}];\r\n\r\n    console.log(xDraggable);\r\n\r\n    let meta_data = [];\r\n    let margin_gap = 24;\r\n\r\n    const array_xDraggable = xDraggable;\r\n    for (let index = 1; index < array_xDraggable.length; index++) \r\n    {\r\n        const draggable_element = array_xDraggable[index][0];\r\n        \r\n        console.log(\"draggable_element \", draggable_element);\r\n\r\n        const draggable_element_main = draggable_element[\"el\"];\r\n\r\n        let page = 0;\r\n\r\n        const temp_meta_data_top =\r\n        parseInt($(draggable_element_main).css(\"top\").slice(0, -2)) +\r\n        (parseInt($(draggable_element_main).css(\"transform\").split(\",\")[5])\r\n            ? parseInt($(draggable_element_main).css(\"transform\").split(\",\")[5])\r\n            : 0);\r\n\r\n\r\n        for (let j = 0; j < pagesOffsetObject.length; j++) \r\n        {\r\n            const snapshots_name = pagesOffsetObject[j].snapshots_name;\r\n            console.log(\"snapshots_name \", snapshots_name);\r\n\r\n            const current_page_image_height = pagesOffsetObject[j].image_height;\r\n            const current_page_image_width = pagesOffsetObject[j].image_width;\r\n\r\n            let image_document_element = document.querySelector(\"[snapshots_name='\"+snapshots_name+\"']\").querySelectorAll('img')[0];\r\n            console.log(\"image_document_element \", image_document_element);\r\n\r\n            let offsets = draggable_element_main.getBoundingClientRect();\r\n            console.log(\"offsets \", offsets);\r\n\r\n            let offsets_document_image = image_document_element.getBoundingClientRect();\r\n            console.log(\"offsets \", offsets);\r\n\r\n            let top = (offsets.top - offsets_document_image.top)*zoom_value_formula;\r\n            const left = (offsets.left - offsets_document_image.left)*zoom_value_formula;\r\n            const width = offsets.width * zoom_value_formula;\r\n            const height = offsets.height * zoom_value_formula;\r\n            const image_width = offsets_document_image.width * zoom_value_formula;\r\n            const image_height = offsets_document_image.height * zoom_value_formula;\r\n\r\n            page = j + 1;\r\n                meta_data.push({\r\n                    top: Math.ceil(top),\r\n                    left: Math.ceil(left),\r\n                    width: Math.ceil(width),\r\n                    height: Math.ceil(height),\r\n                    page: page,\r\n                    documents_top: Math.ceil(temp_meta_data_top),\r\n                });\r\n                break;\r\n        }\r\n\r\n        // let element_object = {\r\n        //     top : top,\r\n        //     left : left,\r\n        //     // snapshots_name : snapshots_name,\r\n        //     // document_key : document_key,\r\n        //     width : width,\r\n        //     height : height,\r\n        //     // image_width : image_width, \r\n        //     // image_height : image_height\r\n        // }\r\n\r\n        // meta_data.push(element_object);\r\n\r\n        if(array_xDraggable.length-1 == index)\r\n        {\r\n            console.log(\"meta_data \", meta_data);\r\n        }\r\n        \r\n    }\r\n  \r\n}\r\n\r\nconst xElem = subjx(\".draggable\");\r\nconst options = {\r\n    container: '#world',\r\n    snap: {\r\n        x: 0,\r\n        y: 0,\r\n        angle: 0\r\n    },\r\n    cursorMove: 'move',\r\n    cursorRotate: 'crosshair',\r\n    cursorResize: 'pointer',\r\n    rotatable : false,\r\n\r\n    ...methods\r\n\r\n}\r\n\r\nconst methods = {\r\n    onInit(elements) {\r\n        // fires on tool activation\r\n        console.log(\"onInit \", elements)\r\n    },\r\n    onMove({\r\n        clientX,\r\n        clientY,\r\n        dx,\r\n        dy,\r\n        transform\r\n    }) {\r\n        // fires on moving\r\n        console.log(\"onMove \", clientX)\r\n    },\r\n    onResize({\r\n        clientX,\r\n        clientY,\r\n        dx,\r\n        dy,\r\n        transform,\r\n        width,\r\n        height\r\n    }) {\r\n        // fires on resizing\r\n        console.log(\"onResize \", clientX)\r\n    },\r\n    onRotate({\r\n        clientX,\r\n        clientY,\r\n        delta,\r\n        transform\r\n    }) {\r\n        // fires on rotation\r\n        console.log(\"onRotate \", clientX)\r\n    },\r\n    onDrop({\r\n        clientX,\r\n        clientY\r\n    }) {\r\n        // fires on drop\r\n        console.log(\"onDrop \", clientX)\r\n    },\r\n    onDestroy(el) {\r\n        // fires on tool deactivation\r\n        console.log(\"onDestroy \", el)\r\n    }\r\n}\r\nlet xDraggable = xElem.drag(options);\r\n\r\nsubjx('.clone').clone({\r\n    stack: '#container',\r\n    appendTo: '#stack',\r\n    onInit(el) {\r\n        // fires on tool activation;\r\n        console.log(\"clone init\")\r\n    },\r\n    onMove(dx, dy) {\r\n        // fires on moving\r\n        // console.log(\"fires on moving \", dx, dy)\r\n    },\r\n    onDrop(e, el, clone) {\r\n        // fires on drop\r\n        console.log(\"onDrop e \", e);\r\n        console.log(\"onDrop el \", el);\r\n        console.log(\"onDrop clone \", clone);\r\n        let parent = document.getElementById(\"world\");\r\n\r\n        // console.log(xDraggable.length)\r\n        const stack = subjx('#world')[0],\r\n            offset = stack.getBoundingClientRect(),\r\n            drag_div = document.createElement('div');\r\n\r\n        // const xDraggable_length = xDraggable.length;\r\n\r\n        // drag_div.setAttribute(\"id\", \"item_\"+(xDraggable_length+1));\r\n        drag_div.setAttribute(\"class\", \"draggable\");\r\n        drag_div.setAttribute(\"document_id\", e.target.id);\r\n        drag_div.style.top = `${(e.clientY - offset.top)*zoom_value_formula}px`;\r\n        drag_div.style.left = `${(e.clientX - offset.left)*zoom_value_formula}px`;\r\n\r\n        console.log(\"top \", e.clientY, \" \", offset.top, \" -> \", ((e.clientY - offset.top) * zoom_value_formula));\r\n        console.log(\"left \", e.clientX, \" \", offset.left, \" -> \", ((e.clientX - offset.left) * zoom_value_formula));\r\n\r\n        // drag_div.style.top = \"150px\";\r\n        // drag_div.style.left = \"600px\";\r\n\r\n        let drag_img = document.createElement('img');\r\n        drag_img.style.background = \"url('https://wesign.com/assets/images_dev/sign_box_2.png') 50% center / contain no-repeat, rgb(255, 214, 91)\";\r\n        drag_img.style.opacity = 0.8;\r\n        drag_img.style.border =  '1px solid rgb(255, 255, 118)';\r\n        drag_img.style.borderRadius =  '5px';\r\n        drag_img.style.width = '100%';\r\n        drag_img.style.height =  '100%';\r\n\r\n\r\n        drag_div.appendChild(drag_img);\r\n        parent.appendChild(drag_div);\r\n\r\n        xDraggable.push(\r\n            subjx(drag_div).drag(options)\r\n        );\r\n    },\r\n    onDestroy() {\r\n        // fires on tool deactivation\r\n    }\r\n});\r\n\r\n\r\nsubjx('.clone').on('click', async () => {\r\n    console.log(\"single\");\r\n\r\n});\r\n\r\nfunction checkAllImagesLoaded() {\r\n    var imgs = document.images,\r\n    len = imgs.length,\r\n    counter = 0;\r\n\r\n    [].forEach.call( imgs, function( img ) {\r\n        if(img.complete)\r\n        incrementCounter();\r\n        else\r\n        img.addEventListener( 'load', incrementCounter, false );\r\n    } );\r\n\r\n    function incrementCounter() {\r\n        counter++;\r\n        if ( counter === len ) {\r\n            console.log( 'All images loaded!' );\r\n            fitToWidth();\r\n        }\r\n    }\r\n\r\n}\r\n\r\nfunction fitToWidth() {\r\n    transformToFit()\r\n    \r\n\r\n}\r\n\r\n\r\n","var bundleURL = null;\nfunction getBundleURLCached() {\n  if (!bundleURL) {\n    bundleURL = getBundleURL();\n  }\n\n  return bundleURL;\n}\n\nfunction getBundleURL() {\n  // Attempt to find the URL of the current script and use that as the base URL\n  try {\n    throw new Error;\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\\/\\/[^)\\n]+/g);\n    if (matches) {\n      return getBaseURL(matches[0]);\n    }\n  }\n\n  return '/';\n}\n\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\\/\\/.+)?\\/[^/]+(?:\\?.*)?$/, '$1') + '/';\n}\n\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\n","var bundle = require('./bundle-url');\n\nfunction updateLink(link) {\n  var newLink = link.cloneNode();\n  newLink.onload = function () {\n    link.remove();\n  };\n  newLink.href = link.href.split('?')[0] + '?' + Date.now();\n  link.parentNode.insertBefore(newLink, link.nextSibling);\n}\n\nvar cssTimeout = null;\nfunction reloadCSS() {\n  if (cssTimeout) {\n    return;\n  }\n\n  cssTimeout = setTimeout(function () {\n    var links = document.querySelectorAll('link[rel=\"stylesheet\"]');\n    for (var i = 0; i < links.length; i++) {\n      if (bundle.getBaseURL(links[i].href) === bundle.getBundleURL()) {\n        updateLink(links[i]);\n      }\n    }\n\n    cssTimeout = null;\n  }, 50);\n}\n\nmodule.exports = reloadCSS;\n"]}
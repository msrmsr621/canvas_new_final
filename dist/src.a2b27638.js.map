{"version":3,"sources":["node_modules/subjx/dist/js/subjx.dev.common.js","node_modules/subjx/index.js","src/index.js","node_modules/parcel-bundler/src/builtins/bundle-url.js","node_modules/parcel-bundler/src/builtins/css-loader.js","node_modules/parcel-bundler/src/builtins/hmr-runtime.js"],"names":["module","exports","require","_subjx2","_interopRequireDefault","obj","__esModule","default","_typeof","Symbol","iterator","constructor","prototype","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","toString","call","slice","name","Array","from","test","len","length","arr2","_i","_s","_e","_x","_r","_arr","_n","_d","next","done","push","value","err","return","isArray","_regeneratorRuntime","Op","hasOwn","hasOwnProperty","defineProperty","key","desc","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","enumerable","configurable","writable","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","create","context","Context","makeInvokeMethod","tryCatch","fn","arg","type","ContinueSentinel","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","method","_invoke","AsyncIterator","PromiseImpl","invoke","resolve","reject","record","result","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","state","Error","doneResult","delegate","delegateResult","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","methodName","undefined","info","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","displayName","isGeneratorFunction","genFun","ctor","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","val","object","reverse","pop","skipTempReset","prev","charAt","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","_catch","thrown","delegateYield","asyncGeneratorStep","gen","_next","_throw","_asyncToGenerator","args","arguments","apply","ownKeys","enumerableOnly","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","_objectSpread","target","source","_defineProperty","getOwnPropertyDescriptors","defineProperties","_toPropertyKey","_toPrimitive","String","input","hint","prim","toPrimitive","res","Number","zoom_value_formula","scaleValue","document","getElementById","onclick","cacluatePosition","onchange","changeZoomCanvas","selected_index","selectedIndex","console","log","defaultSelectedZoomCanvas","checkAllImagesLoaded","addEventListener","moveCursor","clickEvent","event","clicked","fitTextToImage","divs","querySelectorAll","div","text_div","getElementsByClassName","image_div","style","width","clientWidth","transformToFit","images","maxWidth","image","Math","max","height","clientHeight","concat","container","offsets_world","transform","transformOrigin","pagesOffsetObject","xDraggable","meta_data","margin_gap","array_xDraggable","index","draggable_element","draggable_element_main","page","temp_meta_data_top","parseInt","$","css","split","j","snapshots_name","current_page_image_height","image_height","current_page_image_width","image_width","image_document_element","querySelector","offsets","getBoundingClientRect","offsets_document_image","top","left","ceil","documents_top","elementToBeCloned","elementToBeClonedDup","xElem","subjx","options","snap","x","y","angle","cursorMove","cursorRotate","cursorResize","rotatable","methods","onInit","elements","onMove","_ref","clientX","clientY","dx","dy","onResize","_ref2","onRotate","_ref3","delta","onDrop","_ref4","onDestroy","el","drag","cloneElement","e","parent","stack","offset","drag_div","createElement","setAttribute","id","drag_img","background","opacity","border","borderRadius","appendChild","CloneElementUsingXY","target_id","clone","appendTo","on","_ref5","_callee","a","_callee$","_context","removeChild","mouseY","mouseX","element","isHover","parentElement","_ref6","_callee2","_container","_callee2$","_context2","setTimeout","cloneNode","position","pointerEvents","_x2","_callee3","getStartEnd","_getStartEnd","_getStartEnd2","containerStart","containerEnd","maxPercentage","maxDiv","maxDivRect","_callee3$","_context3","_getStartEnd5","elementRect","elementStart","elementEnd","_getStartEnd3","_getStartEnd4","min","elPercentage","_ref8","_callee4","_callee4$","_context4","_x3","imgs","counter","img","incrementCounter","fitToWidth","scrollCheck","bottom","window","innerHeight","bundleURL","getBundleURLCached","getBundleURL","matches","match","getBaseURL","url","replace","bundle","updateLink","link","newLink","onload","remove","href","Date","now","parentNode","insertBefore","nextSibling","cssTimeout","reloadCSS","links","OVERLAY_ID","OldModule","Module","moduleName","hot","data","hotData","_acceptCallbacks","_disposeCallbacks","accept","dispose","checkedAssets","assetsToAccept","isParcelRequire","WebSocket","hostname","location","protocol","ws","onmessage","JSON","parse","handled","assets","asset","isNew","didAccept","hmrAcceptCheck","global","parcelRequire","every","generated","js","clear","hmrApply","v","hmrAcceptRun","reload","close","onclose","removeErrorOverlay","message","overlay","createErrorOverlay","body","stackTrace","innerText","innerHTML","getParents","modules","parents","k","d","dep","Function","deps","cached","cache","some","cb"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGAA,IAAI6X,SAAS,GAAG,IAAI;AACpB,SAASC,kBAAkBA,CAAA,EAAG;EAC5B,IAAI,CAACD,SAAS,EAAE;IACdA,SAAS,GAAGE,YAAY,EAAE;EAC5B;EAEA,OAAOF,SAAS;AAClB;AAEA,SAASE,YAAYA,CAAA,EAAG;EACtB;EACA,IAAI;IACF,MAAM,IAAIhR,KAAK;EACjB,CAAC,CAAC,OAAO/D,GAAG,EAAE;IACZ,IAAIgV,OAAO,GAAG,CAAC,EAAE,GAAGhV,GAAG,CAACsQ,KAAK,EAAE2E,KAAK,CAAC,+DAA+D,CAAC;IACrG,IAAID,OAAO,EAAE;MACX,OAAOE,UAAU,CAACF,OAAO,CAAC,CAAC,CAAC,CAAC;IAC/B;EACF;EAEA,OAAO,GAAG;AACZ;AAEA,SAASE,UAAUA,CAACC,GAAG,EAAE;EACvB,OAAO,CAAC,EAAE,GAAGA,GAAG,EAAEC,OAAO,CAAC,gFAAgF,EAAE,IAAI,CAAC,GAAG,GAAG;AACzH;AAEAnY,OAAO,CAAC8X,YAAY,GAAGD,kBAAkB;AACzC7X,OAAO,CAACiY,UAAU,GAAGA,UAAU;;AC5B/B,IAAIG,MAAM,GAAGnY,OAAO,CAAC,cAAc,CAAC;AAEpC,SAASoY,UAAUA,CAACC,IAAI,EAAE;EACxB,IAAIC,OAAO,GAAGD,IAAI,CAAC/C,SAAS,EAAE;EAC9BgD,OAAO,CAACC,MAAM,GAAG,YAAY;IAC3BF,IAAI,CAACG,MAAM,EAAE;EACf,CAAC;EACDF,OAAO,CAACG,IAAI,GAAGJ,IAAI,CAACI,IAAI,CAACxI,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGyI,IAAI,CAACC,GAAG,EAAE;EACzDN,IAAI,CAACO,UAAU,CAACC,YAAY,CAACP,OAAO,EAAED,IAAI,CAACS,WAAW,CAAC;AACzD;AAEA,IAAIC,UAAU,GAAG,IAAI;AACrB,SAASC,SAASA,CAAA,EAAG;EACnB,IAAID,UAAU,EAAE;IACd;EACF;EAEAA,UAAU,GAAG1D,UAAU,CAAC,YAAY;IAClC,IAAI4D,KAAK,GAAGrM,QAAQ,CAACmB,gBAAgB,CAAC,wBAAwB,CAAC;IAC/D,KAAK,IAAIlN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoY,KAAK,CAACjX,MAAM,EAAEnB,CAAC,EAAE,EAAE;MACrC,IAAIsX,MAAM,CAACH,UAAU,CAACiB,KAAK,CAACpY,CAAC,CAAC,CAAC4X,IAAI,CAAC,KAAKN,MAAM,CAACN,YAAY,EAAE,EAAE;QAC9DO,UAAU,CAACa,KAAK,CAACpY,CAAC,CAAC,CAAC;MACtB;IACF;IAEAkY,UAAU,GAAG,IAAI;EACnB,CAAC,EAAE,EAAE,CAAC;AACR;AAEAjZ,MAAM,CAACC,OAAO,GAAGiZ,SAAS;;;;;;;;AJ7B1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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","file":"src.a2b27638.js","sourceRoot":"..","sourcesContent":["/*@license\n* Drag/Rotate/Resize Library\n* Released under the MIT license, 2018-2020\n* Karen Sarksyan\n* nichollascarter@gmail.com\n*/\n'use strict';\n\nconst requestAnimFrame = \r\n    window.requestAnimationFrame ||\r\n    window.mozRequestAnimationFrame ||\r\n    window.webkitRequestAnimationFrame ||\r\n    window.msRequestAnimationFrame ||\r\n    function (f) {\r\n        return setTimeout(f, 1000 / 60);\r\n    };\r\n\r\nconst cancelAnimFrame =\r\n    window.cancelAnimationFrame ||\r\n    window.mozCancelAnimationFrame ||\r\n    function (requestID) {\r\n        clearTimeout(requestID);\r\n    };\r\n\r\nconst {\r\n    forEach,\r\n    slice: arrSlice,\r\n    map: arrMap,\r\n    reduce: arrReduce\r\n} = Array.prototype;\r\n/* eslint-disable no-console */\r\nconst { warn } = console;\r\n/* eslint-disable no-console */\r\n\r\nfunction isDef(val) {\r\n    return val !== undefined && val !== null;\r\n}\r\n\r\nfunction isUndef(val) {\r\n    return val === undefined || val === null;\r\n}\r\n\r\nfunction isFunc(val) {\r\n    return typeof val === 'function';\r\n}\r\n\r\nfunction createMethod(fn) {\r\n    return isFunc(fn)\r\n        ? function () {\r\n            fn.call(this, ...arguments);\r\n        }\r\n        : () => { };\r\n}\n\nclass Helper {\n\n    constructor(params) {\n        if (typeof params === 'string') {\n            const selector = document.querySelectorAll(params);\n            this.length = selector.length;\n            for (let count = 0; count < this.length; count++) {\n                this[count] = selector[count];\n            }\n        } else if (typeof params === 'object' &&\n            (params.nodeType === 1 || params === document)) {\n            this[0] = params;\n            this.length = 1;\n        } else if (params instanceof Helper) {\n            this.length = params.length;\n            for (let count = 0; count < this.length; count++) {\n                this[count] = params[count];\n            }\n        } else if (isIterable(params)) {\n            this.length = 0;\n            for (let count = 0; count < this.length; count++) {\n                if (params.nodeType === 1) {\n                    this[count] = params[count];\n                    this.length++;\n                }\n            }\n        } else {\n            throw new Error(`Passed parameter must be selector/element/elementArray`);\n        }\n    }\n\n    css(prop) {\n        const _getStyle = obj => {\n            let len = obj.length;\n\n            while (len--) {\n                if (obj[len].currentStyle) {\n                    return obj[len].currentStyle[prop];\n                } else if (document.defaultView && document.defaultView.getComputedStyle) {\n                    return document.defaultView.getComputedStyle(obj[len], '')[prop];\n                } else {\n                    return obj[len].style[prop];\n                }\n            }\n        };\n\n        const _setStyle = (obj, options) => {\n            let len = obj.length;\n\n            while (len--) {\n                for (const property in options) {\n                    obj[len].style[property] = options[property];\n                }\n            }\n            return obj.style;\n        };\n\n        const methods = {\n            setStyle(options) {\n                return _setStyle(this, options);\n            },\n            getStyle() {\n                return _getStyle(this);\n            }\n        };\n\n        if (typeof prop === 'string') {\n            return methods.getStyle.apply(this, arrSlice.call(arguments, 1));\n        } else if (typeof prop === 'object' || !prop) {\n            return methods.setStyle.apply(this, arguments);\n        } else {\n            warn(`Method ${prop} does not exist`);\n        }\n        return false;\n    }\n\n    on() {\n        let len = this.length;\n\n        while (len--) {\n            if (!this[len].events) {\n                this[len].events = {};\n                this[len].events[arguments[0]] = [];\n            }\n\n            if (typeof (arguments[1]) !== 'string') {\n                if (document.addEventListener) {\n                    this[len].addEventListener(\n                        arguments[0], \n                        arguments[1], \n                        arguments[2] || { passive: false }\n                    );\n                } else if (document.attachEvent) {\n                    this[len].attachEvent(`on${arguments[0]}`, arguments[1]);\n                } else {\n                    this[len][`on${arguments[0]}`] = arguments[1];\n                }\n            } else {\n                listenerDelegate(\n                    this[len], \n                    arguments[0], \n                    arguments[1], \n                    arguments[2], \n                    arguments[3], \n                    true\n                );\n            }\n        }\n        return this;\n    }\n\n    off() {\n        let len = this.length;\n\n        while (len--) {\n            if (!this[len].events) {\n                this[len].events = {};\n                this[len].events[arguments[0]] = [];\n            }\n\n            if (typeof (arguments[1]) !== 'string') {\n                if (document.removeEventListener) {\n                    this[len].removeEventListener(arguments[0], arguments[1], arguments[2]);\n                } else if (document.detachEvent) {\n                    this[len].detachEvent(`on${arguments[0]}`, arguments[1]);\n                } else {\n                    this[len][`on${arguments[0]}`] = null;\n                }\n            } else {\n                listenerDelegate(this[len], arguments[0], arguments[1], arguments[2], arguments[3], false);\n            }\n        }\n\n        return this;\n    }\n\n    is(selector) {\n        if (isUndef(selector)) return false;\n        \n        const _sel = helper(selector);\n        let len = this.length;\n\n        while (len--) {\n            if (this[len] === _sel[len]) return true;\n        }\n        return false;\n    }\n\n}\n\nfunction listenerDelegate(el, evt, sel, handler, options, act) {\n    const doit = function (event) {\n        let t = event.target;\n        while (t && t !== this) {\n            if (t.matches(sel)) {\n                handler.call(t, event);\n            }\n            t = t.parentNode;\n        }\n    };\n\n    if (act === true) {\n        if (document.addEventListener) {\n            el.addEventListener(evt, doit, options || { passive: false });\n        } else if (document.attachEvent) {\n            el.attachEvent(`on${evt}`, doit);\n        } else {\n            el[`on${evt}`] = doit;\n        }\n    } else {\n        if (document.removeEventListener) {\n            el.removeEventListener(evt, doit, options || { passive: false });\n        } else if (document.detachEvent) {\n            el.detachEvent(`on${evt}`, doit);\n        } else {\n            el[`on${evt}`] = null;\n        }\n    }\n}\n\nfunction isIterable(obj) {\n    return isDef(obj) &&\n        typeof obj === 'object' &&\n        (\n            Array.isArray(obj) ||\n            (\n                isDef(window.Symbol) &&\n                typeof obj[window.Symbol.iterator] === 'function'\n            ) ||\n            isDef(obj.forEach) ||\n            (\n                typeof (obj.length) === \"number\" &&\n                (obj.length === 0 ||\n                    (obj.length > 0 &&\n                        (obj.length - 1) in obj)\n                )\n            )\n        );\n}\n\nfunction helper(params) {\n    return new Helper(params);\n}\n\nclass Observable {\r\n\r\n    constructor() {\n        this.observers = {};\n    }\r\n\r\n    subscribe(eventName, sub) {\n        const obs = this.observers;\r\n\r\n        if (isUndef(obs[eventName])) {\n            Object.defineProperty(obs, eventName, {\r\n                value: []\r\n            });\n        }\r\n\r\n        obs[eventName].push(sub);\r\n\r\n        return this;\n    }\r\n\r\n    unsubscribe(eventName, f) {\n        const obs = this.observers;\r\n\r\n        if (isDef(obs[eventName])) {\n            const index = obs[eventName].indexOf(f);\r\n            obs[eventName].splice(index, 1);\n        }\r\n\r\n        return this;\n    }\r\n\r\n    notify(eventName, source, data) {\n        if (isUndef(this.observers[eventName])) return;\r\n\r\n        this.observers[eventName].forEach(observer => {\n            if (source === observer) return;\r\n            switch (eventName) {\n\r\n                case 'onmove':\r\n                    observer.notifyMove(data);\r\n                    break;\r\n                case 'onrotate':\r\n                    observer.notifyRotate(data);\r\n                    break;\r\n                case 'onresize':\r\n                    observer.notifyResize(data);\r\n                    break;\r\n                case 'onapply':\r\n                    observer.notifyApply(data);\r\n                    break;\r\n                case 'ongetstate':\r\n                    observer.notifyGetState(data);\r\n                    break;\r\n            \n            }\n        });\n    }\r\n\n}\n\nclass Event {\r\n\r\n    constructor(name) {\r\n        this.name = name;\r\n        this.callbacks = [];\r\n    }\r\n\r\n    registerCallback(cb) {\r\n        this.callbacks.push(cb);\r\n    }\r\n\r\n    removeCallback(cb) {\r\n        const ix = this.callbacks(cb);\r\n        this.callbacks.splice(ix, 1);\r\n    }\r\n\r\n}\r\n\r\nclass EventDispatcher {\r\n\r\n    constructor() {\r\n        this.events = {};\r\n    }\r\n\r\n    registerEvent(eventName) {\r\n        this.events[eventName] = new Event(eventName);\r\n    }\r\n\r\n    emit(ctx, eventName, eventArgs) {\r\n        this.events[eventName].callbacks.forEach((cb) => {\r\n            cb.call(ctx, eventArgs);\r\n        });\r\n    };\r\n    \r\n    addEventListener(eventName, cb) {\r\n        this.events[eventName].registerCallback(cb);\r\n    }\r\n\r\n    removeEventListener(eventName, cb) {\r\n        this.events[eventName].removeCallback(cb);\r\n    }\r\n\r\n}\n\nclass SubjectModel {\r\n\r\n    constructor(el) {\r\n        this.el = el;\r\n        this.storage = null;\r\n        this.proxyMethods = null;\r\n\r\n        this.eventDispatcher = new EventDispatcher();\r\n\r\n        this._onMouseDown = this._onMouseDown.bind(this);\r\n        this._onTouchStart = this._onTouchStart.bind(this);\r\n        this._onMouseMove = this._onMouseMove.bind(this);\r\n        this._onTouchMove = this._onTouchMove.bind(this);\r\n        this._onMouseUp = this._onMouseUp.bind(this);\r\n        this._onTouchEnd = this._onTouchEnd.bind(this);\r\n        this._animate = this._animate.bind(this);\r\n    }\r\n\r\n    enable(options) {\r\n        this._processOptions(options);\r\n        this._init(this.el);\r\n        this.proxyMethods.onInit.call(this, this.el);\r\n    }\r\n\r\n    disable() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _init() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _destroy() {\r\n        throwNotImplementedError();\r\n    }\r\n    \r\n    _processOptions() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _start() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _moving() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _end() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _animate() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _drag({ dx, dy, ...rest }) {\r\n        const transform = this._processMove(dx, dy);\r\n\r\n        const finalArgs = {\r\n            dx,\r\n            dy,\r\n            transform,\r\n            ...rest\r\n        };\r\n\r\n        this.proxyMethods.onMove.call(this, finalArgs);\r\n        this._emitEvent('drag', finalArgs);\r\n    }\r\n\r\n    _draw() {\r\n        this._animate();\r\n    }\r\n\r\n    _onMouseDown(e) {\r\n        this._start(e);\r\n        helper(document)\r\n            .on('mousemove', this._onMouseMove)\r\n            .on('mouseup', this._onMouseUp);\r\n    }\r\n\r\n    _onTouchStart(e) {\r\n        this._start(e.touches[0]);\r\n        helper(document)\r\n            .on('touchmove', this._onTouchMove)\r\n            .on('touchend', this._onTouchEnd);\r\n    }\r\n\r\n    _onMouseMove(e) {\r\n        if (e.preventDefault) {\r\n            e.preventDefault();\r\n        }\r\n        this._moving(\r\n            e,\r\n            this.el\r\n        );\r\n    }\r\n\r\n    _onTouchMove(e) {\r\n        if (e.preventDefault) {\r\n            e.preventDefault();\r\n        }\r\n        this._moving(\r\n            e.touches[0],\r\n            this.el\r\n        );\r\n    }\r\n\r\n    _onMouseUp(e) {\r\n        helper(document)\r\n            .off('mousemove', this._onMouseMove)\r\n            .off('mouseup', this._onMouseUp);\r\n\r\n        this._end(\r\n            e,\r\n            this.el\r\n        );\r\n    }\r\n\r\n    _onTouchEnd(e) {\r\n        helper(document)\r\n            .off('touchmove', this._onTouchMove)\r\n            .off('touchend', this._onTouchEnd);\r\n\r\n        if (e.touches.length === 0) {\r\n            this._end(\r\n                e.changedTouches[0],\r\n                this.el\r\n            );\r\n        }\r\n    }\r\n\r\n    _emitEvent() {\r\n        this.eventDispatcher.emit(this, ...arguments);\r\n    }\r\n\r\n    on(name, cb) {\r\n        this.eventDispatcher.addEventListener(name, cb);\r\n        return this;\r\n    }\r\n\r\n    off(name, cb) {\r\n        this.eventDispatcher.removeEventListener(name, cb);\r\n        return this;\r\n    }\r\n\r\n}\r\n\r\nfunction throwNotImplementedError() {\r\n    throw Error(`Method not implemented`);\r\n}\n\nconst EVENTS = [\r\n    'dragStart',\r\n    'drag',\r\n    'dragEnd',\r\n    'resizeStart',\r\n    'resize',\r\n    'resizeEnd',\r\n    'rotateStart',\r\n    'rotate',\r\n    'rotateEnd',\r\n    'setPointStart',\r\n    'setPointEnd'\r\n];\n\nconst RAD = Math.PI / 180;\r\n\r\nfunction snapToGrid(value, snap) {\r\n    if (snap === 0) {\r\n        return value;\r\n    } else {\r\n        const result = snapCandidate(value, snap);\r\n\r\n        if (result - value < snap) {\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\nfunction snapCandidate(value, gridSize) {\r\n    if (gridSize === 0) return value;\r\n    return Math.round(value / gridSize) * gridSize;\r\n}\r\n\r\nfunction floatToFixed(val, size = 6) {\r\n    return Number(val.toFixed(size));\r\n}\n\nfunction getOffset(node) {\r\n    return node.getBoundingClientRect();\r\n}\r\n\r\nfunction getTransform(el) {\r\n    const transform = el.css('-webkit-transform') ||\r\n        el.css('-moz-transform') ||\r\n        el.css('-ms-transform') ||\r\n        el.css('-o-transform') ||\r\n        el.css('transform') ||\r\n        'none';\r\n    return transform;\r\n}\r\n\r\nfunction parseMatrix(value) {\r\n    const transform = value.match(/[+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g);\r\n\r\n    if (transform) {\r\n        return transform.map(item => {\r\n            return parseFloat(item);\r\n        });\r\n    } else {\r\n        return [1, 0, 0, 1, 0, 0];\r\n    }\r\n}\r\n\r\nfunction addClass(node, cls) {\r\n    if (!cls) return;\r\n\r\n    if (node.classList) {\r\n        if (cls.indexOf(' ') > -1) {\r\n            cls.split(/\\s+/).forEach(cl => {\r\n                return node.classList.add(cl);\r\n            });\r\n        } else {\r\n            return node.classList.add(cls);\r\n        }\r\n    }\r\n    return node;\r\n}\r\n\r\nfunction removeClass(node, cls) {\r\n    if (!cls) return;\r\n\r\n    if (node.classList) {\r\n        if (cls.indexOf(' ') > -1) {\r\n            cls.split(/\\s+/).forEach(cl => {\r\n                return node.classList.remove(cl);\r\n            });\r\n        } else {\r\n            return node.classList.remove(cls);\r\n        }\r\n    }\r\n    return node;\r\n}\r\n\r\nfunction objectsCollide(a, b) {\r\n    const {\r\n            top: aTop,\r\n            left: aLeft\r\n        } = getOffset(a),\r\n        {\r\n            top: bTop,\r\n            left: bLeft\r\n        } = getOffset(b),\r\n        _a = helper(a),\r\n        _b = helper(b);\r\n\r\n    return !(\r\n        ((aTop < bTop) ||\r\n            (aTop + parseFloat(_a.css('height'))) > (bTop + parseFloat(_b.css('height')))) ||\r\n        ((aLeft < bLeft) ||\r\n            (aLeft + parseFloat(_a.css('width'))) > (bLeft + parseFloat(_b.css('width'))))\r\n    );\r\n}\r\n\r\nfunction matrixToCSS(arr) {\r\n    const style = `matrix(${arr.join()})`;\r\n\r\n    return {\r\n        transform: style,\r\n        webkitTranform: style,\r\n        mozTransform: style,\r\n        msTransform: style,\r\n        otransform: style\r\n    };\r\n}\n\nclass Transformable extends SubjectModel {\r\n\r\n    constructor(el, options, observable) {\r\n        super(el);\r\n        if (this.constructor === Transformable) {\r\n            throw new TypeError('Cannot construct Transformable instances directly');\r\n        }\r\n        this.observable = observable;\r\n\r\n        EVENTS.forEach((eventName) => {\r\n            this.eventDispatcher.registerEvent(eventName);\r\n        });\r\n        \r\n        this.enable(options);\r\n    }\r\n\r\n    _cursorPoint() {\r\n        throw Error(`'_cursorPoint()' method not implemented`);\r\n    }\r\n\r\n    _rotate({ radians, ...rest }) {\r\n        const resultMtrx = this._processRotate(radians);\r\n        const finalArgs = {\r\n            transform: resultMtrx,\r\n            delta: radians,\r\n            ...rest\r\n        };\r\n        this.proxyMethods.onRotate.call(this, finalArgs);\r\n        this._emitEvent('rotate', finalArgs);\r\n    }\r\n\r\n    _resize({ dx, dy, ...rest }) {\r\n        const finalValues = this._processResize(dx, dy);\r\n        const finalArgs = {\r\n            ...finalValues,\r\n            dx,\r\n            dy,\r\n            ...rest\r\n        };\r\n        this.proxyMethods.onResize.call(this, finalArgs);\r\n        this._emitEvent('resize', finalArgs);\r\n    }\r\n\r\n    _processOptions(options) {\r\n        const { el } = this;\r\n\r\n        addClass(el, 'sjx-drag');\r\n\r\n        const _snap = {\r\n            x: 10,\r\n            y: 10,\r\n            angle: 10 * RAD\r\n        };\r\n\r\n        const _each = {\r\n            move: false,\r\n            resize: false,\r\n            rotate: false\r\n        };\r\n\r\n        let _restrict = null,\r\n            _proportions = false,\r\n            _axis = 'xy',\r\n            _cursorMove = 'auto',\r\n            _cursorResize = 'auto',\r\n            _cursorRotate = 'auto',\r\n            _themeColor = '#00a8ff',\r\n            _rotationPoint = false,\r\n            _draggable = true,\r\n            _resizable = true,\r\n            _rotatable = true,\r\n            _onInit = () => { },\r\n            _onMove = () => { },\r\n            _onRotate = () => { },\r\n            _onResize = () => { },\r\n            _onDrop = () => { },\r\n            _onDestroy = () => { };\r\n\r\n        let _container = el.parentNode;\r\n\r\n        if (isDef(options)) {\r\n            const {\r\n                snap,\r\n                each,\r\n                axis,\r\n                cursorMove,\r\n                cursorResize,\r\n                cursorRotate,\r\n                rotationPoint,\r\n                restrict,\r\n                draggable,\r\n                resizable,\r\n                rotatable,\r\n                onInit,\r\n                onDrop,\r\n                onMove,\r\n                onResize,\r\n                onRotate,\r\n                onDestroy,\r\n                container,\r\n                proportions,\r\n                themeColor\r\n            } = options;\r\n\r\n            if (isDef(snap)) {\r\n                const { x, y, angle } = snap;\r\n\r\n                _snap.x = isUndef(x) ? 10 : x;\r\n                _snap.y = isUndef(y) ? 10 : y;\r\n                _snap.angle = isUndef(angle)\r\n                    ? _snap.angle\r\n                    : angle * RAD;\r\n            }\r\n\r\n            if (isDef(each)) {\r\n                const { move, resize, rotate } = each;\r\n\r\n                _each.move = move || false;\r\n                _each.resize = resize || false;\r\n                _each.rotate = rotate || false;\r\n            }\r\n\r\n            if (isDef(restrict)) {\r\n                _restrict = restrict === 'parent'\r\n                    ? el.parentNode\r\n                    : helper(restrict)[0] || document;\r\n            }\r\n\r\n            _themeColor = themeColor || '#00a8ff';\r\n            _cursorMove = cursorMove || 'auto';\r\n            _cursorResize = cursorResize || 'auto';\r\n            _cursorRotate = cursorRotate || 'auto';\r\n            _axis = axis || 'xy';\r\n\r\n            _container = isDef(container) && helper(container)[0]\r\n                ? helper(container)[0]\r\n                : _container;\r\n\r\n            _rotationPoint = rotationPoint || false;\r\n            _proportions = proportions || false;\r\n\r\n            _draggable = isDef(draggable) ? draggable : true;\r\n            _resizable = isDef(resizable) ? resizable : true;\r\n            _rotatable = isDef(rotatable) ? rotatable : true;\r\n\r\n            _onInit = createMethod(onInit);\r\n            _onDrop = createMethod(onDrop);\r\n            _onMove = createMethod(onMove);\r\n            _onResize = createMethod(onResize);\r\n            _onRotate = createMethod(onRotate);\r\n            _onDestroy = createMethod(onDestroy);\r\n        }\r\n\r\n        this.options = {\r\n            axis: _axis,\r\n            themeColor: _themeColor,\r\n            cursorMove: _cursorMove,\r\n            cursorRotate: _cursorRotate,\r\n            cursorResize: _cursorResize,\r\n            rotationPoint: _rotationPoint,\r\n            restrict: _restrict,\r\n            container: _container,\r\n            snap: _snap,\r\n            each: _each,\r\n            proportions: _proportions,\r\n            draggable: _draggable,\r\n            resizable: _resizable,\r\n            rotatable: _rotatable\r\n        };\r\n\r\n        this.proxyMethods = {\r\n            onInit: _onInit,\r\n            onDrop: _onDrop,\r\n            onMove: _onMove,\r\n            onResize: _onResize,\r\n            onRotate: _onRotate,\r\n            onDestroy: _onDestroy\r\n        };\r\n\r\n        this.subscribe(_each);\r\n    }\r\n\r\n    _animate() {\r\n        const self = this;\r\n        const {\r\n            observable,\r\n            storage,\r\n            options\r\n        } = self;\r\n\r\n        if (isUndef(storage)) return;\r\n\r\n        storage.frame = requestAnimFrame(self._animate);\r\n\r\n        if (!storage.doDraw) return;\r\n        storage.doDraw = false;\r\n\r\n        let {\r\n            dox,\r\n            doy,\r\n            clientX,\r\n            clientY,\r\n            doDrag,\r\n            doResize,\r\n            doRotate,\r\n            doSetCenter,\r\n            revX,\r\n            revY\r\n        } = storage;\r\n\r\n        const {\r\n            snap,\r\n            each: {\r\n                move: moveEach,\r\n                resize: resizeEach,\r\n                rotate: rotateEach\r\n            },\r\n            restrict,\r\n            draggable,\r\n            resizable,\r\n            rotatable\r\n        } = options;\r\n\r\n        if (doResize && resizable) {\r\n            const {\r\n                transform,\r\n                cx,\r\n                cy\r\n            } = storage;\r\n\r\n            const { x, y } = this._pointToElement(\r\n                {\r\n                    x: clientX,\r\n                    y: clientY\r\n                }\r\n            );\r\n\r\n            let dx = dox\r\n                ? snapToGrid(x - cx, snap.x / transform.scX)\r\n                : 0;\r\n\r\n            let dy = doy\r\n                ? snapToGrid(y - cy, snap.y / transform.scY)\r\n                : 0;\r\n\r\n            dx = dox ? (revX ? - dx : dx) : 0,\r\n            dy = doy ? (revY ? - dy : dy) : 0;\r\n\r\n            const args = {\r\n                dx,\r\n                dy,\r\n                clientX,\r\n                clientY\r\n            };\r\n\r\n            self._resize(args);\r\n\r\n            if (resizeEach) {\r\n                observable.notify(\r\n                    'onresize',\r\n                    self,\r\n                    args\r\n                );\r\n            }\r\n        }\r\n\r\n        if (doDrag && draggable) {\r\n            const {\r\n                restrictOffset,\r\n                elementOffset,\r\n                nx,\r\n                ny\r\n            } = storage;\r\n\r\n            if (isDef(restrict)) {\r\n                if ((clientX - restrictOffset.left) < nx - elementOffset.left) {\r\n                    clientX = nx - elementOffset.left + restrictOffset.left;\r\n                }\r\n\r\n                if ((clientY - restrictOffset.top) < ny - elementOffset.top) {\r\n                    clientY = ny - elementOffset.top + restrictOffset.top;\r\n                }\r\n            }\r\n\r\n            const dx = dox\r\n                ? snapToGrid(clientX - nx, snap.x)\r\n                : 0;\r\n\r\n            const dy = doy\r\n                ? snapToGrid(clientY - ny, snap.y)\r\n                : 0;\r\n\r\n            const args = {\r\n                dx,\r\n                dy,\r\n                clientX,\r\n                clientY\r\n            };\r\n\r\n            self._drag(\r\n                args\r\n            );\r\n\r\n            if (moveEach) {\r\n                observable.notify('onmove',\r\n                    self,\r\n                    args\r\n                );\r\n            }\r\n        }\r\n\r\n        if (doRotate && rotatable) {\r\n            const {\r\n                pressang,\r\n                center\r\n            } = storage;\r\n\r\n            const radians = Math.atan2(\r\n                clientY - center.y,\r\n                clientX - center.x\r\n            ) - pressang;\r\n\r\n            const args = {\r\n                clientX,\r\n                clientY\r\n            };\r\n\r\n            self._rotate(\r\n                {\r\n                    radians: snapToGrid(radians, snap.angle),\r\n                    ...args\r\n                }\r\n            );\r\n\r\n            if (rotateEach) {\r\n                observable.notify('onrotate',\r\n                    self,\r\n                    {\r\n                        radians,\r\n                        ...args\r\n                    }\r\n                );\r\n            }\r\n        }\r\n\r\n        if (doSetCenter && rotatable) {\r\n            const {\r\n                bx,\r\n                by\r\n            } = storage;\r\n\r\n            const { x, y } = this._pointToControls(\r\n                {\r\n                    x: clientX,\r\n                    y: clientY\r\n                }\r\n            );\r\n\r\n            self._moveCenterHandle(\r\n                x - bx,\r\n                y - by\r\n            );\r\n        }\r\n    }\r\n\r\n    _start(e) {\r\n        const {\r\n            observable,\r\n            storage,\r\n            options: { axis, restrict, each },\r\n            el\r\n        } = this;\r\n\r\n        const computed = this._compute(e);\r\n\r\n        Object.keys(computed).forEach(prop => {\r\n            storage[prop] = computed[prop];\r\n        });\r\n\r\n        const {\r\n            onRightEdge,\r\n            onBottomEdge,\r\n            onTopEdge,\r\n            onLeftEdge,\r\n            handle,\r\n            factor,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        } = computed;\r\n\r\n        const doResize =\r\n            onRightEdge ||\r\n            onBottomEdge ||\r\n            onTopEdge ||\r\n            onLeftEdge;\r\n\r\n        const {\r\n            handles\r\n        } = storage;\r\n\r\n        const {\r\n            rotator,\r\n            center,\r\n            radius\r\n        } = handles;\r\n\r\n        if (isDef(radius)) {\r\n            removeClass(radius, 'sjx-hidden');\r\n        }\r\n\r\n        const doRotate = handle.is(rotator),\r\n            doSetCenter = isDef(center)\r\n                ? handle.is(center)\r\n                : false;\r\n\r\n        const doDrag = !(doRotate || doResize || doSetCenter);\r\n\r\n        const {\r\n            clientX,\r\n            clientY\r\n        } = e;\r\n\r\n        const {\r\n            x,\r\n            y\r\n        } = this._cursorPoint(\r\n            {\r\n                clientX,\r\n                clientY\r\n            }\r\n        );\r\n\r\n        const {\r\n            x: nx,\r\n            y: ny\r\n        } = this._pointToElement({ x, y });\r\n\r\n        const {\r\n            x: bx,\r\n            y: by\r\n        } = this._pointToControls({ x, y });\r\n\r\n        const newStorageValues = {\r\n            clientX,\r\n            clientY,\r\n            nx: x,\r\n            ny: y,\r\n            cx: nx,\r\n            cy: ny,\r\n            bx,\r\n            by,\r\n            doResize,\r\n            doDrag,\r\n            doRotate,\r\n            doSetCenter,\r\n            onExecution: true,\r\n            cursor: null,\r\n            elementOffset: getOffset(el),\r\n            restrictOffset: isDef(restrict)\r\n                ? getOffset(restrict)\r\n                : null,\r\n            dox: /\\x/.test(axis) && (doResize\r\n                ?\r\n                handle.is(handles.ml) ||\r\n                handle.is(handles.mr) ||\r\n                handle.is(handles.tl) ||\r\n                handle.is(handles.tr) ||\r\n                handle.is(handles.bl) ||\r\n                handle.is(handles.br)\r\n                : true),\r\n            doy: /\\y/.test(axis) && (doResize\r\n                ?\r\n                handle.is(handles.br) ||\r\n                handle.is(handles.bl) ||\r\n                handle.is(handles.bc) ||\r\n                handle.is(handles.tr) ||\r\n                handle.is(handles.tl) ||\r\n                handle.is(handles.tc)\r\n                : true)\r\n        };\r\n\r\n        this.storage = {\r\n            ...storage,\r\n            ...newStorageValues\r\n        };\r\n\r\n        const eventArgs = {\r\n            clientX,\r\n            clientY\r\n        };\r\n\r\n        if (doResize) {\r\n            this._emitEvent('resizeStart', eventArgs);\r\n        } else if (doRotate) {\r\n            this._emitEvent('rotateStart', eventArgs);\r\n        } else if (doDrag) {\r\n            this._emitEvent('dragStart', eventArgs);\r\n        }\r\n\r\n        const {\r\n            move,\r\n            resize,\r\n            rotate\r\n        } = each;\r\n\r\n        const actionName = doResize\r\n            ? 'resize'\r\n            : (doRotate? 'rotate' : 'drag');\r\n        \r\n        const triggerEvent = \r\n            (doResize && resize) ||\r\n            (doRotate && rotate) ||\r\n            (doDrag && move);\r\n\r\n        observable.notify(\r\n            'ongetstate',\r\n            this,\r\n            {   \r\n                clientX,\r\n                clientY,\r\n                actionName,\r\n                triggerEvent,\r\n                factor,\r\n                revX,\r\n                revY,\r\n                doW,\r\n                doH\r\n            }\r\n        );\r\n        \r\n        this._draw();\r\n    }\r\n\r\n    _moving(e) {\r\n        const {\r\n            storage,\r\n            options\r\n        } = this;\r\n\r\n        const {\r\n            x,\r\n            y\r\n        } = this._cursorPoint(e);\r\n\r\n        storage.e = e;\r\n        storage.clientX = x;\r\n        storage.clientY = y;\r\n        storage.doDraw = true;\r\n\r\n        let {\r\n            doRotate,\r\n            doDrag,\r\n            doResize,\r\n            cursor\r\n        } = storage;\r\n\r\n        const {\r\n            cursorMove,\r\n            cursorResize,\r\n            cursorRotate\r\n        } = options;\r\n\r\n        if (isUndef(cursor)) {\r\n            if (doDrag) {\r\n                cursor = cursorMove;\r\n            } else if (doRotate) {\r\n                cursor = cursorRotate;\r\n            } else if (doResize) {\r\n                cursor = cursorResize;\r\n            }\r\n            helper(document.body).css({ cursor });\r\n        }\r\n    }\r\n\r\n    _end({ clientX, clientY }) {\r\n        const {\r\n            options: { each },\r\n            observable,\r\n            storage,\r\n            proxyMethods\r\n        } = this;\r\n\r\n        const {\r\n            doResize,\r\n            doDrag,\r\n            doRotate,\r\n            //doSetCenter,\r\n            frame,\r\n            handles: { radius }\r\n        } = storage;\r\n\r\n        const actionName = doResize\r\n            ? 'resize'\r\n            : (doDrag ? 'drag' : 'rotate');\r\n\r\n        storage.doResize = false;\r\n        storage.doDrag = false;\r\n        storage.doRotate = false;\r\n        storage.doSetCenter = false;\r\n        storage.doDraw = false;\r\n        storage.onExecution = false;\r\n        storage.cursor = null;\r\n\r\n        this._apply(actionName);\r\n\r\n        const eventArgs = {\r\n            clientX, \r\n            clientY\r\n        };\r\n\r\n        proxyMethods.onDrop.call(this, eventArgs);\r\n\r\n        if (doResize) {\r\n            this._emitEvent('resizeEnd', eventArgs);\r\n        } else if (doRotate) {\r\n            this._emitEvent('rotateEnd', eventArgs);\r\n        } else if (doDrag) {\r\n            this._emitEvent('dragEnd', eventArgs);\r\n        }\r\n\r\n        const {\r\n            move,\r\n            resize,\r\n            rotate\r\n        } = each;\r\n\r\n        const triggerEvent = \r\n            (doResize && resize) ||\r\n            (doRotate && rotate) ||\r\n            (doDrag && move);\r\n\r\n        observable.notify(\r\n            'onapply',\r\n            this,\r\n            {\r\n                clientX, \r\n                clientY,\r\n                actionName,\r\n                triggerEvent\r\n            }\r\n        );\r\n\r\n        cancelAnimFrame(frame);\r\n\r\n        helper(document.body).css({ cursor: 'auto' });\r\n        if (isDef(radius)) {\r\n            addClass(radius, 'sjx-hidden');\r\n        }  \r\n    }\r\n\r\n    _compute(e) {\r\n        const {\r\n            handles\r\n        } = this.storage;\r\n\r\n        const handle = helper(e.target);\r\n\r\n        const {\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH,\r\n            ...rest\r\n        } = this._checkHandles(handle, handles);\r\n\r\n        const _computed = this._getState({\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        });\r\n\r\n        const {\r\n            x: clientX,\r\n            y: clientY\r\n        } = this._cursorPoint(e);\r\n\r\n        const pressang = Math.atan2(\r\n            clientY - _computed.center.y,\r\n            clientX - _computed.center.x\r\n        );\r\n\r\n        return {\r\n            ..._computed,\r\n            ...rest,\r\n            handle,\r\n            pressang\r\n        };\r\n    }\r\n\r\n    _checkHandles(handle, handles) {\r\n        const { tl, tc, tr, bl, br, bc, ml, mr } = handles;\r\n        const isTL = isDef(tl) ? handle.is(tl) : false,\r\n            isTC = isDef(tc) ? handle.is(tc) : false,\r\n            isTR = isDef(tr) ? handle.is(tr) : false,\r\n            isBL = isDef(bl) ? handle.is(bl) : false,\r\n            isBC = isDef(bc) ? handle.is(bc) : false,\r\n            isBR = isDef(br) ? handle.is(br) : false,\r\n            isML = isDef(ml) ? handle.is(ml) : false,\r\n            isMR = isDef(mr) ? handle.is(mr) : false;\r\n\r\n        //reverse axis\r\n        const revX = isTL || isML || isBL || isTC,\r\n            revY = isTL || isTR || isTC || isML;\r\n\r\n        const onTopEdge = isTC || isTR || isTL,\r\n            onLeftEdge = isTL || isML || isBL,\r\n            onRightEdge = isTR || isMR || isBR,\r\n            onBottomEdge = isBR || isBC || isBL;\r\n\r\n        const doW = isML || isMR,\r\n            doH = isTC || isBC;\r\n\r\n        return {\r\n            revX,\r\n            revY,\r\n            onTopEdge,\r\n            onLeftEdge,\r\n            onRightEdge,\r\n            onBottomEdge,\r\n            doW,\r\n            doH\r\n        };\r\n    }\r\n\r\n    notifyMove() {\r\n        this._drag(...arguments);\r\n    }\r\n\r\n    notifyRotate({ radians, ...rest }) {\r\n        const {\r\n            snap: { angle }\r\n        } = this.options;\r\n\r\n        this._rotate(\r\n            {\r\n                radians: snapToGrid(radians, angle),\r\n                ...rest\r\n            }\r\n        );\r\n    }\r\n\r\n    notifyResize() {\r\n        this._resize(...arguments);\r\n    }\r\n\r\n    notifyApply({ clientX, clientY, actionName, triggerEvent }) {\r\n        this.proxyMethods.onDrop.call(this, { clientX, clientY });\r\n        if (triggerEvent) {\r\n            this._apply(actionName);\r\n            this._emitEvent(`${actionName}End`, { clientX, clientY });\r\n        }\r\n    }\r\n\r\n    notifyGetState({ clientX, clientY, actionName, triggerEvent, ...rest}) {\r\n        if (triggerEvent) {\r\n            const recalc = this._getState(\r\n                rest\r\n            );\r\n    \r\n            this.storage = {\r\n                ...this.storage,\r\n                ...recalc\r\n            };\r\n            this._emitEvent(`${actionName}Start`, { clientX, clientY });\r\n        }\r\n    }\r\n\r\n    subscribe({ resize, move, rotate }) {\r\n        const { observable: ob } = this;\r\n\r\n        if (move || resize || rotate) {\r\n            ob.subscribe('ongetstate', this)\r\n                .subscribe('onapply', this);\r\n        }\r\n\r\n        if (move) {\r\n            ob.subscribe('onmove', this);\r\n        }\r\n        if (resize) {\r\n            ob.subscribe('onresize', this);\r\n        }\r\n        if (rotate) {\r\n            ob.subscribe('onrotate', this);\r\n        }\r\n    }\r\n\r\n    unsubscribe() {\r\n        const { observable: ob } = this;\r\n\r\n        ob.unsubscribe('ongetstate', this)\r\n            .unsubscribe('onapply', this)\r\n            .unsubscribe('onmove', this)\r\n            .unsubscribe('onresize', this)\r\n            .unsubscribe('onrotate', this);\r\n    }\r\n\r\n    disable() {\r\n        const {\r\n            storage,\r\n            proxyMethods,\r\n            el\r\n        } = this;\r\n\r\n        if (isUndef(storage)) return;\r\n\r\n        // unexpected case\r\n        if (storage.onExecution) {\r\n            this._end();\r\n            helper(document)\r\n                .off('mousemove', this._onMouseMove)\r\n                .off('mouseup', this._onMouseUp)\r\n                .off('touchmove', this._onTouchMove)\r\n                .off('touchend', this._onTouchEnd);\r\n        }\r\n\r\n        removeClass(el, 'sjx-drag');\r\n\r\n        this._destroy();\r\n        this.unsubscribe();\r\n\r\n        proxyMethods.onDestroy.call(this, el);\r\n        delete this.storage;\r\n    }\r\n\r\n    exeDrag({ dx, dy }) {\r\n        const { draggable } = this.options;\r\n        if (!draggable) return;\r\n    \r\n        this.storage = {\r\n            ...this.storage,\r\n            ...this._getState({ \r\n                revX: false, \r\n                revY: false, \r\n                doW: false, \r\n                doH: false \r\n            })\r\n        };\r\n\r\n        this._drag({ dx, dy });\r\n        this._apply('drag');\r\n    }\r\n\r\n    exeResize({ dx, dy, revX, revY, doW, doH }) {\r\n        const { resizable } = this.options;\r\n        if (!resizable) return;\r\n\r\n        this.storage = {\r\n            ...this.storage,\r\n            ...this._getState({ \r\n                revX: revX || false,\r\n                revY: revY || false,\r\n                doW: doW || false,\r\n                doH: doH || false\r\n            })\r\n        };\r\n\r\n        this._resize({ dx, dy });\r\n        this._apply('resize');\r\n    }\r\n\r\n    exeRotate({ delta }) {\r\n        const { rotatable } = this.options;\r\n        if (!rotatable) return;\r\n\r\n        this.storage = {\r\n            ...this.storage,\r\n            ...this._getState({ \r\n                revX: false, \r\n                revY: false, \r\n                doW: false, \r\n                doH: false \r\n            })\r\n        };\r\n\r\n        this._rotate({ radians: delta });\r\n        this._apply('rotate');\r\n    }\r\n\r\n}\n\nfunction matrixTransform({ x, y }, matrix) {\r\n    const [a, b, c, d, e, f] = matrix;\r\n\r\n    return {\r\n        x: a * x + c * y + e,\r\n        y: b * x + d * y + f\r\n    };\r\n}\r\n\r\n//http://blog.acipo.com/matrix-inversion-in-javascript/\r\nfunction matrixInvert(ctm) {\r\n    // I use Guassian Elimination to calculate the inverse:\r\n    // (1) 'augment' the matrix (left) by the identity (on the right)\r\n    // (2) Turn the matrix on the left into the identity by elemetry row ops\r\n    // (3) The matrix on the right is the inverse (was the identity matrix)\r\n    // There are 3 elemtary row ops: (I combine b and c in my code)\r\n    // (a) Swap 2 rows\r\n    // (b) Multiply a row by a scalar\r\n    // (c) Add 2 rows\r\n\r\n    const M = [\r\n        [ctm[0], ctm[2], ctm[4]],\r\n        [ctm[1], ctm[3], ctm[5]],\r\n        [0, 0, 1]\r\n    ];\r\n\r\n    //if the matrix isn't square: exit (error)\r\n    if (M.length !== M[0].length) {\r\n        return;\r\n    }\r\n\r\n    //create the identity matrix (I), and a copy (C) of the original\r\n    const dim = M.length;\r\n\r\n    const I = [],\r\n        C = [];\r\n\r\n    for (let i = 0; i < dim; i += 1) {\r\n        // Create the row\r\n        I[I.length] = [];\r\n        C[C.length] = [];\r\n        for (let j = 0; j < dim; j += 1) {\r\n            //if we're on the diagonal, put a 1 (for identity)\r\n            if (i == j) {\r\n                I[i][j] = 1;\r\n            } else {\r\n                I[i][j] = 0;\r\n            }\r\n\r\n            // Also, make the copy of the original\r\n            C[i][j] = M[i][j];\r\n        }\r\n    }\r\n\r\n    // Perform elementary row operations\r\n    for (let i = 0; i < dim; i += 1) {\r\n        // get the element e on the diagonal\r\n        let e = C[i][i];\r\n\r\n        // if we have a 0 on the diagonal (we'll need to swap with a lower row)\r\n        if (e === 0) {\r\n            //look through every row below the i'th row\r\n            for (let ii = i + 1; ii < dim; ii += 1) {\r\n                //if the ii'th row has a non-0 in the i'th col\r\n                if (C[ii][i] !== 0) {\r\n                    //it would make the diagonal have a non-0 so swap it\r\n                    for (let j = 0; j < dim; j++) {\r\n                        e = C[i][j]; //temp store i'th row\r\n                        C[i][j] = C[ii][j]; //replace i'th row by ii'th\r\n                        C[ii][j] = e; //repace ii'th by temp\r\n                        e = I[i][j]; //temp store i'th row\r\n                        I[i][j] = I[ii][j]; //replace i'th row by ii'th\r\n                        I[ii][j] = e; //repace ii'th by temp\r\n                    }\r\n                    //don't bother checking other rows since we've swapped\r\n                    break;\r\n                }\r\n            }\r\n            //get the new diagonal\r\n            e = C[i][i];\r\n            //if it's still 0, not invertable (error)\r\n            if (e === 0) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Scale this row down by e (so we have a 1 on the diagonal)\r\n        for (let j = 0; j < dim; j++) {\r\n            C[i][j] = C[i][j] / e; //apply to original matrix\r\n            I[i][j] = I[i][j] / e; //apply to identity\r\n        }\r\n\r\n        // Subtract this row (scaled appropriately for each row) from ALL of\r\n        // the other rows so that there will be 0's in this column in the\r\n        // rows above and below this one\r\n        for (let ii = 0; ii < dim; ii++) {\r\n            // Only apply to other rows (we want a 1 on the diagonal)\r\n            if (ii == i) {\r\n                continue;\r\n            }\r\n\r\n            // We want to change this element to 0\r\n            e = C[ii][i];\r\n\r\n            // Subtract (the row above(or below) scaled by e) from (the\r\n            // current row) but start at the i'th column and assume all the\r\n            // stuff left of diagonal is 0 (which it should be if we made this\r\n            // algorithm correctly)\r\n            for (let j = 0; j < dim; j++) {\r\n                C[ii][j] -= e * C[i][j]; //apply to original matrix\r\n                I[ii][j] -= e * I[i][j]; //apply to identity\r\n            }\r\n        }\r\n    }\r\n\r\n    //we've done all operations, C should be the identity\r\n    //matrix I should be the inverse:\r\n    return [\r\n        I[0][0], I[1][0],\r\n        I[0][1], I[1][1],\r\n        I[0][2], I[1][2]\r\n    ];\r\n}\r\n\r\nfunction multiplyMatrix(\r\n    [a1, b1, c1, d1, e1, f1], \r\n    [a2, b2, c2, d2, e2, f2]\r\n) {\r\n    const m1 = [\r\n        [a1, c1, e1],\r\n        [b1, d1, f1],\r\n        [0, 0, 1]\r\n    ];\r\n\r\n    const m2 = [\r\n        [a2, c2, e2],\r\n        [b2, d2, f2],\r\n        [0, 0, 1]\r\n    ];\r\n\r\n    const result = [];\r\n\r\n    for (let j = 0; j < m2.length; j++) {\r\n        result[j] = [];\r\n        for (let k = 0; k < m1[0].length; k++) {\r\n            let sum = 0;\r\n            for (let i = 0; i < m1.length; i++) {\r\n                sum += m1[i][k] * m2[j][i];\r\n            }\r\n            result[j].push(sum);\r\n        }\r\n    }\r\n\r\n    return [\r\n        result[0][0], result[1][0],\r\n        result[0][1], result[1][1],\r\n        result[0][2], result[1][2]\r\n    ];\r\n}\r\n\r\nfunction rotatedTopLeft(\r\n    x,\r\n    y,\r\n    width,\r\n    height,\r\n    rotationAngle,\r\n    revX,\r\n    revY,\r\n    doW,\r\n    doH\r\n) {\r\n    const hw = parseFloat(width) / 2,\r\n        hh = parseFloat(height) / 2;\r\n\r\n    const cx = x + hw,\r\n        cy = y + hh;\r\n\r\n    const dx = x - cx,\r\n        dy = y - cy;\r\n\r\n    const originalTopLeftAngle = Math.atan2(doW ? 0 : dy, doH ? 0 : dx);\r\n    const rotatedTopLeftAngle = originalTopLeftAngle + rotationAngle;\r\n\r\n    const radius = Math.sqrt(Math.pow(doH ? 0 : hw, 2) + Math.pow(doW ? 0 : hh, 2));\r\n\r\n    let cos = Math.cos(rotatedTopLeftAngle),\r\n        sin = Math.sin(rotatedTopLeftAngle);\r\n\r\n    cos = revX === true ? -cos : cos;\r\n    sin = revY === true ? -sin : sin;\r\n\r\n    const rx = cx + radius * cos,\r\n        ry = cy + radius * sin;\r\n\r\n    return {\r\n        left: floatToFixed(rx),\r\n        top: floatToFixed(ry)\r\n    };\r\n}\n\nconst MIN_SIZE = 2;\r\nconst CENTER_DELTA = 7;\r\n\r\nclass Draggable extends Transformable {\r\n\r\n    _init(el) {\r\n        const {\r\n            rotationPoint,\r\n            container,\r\n            resizable,\r\n            rotatable\r\n        } = this.options;\r\n\r\n        const {\r\n            left,\r\n            top,\r\n            width,\r\n            height\r\n        } = el.style;\r\n\r\n        const wrapper = document.createElement('div');\r\n        addClass(wrapper, 'sjx-wrapper');\r\n        container.appendChild(wrapper);\r\n\r\n        const $el = helper(el);\r\n\r\n        const w = width || $el.css('width'),\r\n            h = height || $el.css('height'),\r\n            t = top || $el.css('top'),\r\n            l = left || $el.css('left');\r\n\r\n        const css = {\r\n            top: t,\r\n            left: l,\r\n            width: w,\r\n            height: h,\r\n            transform: getTransform($el)\r\n        };\r\n\r\n        const controls = document.createElement('div');\r\n        addClass(controls, 'sjx-controls');\r\n\r\n        const resizingHandles = {\r\n            tl: ['sjx-hdl', 'sjx-hdl-t', 'sjx-hdl-l', 'sjx-hdl-tl'],\r\n            tr: ['sjx-hdl', 'sjx-hdl-t', 'sjx-hdl-r', 'sjx-hdl-tr'],\r\n            br: ['sjx-hdl', 'sjx-hdl-b', 'sjx-hdl-r', 'sjx-hdl-br'],\r\n            bl: ['sjx-hdl', 'sjx-hdl-b', 'sjx-hdl-l', 'sjx-hdl-bl'],\r\n            tc: ['sjx-hdl', 'sjx-hdl-t', 'sjx-hdl-c', 'sjx-hdl-tc'],\r\n            bc: ['sjx-hdl', 'sjx-hdl-b', 'sjx-hdl-c', 'sjx-hdl-bc'],\r\n            ml: ['sjx-hdl', 'sjx-hdl-m', 'sjx-hdl-l', 'sjx-hdl-ml'],\r\n            mr: ['sjx-hdl', 'sjx-hdl-m', 'sjx-hdl-r', 'sjx-hdl-mr']\r\n        };\r\n\r\n        const rotationHandles = {\r\n            normal: ['sjx-normal'],\r\n            rotator: ['sjx-hdl', 'sjx-hdl-m', 'sjx-rotator']\r\n        };\r\n\r\n        const handles = {\r\n            ...(rotatable && rotationHandles),\r\n            ...(resizable && resizingHandles),\r\n            center: rotationPoint && rotatable ? ['sjx-hdl', 'sjx-hdl-m', 'sjx-hdl-c', 'sjx-hdl-mc'] : undefined\r\n        };\r\n\r\n        Object.keys(handles).forEach(key => {\r\n            const data = handles[key];\r\n            if (isUndef(data)) return;\r\n            const handler = createHandler(data);\r\n            handles[key] = handler;\r\n            controls.appendChild(handler);\r\n        });\r\n\r\n        if (isDef(handles.center)) {\r\n            const cHandle = helper(handles.center);\r\n            cHandle.css({\r\n                left: `${el.getAttribute('data-cx')}px`,\r\n                top: `${el.getAttribute('data-cy')}px`\r\n            });\r\n        }\r\n\r\n        wrapper.appendChild(controls);\r\n\r\n        const $controls = helper(controls);\r\n        $controls.css(css);\r\n\r\n        this.storage = {\r\n            controls,\r\n            handles,\r\n            radius: undefined,\r\n            parent: el.parentNode\r\n        };\r\n\r\n        $controls\r\n            .on('mousedown', this._onMouseDown)\r\n            .on('touchstart', this._onTouchStart);\r\n    }\r\n\r\n    _destroy() {\r\n        const {\r\n            controls\r\n        } = this.storage;\r\n\r\n        helper(controls)\r\n            .off('mousedown', this._onMouseDown)\r\n            .off('touchstart', this._onTouchStart);\r\n\r\n        const wrapper = controls.parentNode;\r\n        wrapper.parentNode.removeChild(wrapper);\r\n    }\r\n\r\n    _pointToElement({ x, y }) {\r\n        const {\r\n            transform\r\n        } = this.storage;\r\n\r\n        const ctm = [...transform.matrix];\r\n        ctm[4] = ctm[5] = 0;\r\n\r\n        return this._applyMatrixToPoint(\r\n            matrixInvert(ctm),\r\n            x,\r\n            y\r\n        );\r\n    }\r\n\r\n    _pointToControls(data) {\r\n        return this._pointToElement(data);\r\n    }\r\n\r\n    _applyMatrixToPoint(matrix, x, y) {\r\n        return matrixTransform(\r\n            {\r\n                x,\r\n                y\r\n            },\r\n            matrix\r\n        );\r\n    }\r\n\r\n    _cursorPoint({ clientX, clientY }) {\r\n        const {\r\n            container\r\n        } = this.options;\r\n\r\n        const globalMatrix = parseMatrix(\r\n            getTransform(helper(container))\r\n        );\r\n\r\n        return matrixTransform(\r\n            {\r\n                x: clientX,\r\n                y: clientY\r\n            },\r\n            matrixInvert(\r\n                globalMatrix\r\n            )\r\n        );\r\n    }\r\n\r\n    _apply() {\r\n        const {\r\n            el,\r\n            storage\r\n        } = this;\r\n\r\n        const {\r\n            // cached,\r\n            controls,\r\n            // transform,\r\n            handles\r\n        } = storage;\r\n\r\n        const $controls = helper(controls);\r\n\r\n        const cw = parseFloat($controls.css('width')),\r\n            ch = parseFloat($controls.css('height'));\r\n\r\n        const hW = cw / 2,\r\n            hH = ch / 2;\r\n\r\n        const {\r\n            center: cHandle\r\n        } = handles;\r\n\r\n        const isDefCenter = isDef(cHandle);\r\n\r\n        const centerX = isDefCenter\r\n            ? parseFloat(helper(cHandle).css('left'))\r\n            : hW;\r\n        const centerY = isDefCenter\r\n            ? parseFloat(helper(cHandle).css('top'))\r\n            : hH;\r\n\r\n        el.setAttribute('data-cx', centerX);\r\n        el.setAttribute('data-cy', centerY);\r\n\r\n        // if (isUndef(cached)) return;\r\n\r\n        // const $el = helper(el);\r\n\r\n        // const { dx, dy } = cached;\r\n\r\n        // const css = matrixToCSS(transform.matrix);\r\n\r\n        // const left = parseFloat(\r\n        //     el.style.left || $el.css('left')\r\n        // );\r\n\r\n        // const top = parseFloat(\r\n        //     el.style.top || $el.css('top')\r\n        // );\r\n\r\n        // css.left = `${left + dx}px`;\r\n        // css.top = `${top + dy}px`;\r\n\r\n        // $el.css(css);\r\n        // $controls.css(css);\r\n\r\n        this.storage.cached = null;\r\n    }\r\n\r\n    _processResize(dx, dy) {\r\n        const {\r\n            el,\r\n            storage,\r\n            options: { proportions }\r\n        } = this;\r\n\r\n        const {\r\n            controls,\r\n            coords,\r\n            cw,\r\n            ch,\r\n            transform,\r\n            refang,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        } = storage;\r\n\r\n        const ratio = doW || (!doW && !doH)\r\n            ? (cw + dx) / cw\r\n            : (ch + dy) / ch;\r\n\r\n        const newWidth = proportions ? cw * ratio : cw + dx,\r\n            newHeight = proportions ? ch * ratio : ch + dy;\r\n\r\n        if (newWidth < MIN_SIZE || newHeight < MIN_SIZE) return;\r\n\r\n        const matrix = [...transform.matrix];\r\n\r\n        const newCoords = rotatedTopLeft(\r\n            matrix[4],\r\n            matrix[5],\r\n            newWidth,\r\n            newHeight,\r\n            refang,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        );\r\n\r\n        const nx = coords.left - newCoords.left,\r\n            ny = coords.top - newCoords.top;\r\n\r\n        matrix[4] += nx;\r\n        matrix[5] += ny;\r\n\r\n        const css = matrixToCSS(matrix);\r\n\r\n        css.width = `${newWidth}px`;\r\n        css.height = `${newHeight}px`;\r\n\r\n        helper(controls).css(css);\r\n        helper(el).css(css);\r\n\r\n        storage.cached = {\r\n            dx: nx,\r\n            dy: ny\r\n        };\r\n        \r\n        return {\r\n            width: newWidth,\r\n            height: newHeight,\r\n            ox: nx,\r\n            oy: ny\r\n        };\r\n    }\r\n\r\n    _processMove(dx, dy) {\r\n        const {\r\n            el,\r\n            storage\r\n        } = this;\r\n\r\n        const {\r\n            controls,\r\n            transform: {\r\n                matrix,\r\n                parentMatrix\r\n            }\r\n        } = storage;\r\n\r\n        const pctm = [...parentMatrix];\r\n        pctm[4] = pctm[5] = 0;\r\n\r\n        const nMatrix = [...matrix];\r\n\r\n        nMatrix[4] = matrix[4] + dx;\r\n        nMatrix[5] = matrix[5] + dy;\r\n\r\n        const css = matrixToCSS(nMatrix);\r\n\r\n        helper(controls).css(css);\r\n        helper(el).css(css);\r\n\r\n        storage.cached = {\r\n            dx,\r\n            dy\r\n        };\r\n\r\n        return nMatrix;\r\n    }\r\n\r\n    _processRotate(radians) {\r\n        const {\r\n            el,\r\n            storage: {\r\n                controls,\r\n                transform,\r\n                center\r\n            }\r\n        } = this;\r\n\r\n        const {\r\n            matrix,\r\n            parentMatrix\r\n        } = transform;\r\n\r\n        const cos = floatToFixed(Math.cos(radians), 4),\r\n            sin = floatToFixed(Math.sin(radians), 4);\r\n\r\n        const translateMatrix = [\r\n            1,\r\n            0,\r\n            0,\r\n            1,\r\n            center.cx,\r\n            center.cy\r\n        ];\r\n\r\n        const rotMatrix = [\r\n            cos,\r\n            sin,\r\n            -sin,\r\n            cos,\r\n            0,\r\n            0\r\n        ];\r\n\r\n        const pctm = [...parentMatrix];\r\n        pctm[4] = pctm[5] = 0;\r\n\r\n        const resRotMatrix = multiplyMatrix(\r\n            matrixInvert(pctm),\r\n            multiplyMatrix(rotMatrix, pctm)\r\n        );\r\n\r\n        const nMatrix = multiplyMatrix(\r\n            multiplyMatrix(translateMatrix, resRotMatrix),\r\n            matrixInvert(translateMatrix)\r\n        );\r\n\r\n        const resMatrix = multiplyMatrix(nMatrix, matrix);\r\n\r\n        const css = matrixToCSS(resMatrix);\r\n\r\n        helper(controls).css(css);\r\n        helper(el).css(css);\r\n\r\n        return resMatrix;\r\n    }\r\n\r\n    _getState(params) {\r\n        const {\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        } = params;\r\n\r\n        const factor = revX !== revY\r\n            ? -1\r\n            : 1;\r\n\r\n        const {\r\n            el,\r\n            storage: {\r\n                handles,\r\n                controls,\r\n                parent\r\n            },\r\n            options: { container }\r\n        } = this;\r\n\r\n        const {\r\n            center: cHandle\r\n        } = handles;\r\n\r\n        const $controls = helper(controls);\r\n\r\n        const containerMatrix = parseMatrix(\r\n            getTransform(helper(container))\r\n        );\r\n\r\n        const matrix = parseMatrix(\r\n            getTransform(helper(controls))\r\n        );\r\n\r\n        const pMatrix = parseMatrix(\r\n            getTransform(helper(parent))\r\n        );\r\n\r\n        const refang = Math.atan2(\r\n            matrix[1], matrix[0]\r\n        ) * factor;\r\n\r\n        const parentMatrix = parent !== container\r\n            ? multiplyMatrix(\r\n                pMatrix,\r\n                containerMatrix\r\n            )\r\n            : containerMatrix;\r\n\r\n        const transform = {\r\n            matrix,\r\n            parentMatrix,\r\n            scX: Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]),\r\n            scY: Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3])\r\n        };\r\n\r\n        const cw = parseFloat($controls.css('width')),\r\n            ch = parseFloat($controls.css('height'));\r\n\r\n        // getting current coordinates considering rotation angle                                                                                                  \r\n        const coords = rotatedTopLeft(\r\n            matrix[4],\r\n            matrix[5],\r\n            cw,\r\n            ch,\r\n            refang,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        );\r\n\r\n        const hW = cw / 2,\r\n            hH = ch / 2;\r\n\r\n        const offset_ = getOffset(el),\r\n            isDefCenter = isDef(cHandle);\r\n\r\n        const centerX = isDefCenter\r\n            ? parseFloat(helper(cHandle).css('left'))\r\n            : hW;\r\n        const centerY = isDefCenter\r\n            ? parseFloat(helper(cHandle).css('top'))\r\n            : hH;\r\n\r\n        const cDelta = isDefCenter ? CENTER_DELTA : 0;\r\n\r\n        const { x: el_x, y: el_y } = matrixTransform(\r\n            {\r\n                x: offset_.left,\r\n                y: offset_.top\r\n            },\r\n            matrixInvert(parentMatrix)\r\n        );\r\n\r\n        return {\r\n            transform,\r\n            cw,\r\n            ch,\r\n            coords,\r\n            center: {\r\n                x: el_x + centerX - cDelta,\r\n                y: el_y + centerY - cDelta,\r\n                cx: -centerX + hW - cDelta,\r\n                cy: -centerY + hH - cDelta,\r\n                hx: centerX,\r\n                hy: centerY\r\n            },\r\n            factor,\r\n            refang,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        };\r\n    }\r\n\r\n    _moveCenterHandle(x, y) {\r\n        const { \r\n            handles: { center }, \r\n            center: { hx, hy }\r\n        } = this.storage;\r\n\r\n        const left = `${hx + x}px`,\r\n            top = `${hy + y}px`;\r\n\r\n        helper(center).css(\r\n            {\r\n                left,\r\n                top\r\n            }\r\n        );\r\n    }\r\n\r\n    resetCenterPoint() {\r\n        const {\r\n            handles: { center }\r\n        } = this.storage;\r\n\r\n        helper(center).css(\r\n            {\r\n                left: null,\r\n                top: null\r\n            }\r\n        );\r\n    }\r\n\r\n    fitControlsToSize() {}\r\n\r\n    get controls() {\r\n        return this.storage.controls;\r\n    }\r\n\r\n}\r\n\r\nfunction createHandler(classList) {\r\n    const element = document.createElement('div');\r\n    classList.forEach(cls => {\r\n        addClass(element, cls);\r\n    });\r\n    return element;\r\n}\n\nconst svgPoint = createSVGElement('svg').createSVGPoint();\r\nconst floatRE = /[+-]?\\d+(\\.\\d+)?/g;\r\n\r\nconst ALLOWED_ELEMENTS = [\r\n    'circle', 'ellipse',\r\n    'image', 'line',\r\n    'path', 'polygon',\r\n    'polyline', 'rect',\r\n    'text', 'g'\r\n];\r\n\r\nfunction checkChildElements(element) {\r\n    const arrOfElements = [];\r\n\r\n    if (isGroup(element)) {\r\n        forEach.call(element.childNodes, item => {\r\n            if (item.nodeType === 1) {\r\n                const tagName = item.tagName.toLowerCase();\r\n\r\n                if (ALLOWED_ELEMENTS.indexOf(tagName) !== -1) {\r\n                    if (tagName === 'g') {\r\n                        arrOfElements.push(...checkChildElements(item));\r\n                    }\r\n                    arrOfElements.push(item);\r\n                }\r\n            }\r\n        });\r\n    } else {\r\n        arrOfElements.push(element);\r\n    }\r\n\r\n    return arrOfElements;\r\n}\r\n\r\nfunction createSVGElement(name) {\r\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\r\n}\r\n\r\nfunction createSVGMatrix() {\r\n    return createSVGElement('svg').createSVGMatrix();\r\n}\r\n\r\nfunction getTransformToElement(toElement, g) {\r\n    const gTransform = g.getScreenCTM() || createSVGMatrix();\r\n    return gTransform.inverse().multiply(\r\n        toElement.getScreenCTM() || createSVGMatrix()\r\n    );\r\n}\r\n\r\nfunction matrixToString(m) {\r\n    const { a, b, c, d, e, f } = m;\r\n    return `matrix(${a},${b},${c},${d},${e},${f})`;\r\n}\r\n\r\nfunction pointTo(ctm, x, y) {\r\n    svgPoint.x = x;\r\n    svgPoint.y = y;\r\n    return svgPoint.matrixTransform(ctm);\r\n}\r\n\r\nfunction cloneMatrix(b) {\r\n    const a = createSVGMatrix();\r\n\r\n    a.a = b.a;\r\n    a.b = b.b;\r\n    a.c = b.c;\r\n    a.d = b.d;\r\n    a.e = b.e;\r\n    a.f = b.f;\r\n\r\n    return a;\r\n}\r\n\r\nfunction checkElement(el) {\r\n    const tagName = el.tagName.toLowerCase();\r\n\r\n    if (ALLOWED_ELEMENTS.indexOf(tagName) === -1) {\r\n        warn(\r\n            'Selected element is not allowed to transform. Allowed elements:\\n' +\r\n            'circle, ellipse, image, line, path, polygon, polyline, rect, text, g'\r\n        );\r\n        return false;\r\n    } else {\r\n        return true;\r\n    }\r\n}\r\n\r\nfunction isIdentity(matrix) {\r\n    const { a, b, c, d, e, f } = matrix;\r\n    return a === 1 &&\r\n        b === 0 &&\r\n        c === 0 &&\r\n        d === 1 &&\r\n        e === 0 &&\r\n        f === 0;\r\n}\r\n\r\nfunction createPoint(svg, x, y) {\r\n    if (isUndef(x) || isUndef(y)) {\r\n        return null;\r\n    }\r\n    const pt = svg.createSVGPoint();\r\n    pt.x = x;\r\n    pt.y = y;\r\n    return pt;\r\n}\r\n\r\nfunction isGroup(element) {\r\n    return element.tagName.toLowerCase() === 'g';\r\n}\r\n\r\nfunction parsePoints(pts) {\r\n    return pts.match(floatRE).reduce(\r\n        (result, value, index, array) => {\r\n            if (index % 2 === 0) {\r\n                result.push(array.slice(index, index + 2));\r\n            }\r\n            return result;\r\n        },\r\n        []\r\n    );\r\n}\n\nconst dRE = /\\s*([achlmqstvz])([^achlmqstvz]*)\\s*/gi;\r\nconst sepRE = /\\s*,\\s*|\\s+/g;\r\n\r\nfunction parsePath(path) {\r\n    let match = dRE.lastIndex = 0;\r\n\r\n    const serialized = [];\r\n\r\n    while ((match = dRE.exec(path))) {\r\n        const cmd = match[1];\r\n        const upCmd = cmd.toUpperCase();\r\n\r\n        // normalize the data\r\n        const data = match[2]\r\n            .replace(/([^e])-/g, '$1 -')\r\n            .replace(/ +/g, ' ');\r\n\r\n        serialized.push({\r\n            relative: cmd !== upCmd,\r\n            key: upCmd,\r\n            cmd: cmd,\r\n            values: data.trim().split(sepRE).map(val => {\r\n                if (!isNaN(val)) {\r\n                    return Number(val);\r\n                }\r\n            })\r\n        });\r\n    }\r\n\r\n    return serialized;\r\n}\r\n\r\nfunction movePath(params) {\r\n    const {\r\n        path,\r\n        dx,\r\n        dy\r\n    } = params;\r\n\r\n    try {\r\n        const serialized = parsePath(path);\r\n\r\n        let str = '';\r\n        let space = ' ';\r\n\r\n        let firstCommand = true;\r\n\r\n        for (let i = 0, len = serialized.length; i < len; i++) {\r\n            const item = serialized[i];\r\n\r\n            const {\r\n                values,\r\n                key: cmd,\r\n                relative\r\n            } = item;\r\n\r\n            const coordinates = [];\r\n\r\n            switch (cmd) {\r\n\r\n                case 'M': {\r\n                    for (let k = 0, len = values.length; k < len; k += 2) {\r\n                        let [x, y] = values.slice(k, k + 2);\r\n\r\n                        if (!(relative && !firstCommand)) {\r\n                            x += dx;\r\n                            y += dy;\r\n                        }\r\n\r\n                        coordinates.push(\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        firstCommand = false;\r\n                    }\r\n                    break;\r\n                }              \r\n                case 'A': {\r\n                    for (let k = 0, len = values.length; k < len; k += 7) {\r\n                        const set = values.slice(k, k + 7);\r\n\r\n                        if (!relative) {\r\n                            set[5] += dx;\r\n                            set[6] += dy;\r\n                        }\r\n\r\n                        coordinates.push(...set);\r\n                    }\r\n                    break;\r\n                }\r\n                case 'C': {\r\n                    for (let k = 0, len = values.length; k < len; k += 6) {\r\n                        const set = values.slice(k, k + 6);\r\n\r\n                        if (!relative) {\r\n                            set[0] += dx;\r\n                            set[1] += dy;\r\n                            set[2] += dx;\r\n                            set[3] += dy;\r\n                            set[4] += dx;\r\n                            set[5] += dy;\r\n                        }\r\n\r\n                        coordinates.push(...set);\r\n                    }\r\n                    break;\r\n                }\r\n                case 'H': {\r\n                    for (let k = 0, len = values.length; k < len; k += 1) {\r\n                        const set = values.slice(k, k + 1);\r\n\r\n                        if (!relative) {\r\n                            set[0] += dx;\r\n                        }\r\n\r\n                        coordinates.push(set[0]);\r\n                    }\r\n\r\n                    break;\r\n                }\r\n                case 'V': {\r\n                    for (let k = 0, len = values.length; k < len; k += 1) {\r\n                        const set = values.slice(k, k + 1);\r\n\r\n                        if (!relative) {\r\n                            set[0] += dy;\r\n                        }\r\n                        coordinates.push(set[0]);\r\n                    }\r\n\r\n                    break;\r\n                }\r\n                case 'L':\r\n                case 'T': {\r\n                    for (let k = 0, len = values.length; k < len; k += 2) {\r\n                        let [x, y] = values.slice(k, k + 2);\r\n\r\n                        if (!relative) {\r\n                            x += dx;\r\n                            y += dy;\r\n                        }\r\n\r\n                        coordinates.push(\r\n                            x,\r\n                            y\r\n                        );\r\n                    }\r\n                    break;\r\n                }\r\n                case 'Q':\r\n                case 'S': {\r\n                    for (let k = 0, len = values.length; k < len; k += 4) {\r\n                        let [x1, y1, x2, y2] = values.slice(k, k + 4);\r\n\r\n                        if (!relative) {\r\n                            x1 += dx;\r\n                            y1 += dy;\r\n                            x2 += dx;\r\n                            y2 += dy;\r\n                        }\r\n\r\n                        coordinates.push(\r\n                            x1,\r\n                            y1,\r\n                            x2,\r\n                            y2\r\n                        );\r\n                    }\r\n                    break;\r\n                }\r\n                case 'Z': {\r\n                    values[0] = '';\r\n                    space = '';\r\n                    break;\r\n                }\r\n\r\n            }\r\n\r\n            str += item.cmd + coordinates.join(',') + space;\r\n        }\r\n\r\n        return str;\r\n    } catch (err) {\r\n        warn('Path parsing error: ' + err);\r\n    }\r\n}\r\n\r\nfunction resizePath(params) {\r\n    const {\r\n        path,\r\n        localCTM\r\n    } = params;\r\n\r\n    try {\r\n        const serialized = parsePath(path);\r\n\r\n        let str = '';\r\n        let space = ' ';\r\n\r\n        const res = [];\r\n\r\n        let firstCommand = true;\r\n\r\n        for (let i = 0, len = serialized.length; i < len; i++) {\r\n            const item = serialized[i];\r\n\r\n            const {\r\n                values,\r\n                key: cmd,\r\n                relative\r\n            } = item;\r\n\r\n            switch (cmd) {\r\n\r\n                case 'A': {\r\n                //A rx ry x-axis-rotation large-arc-flag sweep-flag x y\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 7) {\r\n                        const [rx, ry, x_axis_rot, large_arc_flag, sweep_flag, x, y] =\r\n                            values.slice(k, k + 7);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n\r\n                        mtrx.e = mtrx.f = 0;\r\n\r\n                        const {\r\n                            x: newRx,\r\n                            y: newRy\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            rx,\r\n                            ry\r\n                        );\r\n\r\n                        coordinates.unshift(\r\n                            floatToFixed(newRx),\r\n                            floatToFixed(newRy),\r\n                            x_axis_rot,\r\n                            large_arc_flag,\r\n                            sweep_flag\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'C': {\r\n                //C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 6) {\r\n                        const [x1, y1, x2, y2, x, y] = values.slice(k, k + 6);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX1,\r\n                            y: resY1\r\n                        } = pointTo(\r\n                            mtrx,                          \r\n                            x1,\r\n                            y1\r\n                        );\r\n\r\n                        const {\r\n                            x: resX2,\r\n                            y: resY2\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x2,\r\n                            y2\r\n                        );\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX1),\r\n                            floatToFixed(resY1),\r\n                            floatToFixed(resX2),\r\n                            floatToFixed(resY2),\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                // this command makes impossible free transform within group\r\n                // todo: use proportional resizing only or need to be converted to L\r\n                case 'H': {\r\n                // H x (or h dx)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 1) {\r\n                        const [x] = values.slice(k, k + 1);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            0\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                // this command makes impossible free transform within group\r\n                // todo: use proportional resizing only or need to be converted to L\r\n                case 'V': {\r\n                // V y (or v dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 1) {\r\n                        const [y] = values.slice(k, k + 1);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            0,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resY)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'T':\r\n                case 'L': {\r\n                // T x y (or t dx dy)\r\n                // L x y (or l dx dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 2) {\r\n                        const [x, y] = values.slice(k, k + 2);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'M': {\r\n                // M x y (or dx dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 2) {\r\n                        const [x, y] = values.slice(k, k + 2);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative && !firstCommand) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n\r\n                        firstCommand = false;\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'Q': {\r\n                //Q x1 y1, x y (or q dx1 dy1, dx dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 4) {\r\n                        const [x1, y1, x, y] = values.slice(k, k + 4);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX1,\r\n                            y: resY1\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x1,\r\n                            y1\r\n                        );\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX1),\r\n                            floatToFixed(resY1),\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'S': {\r\n                //S x2 y2, x y (or s dx2 dy2, dx dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 4) {\r\n                        const [x2, y2, x, y] = values.slice(k, k + 4);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX2,\r\n                            y: resY2\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x2,\r\n                            y2\r\n                        );\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX2),\r\n                            floatToFixed(resY2),\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'Z': {\r\n                    res.push(['']);\r\n                    space = '';\r\n                    break;\r\n                }\r\n\r\n            }\r\n\r\n            str += item.cmd + res[i].join(',') + space;\r\n        }\r\n\r\n        return str;\r\n    } catch (err) {\r\n        warn('Path parsing error: ' + err);\r\n    }\r\n}\n\nconst MIN_SIZE$1 = 5;\r\nconst ROT_OFFSET = 50;\r\n\r\nclass DraggableSVG extends Transformable {\r\n\r\n    _init(el) {\r\n        const {\r\n            rotationPoint,\r\n            container,\r\n            themeColor,\r\n            resizable,\r\n            rotatable\r\n        } = this.options;\r\n\r\n        const wrapper = createSVGElement('g');\r\n        addClass(wrapper, 'sjx-svg-wrapper');\r\n        container.appendChild(wrapper);\r\n\r\n        const {\r\n            width: cw,\r\n            height: ch,\r\n            x: cx,\r\n            y: cy\r\n        } = el.getBBox();\r\n\r\n        const elCTM = getTransformToElement(el, container);\r\n        const box = createSVGElement('rect');\r\n\r\n        const attrs = [\r\n            ['width', cw],\r\n            ['height', ch],\r\n            ['x', cx],\r\n            ['y', cy],\r\n            ['fill', themeColor],\r\n            ['fill-opacity', 0.1],\r\n            ['stroke', themeColor],\r\n            ['stroke-dasharray', '3 3'],\r\n            ['vector-effect', 'non-scaling-stroke'],\r\n            ['transform', matrixToString(elCTM)]\r\n        ];\r\n\r\n        attrs.forEach(([key, value]) => {\r\n            box.setAttribute(key, value);\r\n        });\r\n\r\n        const handlesGroup = createSVGElement('g'),\r\n            normalLineGroup = createSVGElement('g'),\r\n            group = createSVGElement('g');\r\n\r\n        addClass(group, 'sjx-svg-box-group');\r\n        addClass(handlesGroup, 'sjx-svg-handles');\r\n        addClass(normalLineGroup, 'sjx-svg-normal-group');\r\n\r\n        group.appendChild(box);\r\n        wrapper.appendChild(group);\r\n        wrapper.appendChild(normalLineGroup);\r\n        wrapper.appendChild(handlesGroup);\r\n\r\n        const {\r\n            x: bX,\r\n            y: bY,\r\n            width: bW,\r\n            height: bH\r\n        } = box.getBBox();\r\n\r\n        const centerX = el.getAttribute('data-cx'),\r\n            centerY = el.getAttribute('data-cy');\r\n\r\n        const boxCTM = getTransformToElement(box, box.parentNode),\r\n            boxCenter = pointTo(boxCTM, bX + bW / 2, bY + bH / 2),\r\n            boxTL = pointTo(boxCTM, bX, bY),\r\n            boxTR = pointTo(boxCTM, bX + bW, bY),\r\n            boxMR = pointTo(boxCTM, bX + bW, bY + bH / 2);\r\n\r\n        const resizingHandles = {\r\n            tl: boxTL,\r\n            tr: boxTR,\r\n            br: pointTo(boxCTM, bX + bW, bY + bH),\r\n            bl: pointTo(boxCTM, bX, bY + bH),\r\n            tc: pointTo(boxCTM, bX + bW / 2, bY),\r\n            bc: pointTo(boxCTM, bX + bW / 2, bY + bH),\r\n            ml: pointTo(boxCTM, bX, bY + bH / 2),\r\n            mr: boxMR\r\n        };\r\n\r\n        let rotationHandles = {},\r\n            rotator = null;\r\n\r\n        if (rotatable) {\r\n            const theta = Math.atan2(\r\n                boxTL.y - boxTR.y,\r\n                boxTL.x - boxTR.x\r\n            );\r\n\r\n            rotator = {\r\n                x: boxMR.x - ROT_OFFSET * Math.cos(theta),\r\n                y: boxMR.y - ROT_OFFSET * Math.sin(theta)\r\n            }; \r\n\r\n            const normalLine = createSVGElement('line');\r\n\r\n            normalLine.x1.baseVal.value = boxMR.x;\r\n            normalLine.y1.baseVal.value = boxMR.y;\r\n            normalLine.x2.baseVal.value = rotator.x;\r\n            normalLine.y2.baseVal.value = rotator.y;\r\n\r\n            setLineStyle(normalLine, themeColor);\r\n            normalLineGroup.appendChild(normalLine);\r\n\r\n            let radius = null;\r\n\r\n            if (rotationPoint) {\r\n                radius = createSVGElement('line');\r\n\r\n                addClass(radius, 'sjx-hidden');\r\n\r\n                radius.x1.baseVal.value = boxCenter.x;\r\n                radius.y1.baseVal.value = boxCenter.y;\r\n                radius.x2.baseVal.value = centerX || boxCenter.x;\r\n                radius.y2.baseVal.value = centerY || boxCenter.y;\r\n\r\n                setLineStyle(radius, '#fe3232');\r\n                radius.setAttribute('opacity', 0.5);\r\n\r\n                normalLineGroup.appendChild(radius);\r\n            }\r\n\r\n            rotationHandles = {\r\n                normal: normalLine,\r\n                radius\r\n            };\r\n        }\r\n\r\n        const handles = {\r\n            ...(resizable && resizingHandles),\r\n            rotator,\r\n            center: rotationPoint && rotatable ? createPoint(container, centerX, centerY) || boxCenter : undefined\r\n        };\r\n\r\n        Object.keys(handles).forEach(key => {\r\n            const data = handles[key];\r\n            if (isUndef(data)) return;\r\n            const { x, y } = data;\r\n            const color = key === 'center'\r\n                ? '#fe3232'\r\n                : themeColor;\r\n\r\n            handles[key] = createHandler$1(\r\n                x,\r\n                y,\r\n                color,\r\n                key\r\n            );\r\n            handlesGroup.appendChild(handles[key]);\r\n        });\r\n\r\n        this.storage = {\r\n            wrapper,\r\n            box,\r\n            handles: {\r\n                ...handles,\r\n                ...rotationHandles\r\n            },\r\n            parent: el.parentNode,\r\n            center: {}\r\n        };\r\n\r\n        helper(wrapper)\r\n            .on('mousedown', this._onMouseDown)\r\n            .on('touchstart', this._onTouchStart);\r\n    }\r\n\r\n    _destroy() {\r\n        const {\r\n            wrapper\r\n        } = this.storage;\r\n\r\n        helper(wrapper)\r\n            .off('mousedown', this._onMouseDown)\r\n            .off('touchstart', this._onTouchStart);\r\n\r\n        wrapper.parentNode.removeChild(wrapper);\r\n    }\r\n\r\n    _cursorPoint({ clientX, clientY }) {\r\n        const {\r\n            container\r\n        } = this.options;\r\n\r\n        return pointTo(\r\n            container.getScreenCTM().inverse(),\r\n            clientX,\r\n            clientY\r\n        );\r\n    }\r\n\r\n    _pointToElement({ x, y }) {\r\n        const {\r\n            transform\r\n        } = this.storage;\r\n\r\n        const { ctm } = transform;\r\n        const matrix = ctm.inverse();\r\n\r\n        matrix.e = matrix.f = 0;\r\n\r\n        return this._applyMatrixToPoint(\r\n            matrix,\r\n            x,\r\n            y\r\n        );\r\n    }\r\n\r\n    _pointToControls({ x, y }) {\r\n        const {\r\n            transform\r\n        } = this.storage;\r\n\r\n        const { boxCTM } = transform;\r\n        const matrix = boxCTM.inverse();\r\n\r\n        matrix.e = matrix.f = 0;\r\n\r\n        return this._applyMatrixToPoint(\r\n            matrix,\r\n            x,\r\n            y\r\n        );\r\n    }\r\n\r\n    _applyMatrixToPoint(matrix, x, y) {\r\n        const {\r\n            container\r\n        } = this.options;\r\n\r\n        const pt = container.createSVGPoint();\r\n        pt.x = x;\r\n        pt.y = y;\r\n        return pt.matrixTransform(matrix);\r\n    }\r\n\r\n    _apply(actionName) {\r\n        const {\r\n            el: element,\r\n            storage,\r\n            options: { container }\r\n        } = this;\r\n\r\n        const {\r\n            box,\r\n            handles,\r\n            cached,\r\n            transform \r\n        } = storage;\r\n\r\n        const {\r\n            matrix,\r\n            boxCTM,\r\n            bBox,\r\n            ctm\r\n        } = transform;\r\n\r\n        const eBBox = element.getBBox();\r\n\r\n        const {\r\n            x: elX,\r\n            y: elY,\r\n            width: elW,\r\n            height: elH\r\n        } = eBBox;\r\n\r\n        const rotationPoint = isDef(handles.center)\r\n            ? pointTo(\r\n                boxCTM,\r\n                handles.center.cx.baseVal.value,\r\n                handles.center.cy.baseVal.value\r\n            )\r\n            : pointTo(\r\n                matrix,\r\n                elX + elW / 2,\r\n                elY + elH / 2\r\n            );\r\n\r\n        element.setAttribute('data-cx', rotationPoint.x);\r\n        element.setAttribute('data-cy', rotationPoint.y);\r\n\r\n        if (isUndef(cached)) return;\r\n\r\n        const {\r\n            scaleX,\r\n            scaleY,\r\n            dx,\r\n            dy,\r\n            ox,\r\n            oy\r\n        } = cached;\r\n\r\n        if (actionName === 'drag') {\r\n            if (dx === 0 && dy === 0) return;\r\n\r\n            const eM = createSVGMatrix();\r\n\r\n            eM.e = dx;\r\n            eM.f = dy;\r\n\r\n            const translateMatrix = eM.multiply(matrix)\r\n                .multiply(eM.inverse());\r\n\r\n            element.setAttribute(\r\n                'transform',\r\n                matrixToString(translateMatrix)\r\n            );\r\n\r\n            if (isGroup(element)) {\r\n                const els = checkChildElements(element);\r\n\r\n                els.forEach(child => {\r\n                    const pt = container.createSVGPoint();\r\n                    const ctm = getTransformToElement(element.parentNode, container).inverse();\r\n                    pt.x = ox;\r\n                    pt.y = oy;\r\n                    ctm.e = ctm.f = 0;\r\n                    const newPT = pt.matrixTransform(ctm);\r\n\r\n                    const eM = createSVGMatrix();\r\n\r\n                    eM.e = dx;\r\n                    eM.f = dy;\r\n\r\n                    const translateMatrix = eM.multiply(\r\n                        getTransformToElement(child, child.parentNode)\r\n                    ).multiply(eM.inverse());\r\n\r\n                    if (!isIdentity(translateMatrix)) {\r\n                        child.setAttribute(\r\n                            'transform',\r\n                            matrixToString(translateMatrix)\r\n                        );\r\n                    }\r\n\r\n                    if (!isGroup(child)) {\r\n                        applyTranslate(child, {\r\n                            x: newPT.x,\r\n                            y: newPT.y\r\n                        });\r\n                    }\r\n                });\r\n            } else {\r\n                applyTranslate(element, {\r\n                    x: dx,\r\n                    y: dy\r\n                });\r\n            }\r\n        }\r\n\r\n        if (actionName === 'resize') {\r\n            const {\r\n                x,\r\n                y,\r\n                width: newWidth,\r\n                height: newHeight\r\n            } = box.getBBox();\r\n\r\n            applyTransformToHandles(\r\n                storage,\r\n                {\r\n                    x,\r\n                    y,\r\n                    width: newWidth,\r\n                    height: newHeight,\r\n                    boxMatrix: null\r\n                }\r\n            );\r\n\r\n            if (isGroup(element)) {\r\n                const els = checkChildElements(element);\r\n\r\n                els.forEach(child => {\r\n                    if (!isGroup(child)) {\r\n                        applyResize(child, {\r\n                            scaleX,\r\n                            scaleY,\r\n                            defaultCTM: child.__ctm__,\r\n                            bBox: bBox,\r\n                            container,\r\n                            storage\r\n                        });\r\n                    }\r\n                });\r\n            } else {\r\n                applyResize(element, {\r\n                    scaleX,\r\n                    scaleY,\r\n                    defaultCTM: ctm,\r\n                    bBox: bBox,\r\n                    container,\r\n                    storage\r\n                });\r\n            }\r\n\r\n            element.setAttribute(\r\n                'transform',\r\n                matrixToString(matrix)\r\n            );\r\n        }\r\n\r\n        this.storage.cached = null;\r\n    }\r\n\r\n    _processResize(dx, dy) {\r\n        const {\r\n            el,\r\n            storage,\r\n            options: { proportions }\r\n        } = this;\r\n\r\n        const {\r\n            left,\r\n            top,\r\n            cw,\r\n            ch,\r\n            transform,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        } = storage;\r\n\r\n        const {\r\n            matrix,\r\n            scMatrix,\r\n            trMatrix,\r\n            scaleX: ptX,\r\n            scaleY: ptY\r\n        } = transform;\r\n\r\n        let {\r\n            width: newWidth,\r\n            height: newHeight\r\n        } = el.getBBox(); //box\r\n\r\n        const ratio = doW || (!doW && !doH)\r\n            ? (cw + dx) / cw\r\n            : (ch + dy) / ch;\r\n\r\n        newWidth = proportions ? cw * ratio : cw + dx;\r\n        newHeight = proportions ? ch * ratio : ch + dy;\r\n\r\n        if (Math.abs(newWidth) < MIN_SIZE$1 || Math.abs(newHeight) < MIN_SIZE$1) return;\r\n\r\n        const scaleX = newWidth / cw,\r\n            scaleY = newHeight / ch;\r\n\r\n        // setup scale matrix\r\n        scMatrix.a = scaleX;\r\n        scMatrix.b = 0;\r\n        scMatrix.c = 0;\r\n        scMatrix.d = scaleY;\r\n        scMatrix.e = 0;\r\n        scMatrix.f = 0;\r\n\r\n        // translate compensation matrix\r\n        trMatrix.e = ptX;\r\n        trMatrix.f = ptY;\r\n\r\n        //now must to do: translate(x y) scale(sx sy) translate(-x -y)\r\n        const scaleMatrix = trMatrix\r\n            .multiply(scMatrix)\r\n            .multiply(trMatrix.inverse());\r\n\r\n        const res = matrix.multiply(scaleMatrix);\r\n\r\n        el.setAttribute(\r\n            'transform',\r\n            matrixToString(res)\r\n        );\r\n\r\n        const deltaW = newWidth - cw,\r\n            deltaH = newHeight - ch;\r\n\r\n        const newX = left - deltaW * (doH ? 0.5 : (revX ? 1 : 0)),\r\n            newY = top - deltaH * (doW ? 0.5 : (revY ? 1 : 0));\r\n\r\n        this.storage.cached = {\r\n            scaleX,\r\n            scaleY\r\n        };\r\n\r\n        const finalValues = {\r\n            x: newX,\r\n            y: newY,\r\n            width: newWidth,\r\n            height: newHeight\r\n        };\r\n\r\n        applyTransformToHandles(\r\n            storage,\r\n            {\r\n                ...finalValues,\r\n                boxMatrix: null\r\n            }\r\n        );\r\n\r\n        return finalValues;\r\n    }\r\n\r\n    _processMove(dx, dy) {\r\n        const {\r\n            transform,\r\n            wrapper,\r\n            center\r\n        } = this.storage;\r\n\r\n        const {\r\n            matrix,\r\n            trMatrix,\r\n            scMatrix,\r\n            wrapperMatrix,\r\n            parentMatrix\r\n        } = transform;\r\n\r\n        scMatrix.e = dx;\r\n        scMatrix.f = dy;\r\n\r\n        const moveWrapperMtrx = scMatrix.multiply(wrapperMatrix);\r\n\r\n        wrapper.setAttribute(\r\n            'transform',\r\n            matrixToString(moveWrapperMtrx)\r\n        );\r\n\r\n        parentMatrix.e = parentMatrix.f = 0;\r\n        const { x, y } = pointTo(\r\n            parentMatrix.inverse(),\r\n            dx,\r\n            dy\r\n        );\r\n\r\n        trMatrix.e = x;\r\n        trMatrix.f = y;\r\n\r\n        const moveElementMtrx = trMatrix.multiply(matrix);\r\n\r\n        this.el.setAttribute(\r\n            'transform',\r\n            matrixToString(moveElementMtrx)\r\n        );\r\n\r\n        this.storage.cached = {\r\n            dx: x,\r\n            dy: y,\r\n            ox: dx,\r\n            oy: dy\r\n        };\r\n\r\n        if (center.isShifted) {\r\n            const radiusMatrix = wrapperMatrix.inverse();\r\n            radiusMatrix.e = radiusMatrix.f = 0;\r\n            const { x: nx, y: ny } = pointTo(\r\n                radiusMatrix,\r\n                dx,\r\n                dy\r\n            );\r\n\r\n            this._moveCenterHandle(-nx, -ny);\r\n        }\r\n\r\n        return moveElementMtrx;\r\n    }\r\n\r\n    _processRotate(radians) {\r\n        const {\r\n            center,\r\n            transform,\r\n            wrapper\r\n        } = this.storage;\r\n\r\n        const {\r\n            matrix,\r\n            wrapperMatrix,\r\n            parentMatrix,\r\n            trMatrix,\r\n            scMatrix,\r\n            rotMatrix\r\n        } = transform;\r\n\r\n        const cos = floatToFixed(Math.cos(radians)),\r\n            sin = floatToFixed(Math.sin(radians));\r\n\r\n        // rotate(a cx cy) is equivalent to translate(cx cy) rotate(a) translate(-cx -cy)\r\n        trMatrix.e = center.x;\r\n        trMatrix.f = center.y;\r\n\r\n        rotMatrix.a = cos;\r\n        rotMatrix.b = sin;\r\n        rotMatrix.c = - sin;\r\n        rotMatrix.d = cos;\r\n\r\n        const wrapMatrix = trMatrix.multiply(rotMatrix)\r\n            .multiply(trMatrix.inverse())\r\n            .multiply(wrapperMatrix);\r\n\r\n        wrapper.setAttribute(\r\n            'transform',\r\n            matrixToString(wrapMatrix)\r\n        );\r\n\r\n        scMatrix.e = center.el_x;\r\n        scMatrix.f = center.el_y;\r\n\r\n        parentMatrix.e = parentMatrix.f = 0;\r\n        const resRotMatrix = parentMatrix.inverse()\r\n            .multiply(rotMatrix)\r\n            .multiply(parentMatrix);\r\n\r\n        const rotateMatrix = scMatrix.multiply(resRotMatrix)\r\n            .multiply(scMatrix.inverse());\r\n\r\n        const elMatrix = rotateMatrix.multiply(matrix);\r\n\r\n        this.el.setAttribute(\r\n            'transform',\r\n            matrixToString(elMatrix)\r\n        );\r\n\r\n        return elMatrix;\r\n    }\r\n\r\n    _getState({ revX, revY, doW, doH }) {\r\n        const {\r\n            el: element,\r\n            storage,\r\n            options: { container }\r\n        } = this;\r\n\r\n        const {\r\n            box,\r\n            wrapper,\r\n            parent,\r\n            handles: { center: cHandle }\r\n        } = storage;\r\n\r\n        const eBBox = element.getBBox();\r\n\r\n        const {\r\n            x: el_x,\r\n            y: el_y,\r\n            width: el_w,\r\n            height: el_h\r\n        } = eBBox;\r\n\r\n        const {\r\n            width: cw,\r\n            height: ch,\r\n            x: c_left,\r\n            y: c_top\r\n        } = box.getBBox();\r\n\r\n        const elMatrix = getTransformToElement(element, parent),\r\n            ctm = getTransformToElement(element, container),\r\n            boxCTM = getTransformToElement(box.parentNode, container);\r\n\r\n        const parentMatrix = getTransformToElement(parent, container);\r\n\r\n        const scaleX = el_x + el_w * (doH ? 0.5 : revX ? 1 : 0),\r\n            scaleY = el_y + el_h * (doW ? 0.5 : revY ? 1 : 0);\r\n\r\n        const transform = {\r\n            matrix: elMatrix,\r\n            ctm,\r\n            boxCTM,\r\n            parentMatrix,\r\n            wrapperMatrix: getTransformToElement(wrapper, wrapper.parentNode),\r\n            trMatrix: createSVGMatrix(),\r\n            scMatrix: createSVGMatrix(),\r\n            rotMatrix: createSVGMatrix(),\r\n            scaleX,\r\n            scaleY,\r\n            scX: Math.sqrt(ctm.a * ctm.a + ctm.b * ctm.b),\r\n            scY: Math.sqrt(ctm.c * ctm.c + ctm.d * ctm.d),\r\n            bBox: eBBox\r\n        };\r\n\r\n        const boxCenterX = c_left + cw / 2,\r\n            boxCenterY = c_top + ch / 2;\r\n\r\n        const centerX = cHandle\r\n                ? cHandle.cx.baseVal.value\r\n                : boxCenterX,\r\n            centerY = cHandle\r\n                ? cHandle.cy.baseVal.value\r\n                : boxCenterY;\r\n\r\n        // c-handle's coordinates\r\n        const { x: bcx, y: bcy } = pointTo(\r\n            boxCTM,\r\n            centerX,\r\n            centerY\r\n        );\r\n\r\n        // element's center coordinates\r\n        const { x: elcx, y: elcy } = isDef(cHandle)\r\n            ? pointTo(\r\n                parentMatrix.inverse(),\r\n                bcx,\r\n                bcy\r\n            )\r\n            : pointTo(\r\n                elMatrix,\r\n                el_x + el_w / 2,\r\n                el_y + el_h / 2\r\n            );\r\n\r\n        // box's center coordinates\r\n        const { x: rcx, y: rcy } = pointTo(\r\n            getTransformToElement(box, container),\r\n            boxCenterX,\r\n            boxCenterY\r\n        );\r\n\r\n        checkChildElements(element).forEach(child => {\r\n            child.__ctm__ = getTransformToElement(child, container);\r\n        });\r\n\r\n        return {\r\n            transform,\r\n            cw,\r\n            ch,\r\n            center: {\r\n                x: cHandle ? bcx : rcx,\r\n                y: cHandle ? bcy : rcy,\r\n                el_x: elcx,\r\n                el_y: elcy,\r\n                hx: cHandle ? cHandle.cx.baseVal.value : null,\r\n                hy: cHandle ? cHandle.cy.baseVal.value : null,\r\n                isShifted: (floatToFixed(rcx, 3) !== floatToFixed(bcx, 3)) &&\r\n                    (floatToFixed(rcy, 3) !== floatToFixed(bcy, 3))\r\n            },\r\n            left: c_left,\r\n            top: c_top,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        };\r\n    }\r\n\r\n    _moveCenterHandle(x, y) {\r\n        const {\r\n            handles: { center, radius },\r\n            center: { hx, hy }\r\n        } = this.storage;\r\n\r\n        if (isUndef(center)) return;\r\n\r\n        const mx = hx + x,\r\n            my = hy + y;\r\n\r\n        center.cx.baseVal.value = mx;\r\n        center.cy.baseVal.value = my;\r\n\r\n        radius.x2.baseVal.value = mx;\r\n        radius.y2.baseVal.value = my;\r\n    }\r\n\r\n    resetCenterPoint() {\r\n        const {\r\n            box,\r\n            handles: { center, radius }\r\n        } = this.storage;\r\n\r\n        const {\r\n            width: cw,\r\n            height: ch,\r\n            x: c_left,\r\n            y: c_top\r\n        } = box.getBBox();\r\n\r\n        const matrix = getTransformToElement(box, box.parentNode);\r\n\r\n        const { x: cx, y: cy } = pointTo(\r\n            matrix,\r\n            c_left + cw / 2,\r\n            c_top + ch / 2\r\n        );\r\n\r\n        center.cx.baseVal.value = cx;\r\n        center.cy.baseVal.value = cy;\r\n        center.isShifted = false;\r\n\r\n        radius.x2.baseVal.value = cx;\r\n        radius.y2.baseVal.value = cy;\r\n    }\r\n\r\n    fitControlsToSize() {\r\n        const { \r\n            el, \r\n            storage: { box, wrapper }, \r\n            options: { container }\r\n        } = this;\r\n\r\n        const {\r\n            width,\r\n            height,\r\n            x,\r\n            y\r\n        } = el.getBBox();\r\n\r\n        const containerMatrix = getTransformToElement(\r\n            el,\r\n            container\r\n        );\r\n        \r\n        wrapper.removeAttribute('transform');\r\n        box.setAttribute('transform', matrixToString(containerMatrix));\r\n\r\n        applyTransformToHandles(\r\n            this.storage,\r\n            {\r\n                x,\r\n                y,\r\n                width,\r\n                height,\r\n                boxMatrix: containerMatrix\r\n            }\r\n        );\r\n    }\r\n\r\n    get controls() {\r\n        return this.storage.wrapper;\r\n    }\r\n\r\n}\r\n\r\nfunction applyTranslate(element, { x, y }) {\r\n    const attrs = [];\r\n\r\n    switch (element.tagName.toLowerCase()) {\r\n\r\n        case 'text': {\r\n            const resX = isDef(element.x.baseVal[0])\r\n                ? element.x.baseVal[0].value + x\r\n                : (Number(element.getAttribute('x')) || 0) + x;\r\n            const resY = isDef(element.y.baseVal[0])\r\n                ? element.y.baseVal[0].value + y\r\n                : (Number(element.getAttribute('y')) || 0) + y;\r\n\r\n            attrs.push(\r\n                ['x', resX],\r\n                ['y', resY]\r\n            );\r\n            break;\r\n        }\r\n        case 'use':\r\n        case 'image':\r\n        case 'rect': {\r\n            const resX = isDef(element.x.baseVal.value)\r\n                ? element.x.baseVal.value + x\r\n                : (Number(element.getAttribute('x')) || 0) + x;\r\n            const resY = isDef(element.y.baseVal.value)\r\n                ? element.y.baseVal.value + y\r\n                : (Number(element.getAttribute('y')) || 0) + y;\r\n\r\n            attrs.push(\r\n                ['x', resX],\r\n                ['y', resY]\r\n            );\r\n            break;\r\n        }\r\n        case 'circle':\r\n        case 'ellipse': {\r\n            const resX = element.cx.baseVal.value + x,\r\n                resY = element.cy.baseVal.value + y;\r\n\r\n            attrs.push(\r\n                ['cx', resX],\r\n                ['cy', resY]\r\n            );\r\n            break;\r\n        }\r\n        case 'line': {\r\n            const resX1 = element.x1.baseVal.value + x,\r\n                resY1 = element.y1.baseVal.value + y,\r\n                resX2 = element.x2.baseVal.value + x,\r\n                resY2 = element.y2.baseVal.value + y;\r\n\r\n            attrs.push(\r\n                ['x1', resX1],\r\n                ['y1', resY1],\r\n                ['x2', resX2],\r\n                ['y2', resY2]\r\n            );\r\n            break;\r\n        }\r\n        case 'polygon':\r\n        case 'polyline': {\r\n            const points = parsePoints(element.getAttribute('points'));\r\n            const result = points.map(item => {\r\n                item[0] = Number(item[0]) + x;\r\n                item[1] = Number(item[1]) + y;\r\n\r\n                return item.join(' ');\r\n            }).join(' ');\r\n\r\n            attrs.push(\r\n                ['points', result]\r\n            );\r\n            break;\r\n        }\r\n        case 'path': {\r\n            const path = element.getAttribute('d');\r\n\r\n            attrs.push(['d', movePath(\r\n                {\r\n                    path,\r\n                    dx: x,\r\n                    dy: y\r\n                }\r\n            )]);\r\n            break;\r\n        }\r\n\r\n    }\r\n\r\n    attrs.forEach(item => {\r\n        element.setAttribute(item[0], item[1]);\r\n    });\r\n}\r\n\r\nfunction applyResize(element, data) {\r\n    const {\r\n        scaleX,\r\n        scaleY,\r\n        bBox,\r\n        defaultCTM,\r\n        container\r\n    } = data;\r\n\r\n    const {\r\n        width: boxW,\r\n        height: boxH\r\n    } = bBox;\r\n\r\n    const attrs = [];\r\n\r\n    const ctm = getTransformToElement(element, container);\r\n    const localCTM = defaultCTM.inverse().multiply(ctm);\r\n\r\n    switch (element.tagName.toLowerCase()) {\r\n\r\n        case 'text': {\r\n            const x = isDef(element.x.baseVal[0])\r\n                ? element.x.baseVal[0].value\r\n                : (Number(element.getAttribute('x')) || 0);\r\n            const y = isDef(element.y.baseVal[0])\r\n                ? element.y.baseVal[0].value\r\n                : (Number(element.getAttribute('y')) || 0);\r\n\r\n            const {\r\n                x: resX,\r\n                y: resY\r\n            } = pointTo(\r\n                localCTM,\r\n                x,\r\n                y\r\n            );\r\n\r\n            attrs.push(\r\n                ['x', resX + (scaleX < 0 ? boxW : 0)],\r\n                ['y', resY + (scaleY < 0 ? boxH : 0)]\r\n            );\r\n            break;\r\n        }\r\n        case 'circle': {\r\n            const r = element.r.baseVal.value,\r\n                cx = element.cx.baseVal.value,\r\n                cy = element.cy.baseVal.value,\r\n                newR = r * (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\r\n\r\n            const {\r\n                x: resX,\r\n                y: resY\r\n            } = pointTo(\r\n                localCTM,\r\n                cx,\r\n                cy\r\n            );\r\n\r\n            attrs.push(\r\n                ['r', newR],\r\n                ['cx', resX],\r\n                ['cy', resY]\r\n            );\r\n            break;\r\n        }\r\n        case 'image':\r\n        case 'rect': {\r\n            const width = element.width.baseVal.value,\r\n                height = element.height.baseVal.value,\r\n                x = element.x.baseVal.value,\r\n                y = element.y.baseVal.value;\r\n\r\n            const {\r\n                x: resX,\r\n                y: resY\r\n            } = pointTo(\r\n                localCTM,\r\n                x,\r\n                y\r\n            );\r\n\r\n            const newWidth = Math.abs(width * scaleX),\r\n                newHeight = Math.abs(height * scaleY);\r\n\r\n            attrs.push(\r\n                ['x', resX - (scaleX < 0 ? newWidth : 0)],\r\n                ['y', resY - (scaleY < 0 ? newHeight : 0)],\r\n                ['width', newWidth],\r\n                ['height', newHeight]\r\n            );\r\n            break;\r\n        }\r\n        case 'ellipse': {\r\n            const rx = element.rx.baseVal.value,\r\n                ry = element.ry.baseVal.value,\r\n                cx = element.cx.baseVal.value,\r\n                cy = element.cy.baseVal.value;\r\n\r\n            const {\r\n                x: cx1,\r\n                y: cy1\r\n            } = pointTo(\r\n                localCTM,\r\n                cx,\r\n                cy\r\n            );\r\n\r\n            const scaleMatrix = createSVGMatrix();\r\n\r\n            scaleMatrix.a = scaleX;\r\n            scaleMatrix.d = scaleY;\r\n\r\n            const {\r\n                x: nRx,\r\n                y: nRy\r\n            } = pointTo(\r\n                scaleMatrix,\r\n                rx,\r\n                ry\r\n            );\r\n\r\n            attrs.push(\r\n                ['rx', Math.abs(nRx)],\r\n                ['ry', Math.abs(nRy)],\r\n                ['cx', cx1],\r\n                ['cy', cy1]\r\n            );\r\n            break;\r\n        }\r\n        case 'line': {\r\n            const resX1 = element.x1.baseVal.value,\r\n                resY1 = element.y1.baseVal.value,\r\n                resX2 = element.x2.baseVal.value,\r\n                resY2 = element.y2.baseVal.value;\r\n\r\n            const {\r\n                x: resX1_,\r\n                y: resY1_\r\n            } = pointTo(\r\n                localCTM,\r\n                resX1,\r\n                resY1\r\n            );\r\n\r\n            const {\r\n                x: resX2_,\r\n                y: resY2_\r\n            } = pointTo(\r\n                localCTM,\r\n                resX2,\r\n                resY2\r\n            );\r\n\r\n            attrs.push(\r\n                ['x1', resX1_],\r\n                ['y1', resY1_],\r\n                ['x2', resX2_],\r\n                ['y2', resY2_]\r\n            );\r\n            break;\r\n        }\r\n        case 'polygon':\r\n        case 'polyline': {\r\n            const points = parsePoints(element.getAttribute('points'));\r\n            const result = points.map(item => {\r\n                const {\r\n                    x,\r\n                    y\r\n                } = pointTo(\r\n                    localCTM,\r\n                    Number(item[0]),\r\n                    Number(item[1])\r\n                );\r\n\r\n                item[0] = x;\r\n                item[1] = y;\r\n\r\n                return item.join(' ');\r\n            }).join(' ');\r\n\r\n            attrs.push(['points', result]);\r\n            break;\r\n        }\r\n        case 'path': {\r\n            const path = element.getAttribute('d');\r\n\r\n            attrs.push(['d', resizePath(\r\n                {\r\n                    path,\r\n                    localCTM\r\n                }\r\n            )]);\r\n            break;\r\n        }\r\n\r\n    }\r\n\r\n    attrs.forEach(([key, value]) => {\r\n        element.setAttribute(key, value);\r\n    });\r\n}\r\n\r\nfunction applyTransformToHandles(\r\n    storage,\r\n    data\r\n) {\r\n    const {\r\n        box,\r\n        handles,\r\n        center\r\n    } = storage;\r\n\r\n    let {\r\n        x,\r\n        y,\r\n        width,\r\n        height,\r\n        boxMatrix\r\n    } = data;\r\n\r\n    const hW = width / 2,\r\n        hH = height / 2;\r\n\r\n    const forced = boxMatrix !== null;\r\n\r\n    const boxCTM = !forced\r\n        ? getTransformToElement(\r\n            box,\r\n            box.parentNode\r\n        )\r\n        : boxMatrix;\r\n\r\n    const boxCenter = pointTo(boxCTM, x + hW, y + hH);\r\n\r\n    const attrs = {\r\n        tl: pointTo(boxCTM, x, y),\r\n        tr: pointTo(boxCTM, x + width, y),\r\n        br: pointTo(boxCTM, x + width, y + height),\r\n        bl: pointTo(boxCTM, x, y + height),\r\n        tc: pointTo(boxCTM, x + hW, y),\r\n        bc: pointTo(boxCTM, x + hW, y + height),\r\n        ml: pointTo(boxCTM, x, y + hH),\r\n        mr: pointTo(boxCTM, x + width, y + hH),\r\n        rotator: {},\r\n        center: isDef(handles.center) && !center.isShifted ? boxCenter : undefined\r\n    };\r\n\r\n    // if (forced) { \r\n    //     attrs.center = pointTo(\r\n    //         boxCTM, \r\n    //         center.x, \r\n    //         center.y\r\n    //     );\r\n    //     console.log(attrs.center);\r\n    // }\r\n\r\n    const theta = Math.atan2(\r\n        attrs.tl.y - attrs.tr.y,\r\n        attrs.tl.x - attrs.tr.x\r\n    );\r\n\r\n    attrs.rotator.x = attrs.mr.x - ROT_OFFSET * Math.cos(theta);\r\n    attrs.rotator.y = attrs.mr.y - ROT_OFFSET * Math.sin(theta);\r\n\r\n    const {\r\n        normal,\r\n        radius\r\n    } = handles;\r\n\r\n    if (isDef(normal)) {\r\n        normal.x1.baseVal.value = attrs.mr.x;\r\n        normal.y1.baseVal.value = attrs.mr.y;\r\n        normal.x2.baseVal.value = attrs.rotator.x;\r\n        normal.y2.baseVal.value = attrs.rotator.y;\r\n    }\r\n   \r\n    if (isDef(radius)) {\r\n        radius.x1.baseVal.value = boxCenter.x;\r\n        radius.y1.baseVal.value = boxCenter.y;\r\n        if (!center.isShifted) {\r\n            radius.x2.baseVal.value = boxCenter.x;\r\n            radius.y2.baseVal.value = boxCenter.y;\r\n        }\r\n    }\r\n\r\n    x += width < 0 ? width : 0;\r\n    y += height < 0 ? height : 0;\r\n\r\n    const boxAttrs = {\r\n        x,\r\n        y,\r\n        width: Math.abs(width),\r\n        height: Math.abs(height)\r\n    };\r\n\r\n    Object.keys(boxAttrs).forEach(attr => {\r\n        box.setAttribute(attr, boxAttrs[attr]);\r\n    });\r\n\r\n    Object.keys(attrs).forEach(key => {\r\n        const hdl = handles[key];\r\n        const attr = attrs[key];\r\n        if (isUndef(attr) || isUndef(hdl)) return;\r\n        hdl.setAttribute('cx', attr.x);\r\n        hdl.setAttribute('cy', attr.y);\r\n    });\r\n}\r\n\r\nfunction createHandler$1(l, t, color, key) {\r\n    const handler = createSVGElement('circle');\r\n    addClass(handler, `sjx-svg-hdl-${key}`);\r\n\r\n    const items = {\r\n        cx: l,\r\n        cy: t,\r\n        r: 5.5,\r\n        fill: color,\r\n        stroke: '#fff',\r\n        'fill-opacity': 1,\r\n        'vector-effect': 'non-scaling-stroke',\r\n        'stroke-width': 1\r\n    };\r\n\r\n    Object.keys(items).map(key => {\r\n        handler.setAttribute(key, items[key]);\r\n    });\r\n\r\n    return handler;\r\n}\r\n\r\nfunction setLineStyle(line, color) {\r\n    line.setAttribute('stroke', color);\r\n    line.setAttribute('stroke-dasharray', '3 3');\r\n    line.setAttribute('vector-effect', 'non-scaling-stroke');\r\n}\n\n// factory method for creating draggable elements\r\nfunction drag(options, obInstance) {\r\n    if (this.length) {\r\n        const Ob = (isDef(obInstance) && obInstance instanceof Observable)\r\n            ? obInstance\r\n            : new Observable();\r\n\r\n        return arrReduce.call(this, (result, item) => {\r\n            if (!(item instanceof SVGElement)) {\r\n                result.push(\r\n                    new Draggable(item, options, Ob)\r\n                );\r\n            } else {\r\n                if (checkElement(item)) {\r\n                    result.push(\r\n                        new DraggableSVG(item, options, Ob)\r\n                    );\r\n                }\r\n            }\r\n            return result;\r\n        }, []);\r\n    }\r\n}\n\nclass Cloneable extends SubjectModel {\r\n\r\n    constructor(el, options) {\r\n        super(el);\r\n        this.enable(options);\r\n    }\r\n\r\n    _init() {\r\n        const { \r\n            el, \r\n            options \r\n        } = this;\r\n        const $el = helper(el);\r\n\r\n        const {\r\n            style,\r\n            appendTo\r\n        } = options;\r\n\r\n        const css = {\r\n            position: 'absolute',\r\n            'z-index': '2147483647',\r\n            ...style\r\n        };\r\n\r\n        this.storage = {\r\n            css,\r\n            parent: isDef(appendTo) ? helper(appendTo)[0] : document.body\r\n        };\r\n\r\n        $el.on('mousedown', this._onMouseDown)\r\n            .on('touchstart', this._onTouchStart);\r\n\r\n        EVENTS.slice(0, 3).forEach((eventName) => {\r\n            this.eventDispatcher.registerEvent(eventName);\r\n        });\r\n    }\r\n\r\n    _processOptions(options) {\r\n        let _style = {},\r\n            _appendTo = null,\r\n            _stack = document,\r\n            _onInit = () => {},\r\n            _onMove = () => {},\r\n            _onDrop = () => {},\r\n            _onDestroy = () => {};\r\n        \r\n        if (isDef(options)) {\r\n            const {\r\n                style,\r\n                appendTo,\r\n                stack,\r\n                onInit,\r\n                onMove,\r\n                onDrop,\r\n                onDestroy\r\n            } = options;\r\n\r\n            _style = (isDef(style) && typeof style === 'object') ? style : _style;\r\n            _appendTo = appendTo || null;\r\n    \r\n            const dropZone = isDef(stack) \r\n                ? helper(stack)[0] \r\n                : document;\r\n    \r\n            _onInit = createMethod(onInit);\r\n            _onMove = createMethod(onMove);\r\n            _onDrop = isFunc(onDrop)\r\n                ? function(evt) {\r\n                    const {\r\n                        clone\r\n                    } = this.storage;\r\n    \r\n                    const result = objectsCollide(\r\n                        clone,\r\n                        dropZone\r\n                    );\r\n    \r\n                    if (result) {\r\n                        onDrop.call(this, evt, this.el, clone);\r\n                    }\r\n                }\r\n                : () => {};\r\n            _onDestroy = createMethod(onDestroy);\r\n        }\r\n        \r\n        this.options = {\r\n            style: _style,\r\n            appendTo: _appendTo,\r\n            stack: _stack\r\n        };\r\n\r\n        this.proxyMethods = {\r\n            onInit: _onInit,\r\n            onDrop: _onDrop,\r\n            onMove: _onMove,\r\n            onDestroy: _onDestroy\r\n        };\r\n    }\r\n\r\n    _start({ clientX, clientY }) {\r\n        const { \r\n            storage,\r\n            el\r\n        } = this;\r\n    \r\n        const {\r\n            parent,\r\n            css\r\n        } = storage; \r\n    \r\n        const { left, top } = getOffset(parent);\r\n    \r\n        css.left = `${(clientX - left)}px`;\r\n        css.top = `${(clientY - top)}px`;\r\n    \r\n        const clone = el.cloneNode(true);\r\n        helper(clone).css(css);\r\n    \r\n        storage.clientX = clientX;\r\n        storage.clientY = clientY;\r\n        storage.cx = clientX;\r\n        storage.cy = clientY;\r\n        storage.clone = clone;\r\n    \r\n        helper(parent)[0].appendChild(clone);\r\n        this._draw();\r\n    }\r\n\r\n    _moving({ clientX, clientY }) {    \r\n        const { storage } = this;\r\n    \r\n        storage.clientX = clientX;\r\n        storage.clientY = clientY;\r\n        storage.doDraw = true;\r\n        storage.doMove = true;\r\n    }\r\n    \r\n    _end(e) {\r\n        const { storage } = this;\r\n    \r\n        const {\r\n            clone,\r\n            frameId\r\n        } = storage;\r\n    \r\n        storage.doDraw = false;\r\n        cancelAnimFrame(frameId);\r\n    \r\n        if (isUndef(clone)) return;\r\n    \r\n        this.proxyMethods.onDrop.call(this, e);\r\n        clone.parentNode.removeChild(clone);\r\n    \r\n        delete storage.clone;\r\n    }\r\n\r\n    _animate() {\r\n        const { storage } = this;\r\n    \r\n        storage.frameId = requestAnimFrame(this._animate);\r\n\r\n        const {\r\n            doDraw,\r\n            clientX,\r\n            clientY,\r\n            cx,\r\n            cy\r\n        } = storage;\r\n\r\n        if (!doDraw) return;\r\n        storage.doDraw = false;\r\n\r\n        this._drag(\r\n            { \r\n                dx: clientX - cx,\r\n                dy: clientY - cy\r\n            }\r\n        );\r\n    }\r\n\r\n    _processMove(dx, dy) {\r\n        const {\r\n            clone\r\n        } = this.storage;\r\n\r\n        const translate = `translate(${dx}px, ${dy}px)`;\r\n\r\n        helper(clone).css({\r\n            transform: translate,\r\n            webkitTranform: translate,\r\n            mozTransform: translate,\r\n            msTransform: translate,\r\n            otransform: translate \r\n        });\r\n    }\r\n    \r\n    _destroy() {\r\n        const {\r\n            storage,\r\n            proxyMethods,\r\n            el\r\n        } = this;\r\n\r\n        if (isUndef(storage)) return;\r\n        helper(el)\r\n            .off('mousedown', this._onMouseDown)\r\n            .off('touchstart', this._onTouchStart);\r\n\r\n        proxyMethods.onDestroy.call(this, el);\r\n        delete this.storage;\r\n    }\r\n\r\n    disable() {\r\n        this._destroy();\r\n    }\r\n\r\n}\n\nfunction clone(options) {\n    if (this.length) {\n        return arrMap.call(this, item => {\n            return new Cloneable(item, options);\n        });\n    }\n}\n\nclass Subjx extends Helper {\r\n\r\n    drag() {\r\n        return drag.call(this, ...arguments);\r\n    }\r\n\r\n    clone() {\r\n        return clone.call(this, ...arguments);\r\n    }\r\n\r\n}\n\nfunction subjx(params) {\r\n    return new Subjx(params);\r\n}\r\n\r\nObject.defineProperty(subjx, 'createObservable', {\r\n    value: () => {\r\n        return new Observable();\r\n    }\r\n});\r\n\r\nObject.defineProperty(subjx, 'Subjx', {\r\n    value: Subjx\r\n});\r\n\r\nObject.defineProperty(subjx, 'Observable', {\r\n    value: Observable\r\n});\n\nmodule.exports = subjx;\n","'use strict';\r\n\r\nif (process.env.NODE_ENV === 'production') {\r\n    module.exports = require('./dist/js/subjx.common.js');\r\n} else {\r\n    module.exports = require('./dist/js/subjx.dev.common.js');\r\n}","import \"subjx/dist/style/subjx.css\";\r\n\r\nimport subjx from \"subjx\";\r\n\r\nvar zoom_value_formula = 1;\r\nlet scaleValue = 1;\r\n\r\n// self executing function here\r\n(function() {\r\n    // your page initialization code here\r\n    // the DOM will be available here\r\n\r\n    document.getElementById(\"cacluate_position\").onclick = cacluatePosition;\r\n    document.getElementById(\"zoom_canvas\").onchange = changeZoomCanvas;\r\n\r\n    const selected_index = document.getElementById(\"zoom_canvas\").selectedIndex;\r\n    console.log(\"selected_index \", selected_index)\r\n    defaultSelectedZoomCanvas(selected_index);\r\n\r\n    checkAllImagesLoaded();\r\n    // document.addEventListener('click',clickEvent)\r\n    document.addEventListener('mousemove',moveCursor)\r\n    \r\n\r\n\r\n})();\r\nfunction clickEvent(event)\r\n{\r\n    \r\n    if(clicked)\r\n    {\r\n        console.log('click event')\r\n        console.log(event.target)\r\n        \r\n\r\n    }\r\n    \r\n}\r\nfunction fitTextToImage()\r\n{\r\n    // const images = document.querySelectorAll(\".image_element\");\r\n    console.log(\"divs\")\r\n    var divs = document.querySelectorAll('div[id^=\"imageContainer\"]');\r\n    divs.forEach((div) => {\r\n        let text_div=div.getElementsByClassName(\"image_text\")[0];\r\n        let image_div=div.getElementsByClassName(\"image_element\")[0];\r\n        text_div.style.width=image_div.clientWidth-20+\"px\";\r\n\r\n        \r\n    });\r\n    console.log(divs)\r\n}\r\nfunction transformToFit() {\r\n    const images = document.querySelectorAll(\".image_element\");\r\n    console.log(\"images \", images);\r\n    let maxWidth = 0;\r\n    images.forEach((image) => {\r\n      const width = image.clientWidth;\r\n      maxWidth = Math.max(maxWidth, width);\r\n      const height = image.clientHeight;\r\n      console.log(`Image width: ${width}px, height: ${height}px`);\r\n    });\r\n    let container = document.getElementById(\"stack\");\r\n    let offsets_world = document.getElementById(\"world\");\r\n    \r\n    // if(maxWidth>container.clientWidth){\r\n      scaleValue = container.clientWidth / maxWidth;\r\n    if (scaleValue <= 1) {\r\n      // scaleValue = container.clientWidth / maxWidth - 0.01;\r\n      scaleValue=scaleValue- 0.01;\r\n      offsets_world.style.transform = `scale(${scaleValue})`;\r\n    } else {\r\n      // scaleValue = container.clientWidth / maxWidth - 0.2;\r\n      scaleValue=scaleValue- 0.1;\r\n      offsets_world.style.transform = `scale(${scaleValue})`;\r\n    }\r\n    zoom_value_formula = 1 / scaleValue;\r\n    // }\r\n    // else{\r\n    //     scaleValue=maxWidth;\r\n    // offsets_world.style.transform = `scale(${scaleValue})`;\r\n    // }\r\n  \r\n    // if(scaleValue>0){\r\n    // zoom_value_formula = 1/scaleValue;\r\n    // }\r\n    // console.log(container.clientWidth/maxWidth-0.01)\r\n  }\r\nfunction changeZoomCanvas(event) {\r\n    console.log(\"doSomething\", event);\r\n\r\n    const selected_index = event.target.selectedIndex;\r\n    console.log(\"selected_index \", selected_index);\r\n\r\n    defaultSelectedZoomCanvas(selected_index)\r\n}\r\n\r\nfunction defaultSelectedZoomCanvas(selected_index) {\r\n\r\n    let offsets_world = document.getElementById('world');\r\n\r\n    offsets_world.style.transformOrigin = '0px 0px';\r\n    if (selected_index == 0) {\r\n        zoom_value_formula = 2.5;\r\n        offsets_world.style.transform = 'scale(0.4)';\r\n    } else if (selected_index == 1) {\r\n        zoom_value_formula = 2;\r\n        offsets_world.style.transform = 'scale(0.5)';\r\n    } else if (selected_index == 2) {\r\n        zoom_value_formula = 1.667;\r\n        offsets_world.style.transform = 'scale(0.6)';\r\n    } else if (selected_index == 3) {\r\n        zoom_value_formula = 1.43;\r\n        offsets_world.style.transform = 'scale(0.7)';\r\n    } else if (selected_index == 4) {\r\n        zoom_value_formula = 1.25;\r\n        offsets_world.style.transform = 'scale(0.8)';\r\n    } else if (selected_index == 5) {\r\n        zoom_value_formula = 1.1;\r\n        offsets_world.style.transform = 'scale(0.9)';\r\n    } else if (selected_index == 6) {\r\n        // zoom_value_formula = 1;\r\n        // offsets_world.style.transform = 'scale(1)';\r\n        transformToFit()\r\n    } else if (selected_index == 7) {\r\n        zoom_value_formula = 0.82;\r\n        offsets_world.style.transform = 'scale(1.2)';\r\n    }\r\n}\r\n\r\nfunction cacluatePosition() {\r\n\r\n    var pagesOffsetObject = [{\"height\":3329.05078125,\"snapshots_name\":\"1448/samplepdf-1632023123525/images/sample-1.png\",\"image_height\":3303.70361328125,\"image_width\":2553.70361328125},{\"height\":3329.05078125,\"snapshots_name\":\"1448/samplepdf-1632023123525/images/sample-2.png\",\"image_height\":3303.70361328125,\"image_width\":2553.70361328125},{\"height\":1065.0462646484375,\"snapshots_name\":\"1448/SampleJPGImagekbmbjpg-1632023123544/images/SampleJPGImage_200kbmb-1.png\",\"image_height\":1039.6990966796875,\"image_width\":1039.6990966796875}];\r\n\r\n    console.log(xDraggable);\r\n\r\n    let meta_data = [];\r\n    let margin_gap = 24;\r\n\r\n    const array_xDraggable = xDraggable;\r\n    for (let index = 1; index < array_xDraggable.length; index++) \r\n    {\r\n        const draggable_element = array_xDraggable[index][0];\r\n        \r\n        console.log(\"draggable_element \", draggable_element);\r\n\r\n        const draggable_element_main = draggable_element[\"el\"];\r\n\r\n        let page = 0;\r\n\r\n        const temp_meta_data_top =\r\n        parseInt($(draggable_element_main).css(\"top\").slice(0, -2)) +\r\n        (parseInt($(draggable_element_main).css(\"transform\").split(\",\")[5])\r\n            ? parseInt($(draggable_element_main).css(\"transform\").split(\",\")[5])\r\n            : 0);\r\n\r\n\r\n        for (let j = 0; j < pagesOffsetObject.length; j++) \r\n        {\r\n            const snapshots_name = pagesOffsetObject[j].snapshots_name;\r\n            console.log(\"snapshots_name \", snapshots_name);\r\n\r\n            const current_page_image_height = pagesOffsetObject[j].image_height;\r\n            const current_page_image_width = pagesOffsetObject[j].image_width;\r\n\r\n            let image_document_element = document.querySelector(\"[snapshots_name='\"+snapshots_name+\"']\").querySelectorAll('img')[0];\r\n            console.log(\"image_document_element \", image_document_element);\r\n\r\n            let offsets = draggable_element_main.getBoundingClientRect();\r\n            console.log(\"offsets \", offsets);\r\n\r\n            let offsets_document_image = image_document_element.getBoundingClientRect();\r\n            console.log(\"offsets \", offsets);\r\n\r\n            let top = (offsets.top - offsets_document_image.top)*zoom_value_formula;\r\n            const left = (offsets.left - offsets_document_image.left)*zoom_value_formula;\r\n            const width = offsets.width * zoom_value_formula;\r\n            const height = offsets.height * zoom_value_formula;\r\n            const image_width = offsets_document_image.width * zoom_value_formula;\r\n            const image_height = offsets_document_image.height * zoom_value_formula;\r\n\r\n            page = j + 1;\r\n                meta_data.push({\r\n                    top: Math.ceil(top),\r\n                    left: Math.ceil(left),\r\n                    width: Math.ceil(width),\r\n                    height: Math.ceil(height),\r\n                    page: page,\r\n                    documents_top: Math.ceil(temp_meta_data_top),\r\n                });\r\n                break;\r\n        }\r\n\r\n        // let element_object = {\r\n        //     top : top,\r\n        //     left : left,\r\n        //     // snapshots_name : snapshots_name,\r\n        //     // document_key : document_key,\r\n        //     width : width,\r\n        //     height : height,\r\n        //     // image_width : image_width, \r\n        //     // image_height : image_height\r\n        // }\r\n\r\n        // meta_data.push(element_object);\r\n\r\n        if(array_xDraggable.length-1 == index)\r\n        {\r\n            console.log(\"meta_data \", meta_data);\r\n        }\r\n        \r\n    }\r\n  \r\n}\r\nlet clicked = false;\r\nlet elementToBeCloned = null;\r\nlet elementToBeClonedDup = null;\r\nconst xElem = subjx(\".draggable\");\r\nconst options = {\r\n    container: '#world',\r\n    snap: {\r\n        x: 0,\r\n        y: 0,\r\n        angle: 0\r\n    },\r\n    cursorMove: 'move',\r\n    cursorRotate: 'crosshair',\r\n    cursorResize: 'pointer',\r\n    rotatable : false,\r\n\r\n    ...methods\r\n\r\n}\r\n\r\nconst methods = {\r\n    onInit(elements) {\r\n        // fires on tool activation\r\n        console.log(\"onInit \", elements)\r\n    },\r\n    onMove({\r\n        clientX,\r\n        clientY,\r\n        dx,\r\n        dy,\r\n        transform\r\n    }) {\r\n        // fires on moving\r\n        console.log(\"onMove \", clientX)\r\n    },\r\n    onResize({\r\n        clientX,\r\n        clientY,\r\n        dx,\r\n        dy,\r\n        transform,\r\n        width,\r\n        height\r\n    }) {\r\n        // fires on resizing\r\n        console.log(\"onResize \", clientX)\r\n    },\r\n    onRotate({\r\n        clientX,\r\n        clientY,\r\n        delta,\r\n        transform\r\n    }) {\r\n        // fires on rotation\r\n        console.log(\"onRotate \", clientX)\r\n    },\r\n    onDrop({\r\n        clientX,\r\n        clientY\r\n    }) {\r\n        // fires on drop\r\n        console.log(\"onDrop \", clientX)\r\n    },\r\n    onDestroy(el) {\r\n        // fires on tool deactivation\r\n        console.log(\"onDestroy \", el)\r\n    }\r\n}\r\nlet xDraggable = xElem.drag(options);\r\n// console.log(xDraggable.controls);\r\nfunction cloneElement(e,el){\r\n    console.log(\"onDrop e \", e);\r\n        console.log(\"onDrop el \", el);\r\n        // console.log(\"onDrop clone \", clone);\r\n        let parent = document.getElementById(\"world\");\r\n\r\n        // console.log(xDraggable.length)\r\n        const stack = subjx('#world')[0],\r\n            offset = stack.getBoundingClientRect(),\r\n            drag_div = document.createElement('div');\r\n\r\n        // const xDraggable_length = xDraggable.length;\r\n\r\n        // drag_div.setAttribute(\"id\", \"item_\"+(xDraggable_length+1));\r\n        drag_div.setAttribute(\"class\", \"draggable\");\r\n        drag_div.setAttribute(\"document_id\", e.target.id);\r\n        drag_div.style.top = `${(e.clientY - offset.top)*zoom_value_formula}px`;\r\n        drag_div.style.left = `${(e.clientX - offset.left)*zoom_value_formula}px`;\r\n\r\n        console.log(\"top \", e.clientY, \" \", offset.top, \" -> \", ((e.clientY - offset.top) * zoom_value_formula));\r\n        console.log(\"left \", e.clientX, \" \", offset.left, \" -> \", ((e.clientX - offset.left) * zoom_value_formula));\r\n\r\n        // drag_div.style.top = \"150px\";\r\n        // drag_div.style.left = \"600px\";\r\n\r\n        let drag_img = document.createElement('img');\r\n        drag_img.style.background = \"url('https://wesign.com/assets/images_dev/sign_box_2.png') 50% center / contain no-repeat, rgb(255, 214, 91)\";\r\n        drag_img.style.opacity = 0.8;\r\n        drag_img.style.border =  '1px solid rgb(255, 255, 118)';\r\n        drag_img.style.borderRadius =  '5px';\r\n        drag_img.style.width = '100%';\r\n        drag_img.style.height =  '100%';\r\n\r\n\r\n        drag_div.appendChild(drag_img);\r\n        parent.appendChild(drag_div);\r\n\r\n        xDraggable.push(\r\n            subjx(drag_div).drag(options)\r\n        );\r\n\r\n}\r\nfunction CloneElementUsingXY(clientX,clientY,target_id)\r\n{\r\n    // console.log(\"onDrop e \", e);\r\n    //     console.log(\"onDrop el \", el);\r\n    //     // console.log(\"onDrop clone \", clone);\r\n    \r\n    \r\n        // console.log(\"onDrop clone \", clone);\r\n        let parent = document.getElementById(\"world\");\r\n\r\n        // console.log(xDraggable.length)\r\n        const stack = subjx('#world')[0],\r\n            offset = stack.getBoundingClientRect(),\r\n            drag_div = document.createElement('div');\r\n\r\n        // const xDraggable_length = xDraggable.length;\r\n\r\n        // drag_div.setAttribute(\"id\", \"item_\"+(xDraggable_length+1));\r\n        drag_div.setAttribute(\"class\", \"draggable\");\r\n        drag_div.setAttribute(\"document_id\", target_id);\r\n        drag_div.style.top = `${(clientY - offset.top)*zoom_value_formula}px`;\r\n        drag_div.style.left = `${(clientX - offset.left)*zoom_value_formula}px`;\r\n\r\n        console.log(\"top \", clientY, \" \", offset.top, \" -> \", ((clientY - offset.top) * zoom_value_formula));\r\n        console.log(\"left \", clientX, \" \", offset.left, \" -> \", ((clientX - offset.left) * zoom_value_formula));\r\n\r\n        // drag_div.style.top = \"150px\";\r\n        // drag_div.style.left = \"600px\";\r\n\r\n        let drag_img = document.createElement('img');\r\n        drag_img.style.background = \"url('https://wesign.com/assets/images_dev/sign_box_2.png') 50% center / contain no-repeat, rgb(255, 214, 91)\";\r\n        drag_img.style.opacity = 0.8;\r\n        drag_img.style.border =  '1px solid rgb(255, 255, 118)';\r\n        drag_img.style.borderRadius =  '5px';\r\n        drag_img.style.width = '100%';\r\n        drag_img.style.height =  '100%';\r\n\r\n\r\n        drag_div.appendChild(drag_img);\r\n        parent.appendChild(drag_div);\r\n\r\n        xDraggable.push(\r\n            subjx(drag_div).drag(options)\r\n        );\r\n\r\n\r\n}\r\nsubjx('.clone').clone({\r\n    stack: '#container',\r\n    appendTo: '#stack',\r\n    onInit(el) {\r\n        // fires on tool activation;\r\n        console.log(\"clone init\")\r\n    },\r\n    onMove(dx, dy) {\r\n        // fires on moving\r\n        // console.log(\"fires on moving \", dx, dy)\r\n    },\r\n    onDrop(e, el, clone) {\r\n        // fires on drop\r\n        console.log(\"onDrop e \", e);\r\n        console.log(\"onDrop el \", el);\r\n        console.log(\"onDrop clone \", clone);\r\n        cloneElement(e,el);\r\n        // let parent = document.getElementById(\"world\");\r\n\r\n        // // console.log(xDraggable.length)\r\n        // const stack = subjx('#world')[0],\r\n        //     offset = stack.getBoundingClientRect(),\r\n        //     drag_div = document.createElement('div');\r\n\r\n        // // const xDraggable_length = xDraggable.length;\r\n\r\n        // // drag_div.setAttribute(\"id\", \"item_\"+(xDraggable_length+1));\r\n        // drag_div.setAttribute(\"class\", \"draggable\");\r\n        // drag_div.setAttribute(\"document_id\", e.target.id);\r\n        // drag_div.style.top = `${(e.clientY - offset.top)*zoom_value_formula}px`;\r\n        // drag_div.style.left = `${(e.clientX - offset.left)*zoom_value_formula}px`;\r\n\r\n        // console.log(\"top \", e.clientY, \" \", offset.top, \" -> \", ((e.clientY - offset.top) * zoom_value_formula));\r\n        // console.log(\"left \", e.clientX, \" \", offset.left, \" -> \", ((e.clientX - offset.left) * zoom_value_formula));\r\n\r\n        // // drag_div.style.top = \"150px\";\r\n        // // drag_div.style.left = \"600px\";\r\n\r\n        // let drag_img = document.createElement('img');\r\n        // drag_img.style.background = \"url('https://wesign.com/assets/images_dev/sign_box_2.png') 50% center / contain no-repeat, rgb(255, 214, 91)\";\r\n        // drag_img.style.opacity = 0.8;\r\n        // drag_img.style.border =  '1px solid rgb(255, 255, 118)';\r\n        // drag_img.style.borderRadius =  '5px';\r\n        // drag_img.style.width = '100%';\r\n        // drag_img.style.height =  '100%';\r\n\r\n\r\n        // drag_div.appendChild(drag_img);\r\n        // parent.appendChild(drag_div);\r\n\r\n        // xDraggable.push(\r\n        //     subjx(drag_div).drag(options)\r\n        // );\r\n    },\r\n    onDestroy() {\r\n        // fires on tool deactivation\r\n    }\r\n});\r\nsubjx('#container').on('click', async (a) => {\r\n    if(clicked == true)\r\n    {\r\n        clicked = false;\r\n        cloneElement(a,elementToBeCloned);\r\n        // document.removeChild(elementToBeClonedDup);\r\n        let container=document.getElementById(\"container\");\r\n    container.removeChild(elementToBeClonedDup);\r\n    }\r\n});\r\n// subjx('.clone').clone({\r\n\r\n// })\r\n\r\n\r\nfunction moveCursor(event)\r\n{\r\n    // console.log(\"moveCursor \", event)\r\n    const mouseY= event.clientY;\r\n    const mouseX= event.clientX;\r\n    // elementToBeCloned.style. = mouseY;\r\n    let element=document.getElementById(\"container\");\r\n    const isHover = e => e.parentElement.querySelector(':hover') === e;\r\n    // if()\r\n    if(clicked == true && isHover(element) )\r\n    {\r\n        elementToBeClonedDup.style.left = mouseX + \"px\";\r\n    elementToBeClonedDup.style.top = mouseY + \"px\";\r\n    // clicked = false;\r\n    \r\n\r\n    }\r\n    \r\n}\r\n\r\nsubjx('.clone').on('click', async (a) => {\r\n    console.log(\"e \", a);\r\n    let el=a.target;\r\n    console.log(\"el \", el);\r\n    console.log(\"single\");\r\n    if(clicked == true)\r\n    {\r\n        clicked = false;\r\n        let container=document.getElementById(\"container\");\r\n        // container.appendChild(elementToBeClonedDup);\r\n        // elementToBeClonedDup.style.zIndex=\"-1\";\r\n        // elementToBeClonedDup.style.width=\"100px\";\r\n        // elementToBeClonedDup.style.height=\"100px\";\r\n        // elementToBeClonedDup.style.position=\"fixed\";\r\n        // elementToBeClonedDup.style.pointerEvents=\"none\";\r\n        container.removeChild(elementToBeClonedDup);\r\n        // container.appendChild(elementToBeClonedDup)\r\n        \r\n    }\r\n    else\r\n    {\r\n        setTimeout(()=>{clicked = true;},1)\r\n        \r\n        elementToBeCloned = el;\r\n        \r\n        elementToBeClonedDup=elementToBeCloned.cloneNode(true);\r\n        // elementToBeClonedDup.style.position = \"absolute\";\r\n        // console.log(elementToBeClonedDup.style) \r\n        // console.log(elementToBeClonedDup)\r\n        // elementToBeClonedDup.style.transition=\"all 200ms ease-out\";\r\n        // elementToBeClonedDup.style.pointerEvents=\"none\";\r\n        let container=document.getElementById(\"container\");\r\n        // container.appendChild(elementToBeClonedDup);\r\n        // elementToBeClonedDup.style.zIndex=\"-1\";\r\n        // elementToBeClonedDup.style.width=\"100px\";\r\n        // elementToBeClonedDup.style.height=\"100px\";\r\n        elementToBeClonedDup.style.position=\"fixed\";\r\n        elementToBeClonedDup.style.pointerEvents=\"none\";\r\n\r\n        container.appendChild(elementToBeClonedDup)\r\n        \r\n    }\r\n\r\n    \r\n\r\n});\r\n\r\nsubjx('.clone').on('dblclick', async () => {\r\n    function getStartEnd(element)\r\n    {\r\n        let elementRect= element.getBoundingClientRect();\r\n        let elementStart=elementRect.y;\r\n        let elementEnd=elementRect.y + elementRect.height;\r\n        return [elementStart,elementEnd]\r\n\r\n    }\r\n    console.log(\"double click\");\r\n    // console.log(document.activeElement)\r\n    var divs = document.querySelectorAll('img[id^=\"image_element\"]');\r\n    let container=document.getElementById('container')\r\n    let [containerStart,containerEnd]=getStartEnd(container)\r\n\r\n    let maxPercentage=0\r\n    let maxDiv=null;\r\n    divs.forEach((div) => {\r\n        // let text_div=div.getElementsByClassName(\"image_text\")[0];\r\n        // let image_div=div.getElementsByClassName(\"image_element\")[0];\r\n        // text_div.style.width=image_div.clientWidth-20+\"px\";\r\n        let [elementStart,elementEnd]=getStartEnd(div)\r\n        console.log(getStartEnd(div))\r\n        elementStart=Math.max(elementStart,containerStart)\r\n        elementEnd=Math.min(elementEnd,containerEnd)\r\n        console.log('elementStart',elementStart)\r\n        console.log('elementEnd',elementEnd)\r\n        if(elementStart<elementEnd)\r\n        {\r\n            let elPercentage=elementEnd-elementStart\r\n            if(elPercentage>maxPercentage)\r\n            {\r\n                maxPercentage=elPercentage\r\n                maxDiv=div\r\n            }\r\n        }\r\n    });\r\n    console.log('max div')\r\n    console.log(maxDiv)\r\n    let maxDivRect=maxDiv.getBoundingClientRect();\r\n    CloneElementUsingXY(maxDivRect.x,maxDivRect.y,maxDiv.id)\r\n\r\n});\r\nsubjx(\".removePointer\").on('click',async (a)=>{\r\n    if(clicked == true)\r\n    {\r\n        clicked = false;\r\n        // cloneElement(a,elementToBeCloned);\r\n        // document.removeChild(elementToBeClonedDup);\r\n        let container=document.getElementById(\"container\");\r\n    container.removeChild(elementToBeClonedDup);\r\n    }\r\n\r\n})\r\n\r\nfunction checkAllImagesLoaded() {\r\n    var imgs = document.images,\r\n    len = imgs.length,\r\n    counter = 0;\r\n\r\n    [].forEach.call( imgs, function( img ) {\r\n        if(img.complete)\r\n        incrementCounter();\r\n        else\r\n        img.addEventListener( 'load', incrementCounter, false );\r\n    } );\r\n\r\n    function incrementCounter() {\r\n        counter++;\r\n        if ( counter === len ) {\r\n            console.log( 'All images loaded!' );\r\n            fitToWidth();\r\n        }\r\n    }\r\n\r\n}\r\n\r\nfunction fitToWidth() {\r\n    transformToFit()\r\n    fitTextToImage()\r\n    scrollCheck();\r\n    \r\n\r\n}\r\nfunction scrollCheck()\r\n{\r\n    console.log(\"scrollCheck\")\r\n    let container=document.getElementById(\"stack\");\r\n    console.log(\"container \", container)\r\n    container.addEventListener('scroll', function() {\r\n        var element = document.querySelector('#image_element01');\r\n        var position = element.getBoundingClientRect();\r\n        console.log(\"position \", position)\r\n    \r\n        // checking whether fully visible\r\n        if(position.top >= 0 && position.bottom <= window.innerHeight) {\r\n            console.log('Element is fully visible in screen');\r\n        }\r\n    \r\n        // checking for partial visibility\r\n        if(position.top < window.innerHeight && position.bottom >= 0) {\r\n            console.log('Element is partially visible in screen');\r\n        }\r\n    });\r\n}\r\n\r\n\r\n","var bundleURL = null;\nfunction getBundleURLCached() {\n  if (!bundleURL) {\n    bundleURL = getBundleURL();\n  }\n\n  return bundleURL;\n}\n\nfunction getBundleURL() {\n  // Attempt to find the URL of the current script and use that as the base URL\n  try {\n    throw new Error;\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\\/\\/[^)\\n]+/g);\n    if (matches) {\n      return getBaseURL(matches[0]);\n    }\n  }\n\n  return '/';\n}\n\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\\/\\/.+)?\\/[^/]+(?:\\?.*)?$/, '$1') + '/';\n}\n\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\n","var bundle = require('./bundle-url');\n\nfunction updateLink(link) {\n  var newLink = link.cloneNode();\n  newLink.onload = function () {\n    link.remove();\n  };\n  newLink.href = link.href.split('?')[0] + '?' + Date.now();\n  link.parentNode.insertBefore(newLink, link.nextSibling);\n}\n\nvar cssTimeout = null;\nfunction reloadCSS() {\n  if (cssTimeout) {\n    return;\n  }\n\n  cssTimeout = setTimeout(function () {\n    var links = document.querySelectorAll('link[rel=\"stylesheet\"]');\n    for (var i = 0; i < links.length; i++) {\n      if (bundle.getBaseURL(links[i].href) === bundle.getBundleURL()) {\n        updateLink(links[i]);\n      }\n    }\n\n    cssTimeout = null;\n  }, 50);\n}\n\nmodule.exports = reloadCSS;\n","var OVERLAY_ID = '__parcel__error__overlay__';\n\nvar OldModule = module.bundle.Module;\n\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData,\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n\n  module.bundle.hotData = null;\n}\n\nmodule.bundle.Module = Module;\nvar checkedAssets, assetsToAccept;\n\nvar parent = module.bundle.parent;\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = process.env.HMR_HOSTNAME || location.hostname;\n  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';\n  var ws = new WebSocket(protocol + '://' + hostname + ':' + process.env.HMR_PORT + '/');\n  ws.onmessage = function(event) {\n    checkedAssets = {};\n    assetsToAccept = [];\n\n    var data = JSON.parse(event.data);\n\n    if (data.type === 'update') {\n      var handled = false;\n      data.assets.forEach(function(asset) {\n        if (!asset.isNew) {\n          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);\n          if (didAccept) {\n            handled = true;\n          }\n        }\n      });\n\n      // Enable HMR for CSS by default.\n      handled = handled || data.assets.every(function(asset) {\n        return asset.type === 'css' && asset.generated.js;\n      });\n\n      if (handled) {\n        console.clear();\n\n        data.assets.forEach(function (asset) {\n          hmrApply(global.parcelRequire, asset);\n        });\n\n        assetsToAccept.forEach(function (v) {\n          hmrAcceptRun(v[0], v[1]);\n        });\n      } else if (location.reload) { // `location` global exists in a web worker context but lacks `.reload()` function.\n        location.reload();\n      }\n    }\n\n    if (data.type === 'reload') {\n      ws.close();\n      ws.onclose = function () {\n        location.reload();\n      }\n    }\n\n    if (data.type === 'error-resolved') {\n      console.log('[parcel]  Error resolved');\n\n      removeErrorOverlay();\n    }\n\n    if (data.type === 'error') {\n      console.error('[parcel]   ' + data.error.message + '\\n' + data.error.stack);\n\n      removeErrorOverlay();\n\n      var overlay = createErrorOverlay(data);\n      document.body.appendChild(overlay);\n    }\n  };\n}\n\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n  if (overlay) {\n    overlay.remove();\n  }\n}\n\nfunction createErrorOverlay(data) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n\n  // html encode message and stack trace\n  var message = document.createElement('div');\n  var stackTrace = document.createElement('pre');\n  message.innerText = data.error.message;\n  stackTrace.innerText = data.error.stack;\n\n  overlay.innerHTML = (\n    '<div style=\"background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;\">' +\n      '<span style=\"background: red; padding: 2px 4px; border-radius: 2px;\">ERROR</span>' +\n      '<span style=\"top: 2px; margin-left: 5px; position: relative;\"></span>' +\n      '<div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">' + message.innerHTML + '</div>' +\n      '<pre>' + stackTrace.innerHTML + '</pre>' +\n    '</div>'\n  );\n\n  return overlay;\n\n}\n\nfunction getParents(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return [];\n  }\n\n  var parents = [];\n  var k, d, dep;\n\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n      if (dep === id || (Array.isArray(dep) && dep[dep.length - 1] === id)) {\n        parents.push(k);\n      }\n    }\n  }\n\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n\n  return parents;\n}\n\nfunction hmrApply(bundle, asset) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (modules[asset.id] || !bundle.parent) {\n    var fn = new Function('require', 'module', 'exports', asset.generated.js);\n    asset.isNew = !modules[asset.id];\n    modules[asset.id] = [fn, asset.deps];\n  } else if (bundle.parent) {\n    hmrApply(bundle.parent, asset);\n  }\n}\n\nfunction hmrAcceptCheck(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (!modules[id] && bundle.parent) {\n    return hmrAcceptCheck(bundle.parent, id);\n  }\n\n  if (checkedAssets[id]) {\n    return;\n  }\n  checkedAssets[id] = true;\n\n  var cached = bundle.cache[id];\n\n  assetsToAccept.push([bundle, id]);\n\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    return true;\n  }\n\n  return getParents(global.parcelRequire, id).some(function (id) {\n    return hmrAcceptCheck(global.parcelRequire, id)\n  });\n}\n\nfunction hmrAcceptRun(bundle, id) {\n  var cached = bundle.cache[id];\n  bundle.hotData = {};\n  if (cached) {\n    cached.hot.data = bundle.hotData;\n  }\n\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData);\n    });\n  }\n\n  delete bundle.cache[id];\n  bundle(id);\n\n  cached = bundle.cache[id];\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      cb();\n    });\n    return true;\n  }\n}\n"]}
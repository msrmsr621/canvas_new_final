{"version":3,"sources":["node_modules/subjx/dist/js/subjx.dev.common.js","node_modules/subjx/index.js","src/index.js","node_modules/parcel-bundler/src/builtins/bundle-url.js","node_modules/parcel-bundler/src/builtins/css-loader.js"],"names":["module","exports","require","_subjx2","_interopRequireDefault","obj","__esModule","default","_typeof","Symbol","iterator","constructor","prototype","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","toString","call","slice","name","Array","from","test","len","length","arr2","_i","_s","_e","_x","_r","_arr","_n","_d","next","done","push","value","err","return","isArray","_regeneratorRuntime","Op","hasOwn","hasOwnProperty","defineProperty","key","desc","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","enumerable","configurable","writable","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","create","context","Context","makeInvokeMethod","tryCatch","fn","arg","type","ContinueSentinel","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","method","_invoke","AsyncIterator","PromiseImpl","invoke","resolve","reject","record","result","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","state","Error","doneResult","delegate","delegateResult","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","methodName","undefined","info","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","displayName","isGeneratorFunction","genFun","ctor","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","val","object","reverse","pop","skipTempReset","prev","charAt","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","_catch","thrown","delegateYield","asyncGeneratorStep","gen","_next","_throw","_asyncToGenerator","args","arguments","apply","ownKeys","enumerableOnly","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","_objectSpread","target","source","_defineProperty","getOwnPropertyDescriptors","defineProperties","_toPropertyKey","_toPrimitive","String","input","hint","prim","toPrimitive","res","Number","zoom_value_formula","scaleValue","document","getElementById","onclick","calculatePosition","onchange","changeZoomCanvas","zoom_element","zoom_value","parseInt","defaultSelectedZoomCanvas","checkAllImagesLoaded","addEventListener","moveCursor","fitTextToImage","divs","querySelectorAll","div","text_div","getElementsByClassName","image_div","style","width","clientWidth","console","log","transformToFit","images","maxWidth","image","Math","max","height","clientHeight","concat","stack_container","offsets_world","transform","event","transformOrigin","xDraggable","clicked","elementToBeCloned","elementToBeClonedDup","options","container","snap","x","y","angle","cursorMove","cursorRotate","cursorResize","rotatable","methods","onInit","elements","onMove","_ref","clientX","clientY","dx","dy","onResize","_ref2","onRotate","_ref3","delta","onDrop","_ref4","onDestroy","el","cloneElement","e","parent","stack","subjx","offset","getBoundingClientRect","drag_div","createElement","setAttribute","id","top","left","drag_img","background","opacity","border","borderRadius","drag_element_name","getAttribute","makeId","appendChild","drag","CloneElementUsingXY","target_id","clone","appendTo","on","_ref5","_callee","a","_callee$","_context","removeChild","mouseY","mouseX","element","isHover","parentElement","querySelector","display","_ref6","_callee2","_container","_callee2$","_context2","setTimeout","cloneNode","position","pointerEvents","_x2","_callee3","getStartEnd","_getStartEnd","_getStartEnd2","containerStart","containerEnd","containerMid","maxPercentage","maxDiv","maxDivRect","visibleStart","_callee3$","_context3","_getStartEnd5","elementRect","elementStart","elementEnd","_getStartEnd3","_getStartEnd4","min","elPercentage","_ref8","_callee4","_callee4$","_context4","_x3","imgs","counter","img","incrementCounter","fitToWidth","prefix","characters","charactersLength","floor","random","bundleURL","getBundleURLCached","getBundleURL","matches","match","getBaseURL","url","replace","bundle","updateLink","link","newLink","onload","remove","href","split","Date","now","parentNode","insertBefore","nextSibling","cssTimeout","reloadCSS","links"],"mappings":"AGAA,ACAA,AJAA,ACAA,IEAI4W,ACAAQ,MAAM,EHAE,CEAC,ACAAlX,GDAG,IAAI,ACAA,CAAC,cAAc,CAAC;ADCpC,ACCA,AJDA,SGAS2W,ACCAQ,UAAUA,CAACC,IAAI,EAAE,CDDCT,CAAA,EAAG;AHC9B,ACAA,ACFA3W,ECEE,ACCA,EHDE,EEAE,ACCAqX,CDDCX,ADFP,MEGa,GDDG,ACCAU,EDDE,ECCE,CAAClD,CHDQ,QGCC,EAAE,EHDS,EAAE;ADC3C,AEDA,EEEEmD,AHDEvX,EEAA4W,ADDJzW,IDCU,CGCD,AHDEF,CGCDuX,CFFV,ECCa,CDDbpX,ECCgB0W,ACCA,AHDE,GGCC,AHDE5W,OAAO,CAAC,CEAD,EAAE,CCCC,KFF/B,CAAAA,OAAA,UDCwD,CAAC;ADCzD,ACAA,ACF0B,CDEzB,CEAC,ECCEoX,GHDG,CGCC,CAACG,AFHiBrX,MEGX,EAAE,eFHSC,GAAA,WAAAA,GAAA,IAAAA,GAAA,CAAAC,UAAA,GAAAD,GAAA,KAAAE,OAAA,EAAAF,GAAA;AFG1B,AEH0B,ECIxB,ACAA,AHDEL,CGCD,KHDO,CECD4W,AFDE3W,ACHeO,ODGR,CCHQH,CCIR,CFDGH,CCHK,MDGE,CAAC,+BAA+B,ACHlCM,CDGmC,MCHnC,wBAAAC,MAAA,uBAAAA,MAAA,CAAAC,QAAA,aAAAL,GAAA,kBAAAA,GAAA,gBAAAA,GAAA,WAAAA,GAAA,yBAAAI,MAAA,IAAAJ,GAAA,CAAAM,WAAA,KAAAF,MAAA,IAAAJ,GAAA,KAAAI,MAAA,CAAAG,SAAA,qBAAAP,GAAA,KAAAG,OAAA,CAAAH,GAAA;ACK1B,AHDA,ACAA,ACJ0B,EEKxBkX,OAAO,AFLiB1W,CEKhB6W,IAAI,GAAGJ,IAAI,CAACI,EFLI5W,EEKA,CAAC6W,AFLD,EAAA5W,CAAA,EEKM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CFLdC,EEKiB,GAAG,GAAG4W,IAAI,CAACC,EFL5B,CEK+B,AFL/B/W,EEKiC,CFLjC,KAAAG,qBAAA,CAAAH,GAAA,EAAAC,CAAA,KAAAG,2BAAA,CAAAJ,GAAA,EAAAC,CAAA,KAAAI,gBAAA;ACO1B,AHFA,AEL0B,EEMxBmW,IAAI,CAACQ,EDCEhB,ADPiB3V,QEMT,CAAC4W,GDCGjB,CAAA,EAAG,EDPE,IEMI,CAACS,OAAO,EAAED,AFNdlW,IEMkB,CAAC4W,IFNnB,OEM8B,CAAC;AACzD,AJDA,AEN0B,ECQxB,ODRwB9W,4BAAAG,CAAA,EAAAC,MAAA,SAAAD,CAAA,qBAAAA,CAAA,sBAAAE,iBAAA,CAAAF,CAAA,EAAAC,MAAA,OAAAE,CAAA,GAAAC,MAAA,CAAAb,SAAA,CAAAc,QAAA,CAAAC,IAAA,CAAAN,CAAA,EAAAO,KAAA,aAAAJ,CAAA,iBAAAH,CAAA,CAAAV,WAAA,EAAAa,CAAA,GAAAH,CAAA,CAAAV,WAAA,CAAAkB,IAAA,MAAAL,CAAA,cAAAA,CAAA,mBAAAM,KAAA,CAAAC,IAAA,CAAAV,CAAA,OAAAG,CAAA,+DAAAQ,IAAA,CAAAR,CAAA,UAAAD,iBAAA,CAAAF,CAAA,EAAAC,MAAA;AES1B,AJFA,AEP0B,ECSxB,ECAE2W,EDAE,GDToB1W,KESZ,GAAG,IAAI,MFTKT,GAAA,EAAAmB,GAAA,QAAAA,GAAA,YAAAA,GAAA,GAAAnB,GAAA,CAAAoB,MAAA,EAAAD,GAAA,GAAAnB,GAAA,CAAAoB,MAAA,WAAAnB,CAAA,MAAAoB,IAAA,OAAAL,KAAA,CAAAG,GAAA,GAAAlB,CAAA,GAAAkB,GAAA,EAAAlB,CAAA,IAAAoB,IAAA,CAAApB,CAAA,IAAAD,GAAA,CAAAC,CAAA,UAAAoB,IAAA;AEU1B,AJFA,AER0B,ICUtB,KCAK+V,AFViBjX,CCUhB,IAAI8F,ICAImR,CDAC,ACAD,EAAG,UFVKpX,GAAA,EAAAC,CAAA,QAAAqB,EAAA,WAAAtB,GAAA,gCAAAL,MAAA,IAAAK,GAAA,CAAAL,MAAA,CAAAC,QAAA,KAAAI,GAAA,4BAAAsB,EAAA,QAAAC,EAAA,EAAAC,EAAA,EAAAC,EAAA,EAAAC,EAAA,EAAAC,IAAA,OAAAC,EAAA,OAAAC,EAAA,iBAAAJ,EAAA,IAAAH,EAAA,GAAAA,EAAA,CAAAT,IAAA,CAAAb,GAAA,GAAA8B,IAAA,QAAA7B,CAAA,QAAAU,MAAA,CAAAW,EAAA,MAAAA,EAAA,UAAAM,EAAA,uBAAAA,EAAA,IAAAL,EAAA,GAAAE,EAAA,CAAAZ,IAAA,CAAAS,EAAA,GAAAS,IAAA,MAAAJ,IAAA,CAAAK,IAAA,CAAAT,EAAA,CAAAU,KAAA,GAAAN,IAAA,CAAAP,MAAA,KAAAnB,CAAA,GAAA2B,EAAA,iBAAAM,GAAA,IAAAL,EAAA,OAAAL,EAAA,GAAAU,GAAA,yBAAAN,EAAA,YAAAN,EAAA,CAAAa,MAAA,KAAAT,EAAA,GAAAJ,EAAA,CAAAa,MAAA,IAAAxB,MAAA,CAAAe,EAAA,MAAAA,EAAA,2BAAAG,EAAA,QAAAL,EAAA,aAAAG,IAAA;AFS1B,AET0B,ECWxB,ACAA,CDAC,CAAC,ECAEwV,GFXoBjX,ECWfgC,GAAG,EAAE,ACAA,EAAE,OFXQlC,GAAA,QAAAgB,KAAA,CAAAoB,OAAA,CAAApC,GAAA,UAAAA,GAAA;AFU1B,AEV0B,ICYtB,ACAA,IDAIiW,CDZkB5T,MCYX,GAAG,CAAC,EAAE,GAAGH,GAAG,CAACwO,CDZF,ICYO,EAAEwF,KAAK,CAAC,MDbzC,yDCawG,CAAC,2FDbzG7T,mBAAA,YAAAA,oBAAA,WAAAlD,OAAA,SAAAA,OAAA,OAAAmD,EAAA,GAAA3B,MAAA,CAAAb,SAAA,EAAAyC,MAAA,GAAAD,EAAA,CAAAE,cAAA,EAAAC,cAAA,GAAA9B,MAAA,CAAA8B,cAAA,cAAAlD,GAAA,EAAAmD,GAAA,EAAAC,IAAA,IAAApD,GAAA,CAAAmD,GAAA,IAAAC,IAAA,CAAAV,KAAA,KAAAW,OAAA,wBAAAjD,MAAA,GAAAA,MAAA,OAAAkD,cAAA,GAAAD,OAAA,CAAAhD,QAAA,kBAAAkD,mBAAA,GAAAF,OAAA,CAAAG,aAAA,uBAAAC,iBAAA,GAAAJ,OAAA,CAAAK,WAAA,8BAAAC,OAAA3D,GAAA,EAAAmD,GAAA,EAAAT,KAAA,WAAAtB,MAAA,CAAA8B,cAAA,CAAAlD,GAAA,EAAAmD,GAAA,IAAAT,KAAA,EAAAA,KAAA,EAAAkB,UAAA,MAAAC,YAAA,MAAAC,QAAA,SAAA9D,GAAA,CAAAmD,GAAA,WAAAQ,MAAA,mBAAAhB,GAAA,IAAAgB,MAAA,YAAAA,OAAA3D,GAAA,EAAAmD,GAAA,EAAAT,KAAA,WAAA1C,GAAA,CAAAmD,GAAA,IAAAT,KAAA,gBAAAqB,KAAAC,OAAA,EAAAC,OAAA,EAAAC,IAAA,EAAAC,WAAA,QAAAC,cAAA,GAAAH,OAAA,IAAAA,OAAA,CAAA1D,SAAA,YAAA8D,SAAA,GAAAJ,OAAA,GAAAI,SAAA,EAAAC,SAAA,GAAAlD,MAAA,CAAAmD,MAAA,CAAAH,cAAA,CAAA7D,SAAA,GAAAiE,OAAA,OAAAC,OAAA,CAAAN,WAAA,gBAAAjB,cAAA,CAAAoB,SAAA,eAAA5B,KAAA,EAAAgC,gBAAA,CAAAV,OAAA,EAAAE,IAAA,EAAAM,OAAA,MAAAF,SAAA,aAAAK,SAAAC,EAAA,EAAA5E,GAAA,EAAA6E,GAAA,mBAAAC,IAAA,YAAAD,GAAA,EAAAD,EAAA,CAAAtD,IAAA,CAAAtB,GAAA,EAAA6E,GAAA,cAAAlC,GAAA,aAAAmC,IAAA,WAAAD,GAAA,EAAAlC,GAAA,QAAA/C,OAAA,CAAAmE,IAAA,GAAAA,IAAA,MAAAgB,gBAAA,gBAAAV,UAAA,cAAAW,kBAAA,cAAAC,2BAAA,SAAAC,iBAAA,OAAAvB,MAAA,CAAAuB,iBAAA,EAAA5B,cAAA,qCAAA6B,QAAA,GAAA/D,MAAA,CAAAgE,cAAA,EAAAC,uBAAA,GAAAF,QAAA,IAAAA,QAAA,CAAAA,QAAA,CAAAG,MAAA,QAAAD,uBAAA,IAAAA,uBAAA,KAAAtC,EAAA,IAAAC,MAAA,CAAA1B,IAAA,CAAA+D,uBAAA,EAAA/B,cAAA,MAAA4B,iBAAA,GAAAG,uBAAA,OAAAE,EAAA,GAAAN,0BAAA,CAAA1E,SAAA,GAAA8D,SAAA,CAAA9D,SAAA,GAAAa,MAAA,CAAAmD,MAAA,CAAAW,iBAAA,YAAAM,sBAAAjF,SAAA,gCAAAkF,OAAA,WAAAC,MAAA,IAAA/B,MAAA,CAAApD,SAAA,EAAAmF,MAAA,YAAAb,GAAA,gBAAAc,OAAA,CAAAD,MAAA,EAAAb,GAAA,sBAAAe,cAAAtB,SAAA,EAAAuB,WAAA,aAAAC,OAAAJ,MAAA,EAAAb,GAAA,EAAAkB,OAAA,EAAAC,MAAA,QAAAC,MAAA,GAAAtB,QAAA,CAAAL,SAAA,CAAAoB,MAAA,GAAApB,SAAA,EAAAO,GAAA,mBAAAoB,MAAA,CAAAnB,IAAA,QAAAoB,MAAA,GAAAD,MAAA,CAAApB,GAAA,EAAAnC,KAAA,GAAAwD,MAAA,CAAAxD,KAAA,SAAAA,KAAA,gBAAAvC,OAAA,CAAAuC,KAAA,KAAAM,MAAA,CAAA1B,IAAA,CAAAoB,KAAA,eAAAmD,WAAA,CAAAE,OAAA,CAAArD,KAAA,CAAAyD,OAAA,EAAAC,IAAA,WAAA1D,KAAA,IAAAoD,MAAA,SAAApD,KAAA,EAAAqD,OAAA,EAAAC,MAAA,gBAAArD,GAAA,IAAAmD,MAAA,UAAAnD,GAAA,EAAAoD,OAAA,EAAAC,MAAA,QAAAH,WAAA,CAAAE,OAAA,CAAArD,KAAA,EAAA0D,IAAA,WAAAC,SAAA,IAAAH,MAAA,CAAAxD,KAAA,GAAA2D,SAAA,EAAAN,OAAA,CAAAG,MAAA,gBAAAI,KAAA,WAAAR,MAAA,UAAAQ,KAAA,EAAAP,OAAA,EAAAC,MAAA,SAAAA,MAAA,CAAAC,MAAA,CAAApB,GAAA,SAAA0B,eAAA,EAAArD,cAAA,oBAAAR,KAAA,WAAAA,MAAAgD,MAAA,EAAAb,GAAA,aAAA2B,2BAAA,eAAAX,WAAA,WAAAE,OAAA,EAAAC,MAAA,IAAAF,MAAA,CAAAJ,MAAA,EAAAb,GAAA,EAAAkB,OAAA,EAAAC,MAAA,gBAAAO,eAAA,GAAAA,eAAA,GAAAA,eAAA,CAAAH,IAAA,CAAAI,0BAAA,EAAAA,0BAAA,IAAAA,0BAAA,qBAAA9B,iBAAAV,OAAA,EAAAE,IAAA,EAAAM,OAAA,QAAAiC,KAAA,sCAAAf,MAAA,EAAAb,GAAA,wBAAA4B,KAAA,YAAAC,KAAA,sDAAAD,KAAA,oBAAAf,MAAA,QAAAb,GAAA,SAAA8B,UAAA,WAAAnC,OAAA,CAAAkB,MAAA,GAAAA,MAAA,EAAAlB,OAAA,CAAAK,GAAA,GAAAA,GAAA,UAAA+B,QAAA,GAAApC,OAAA,CAAAoC,QAAA,MAAAA,QAAA,QAAAC,cAAA,GAAAC,mBAAA,CAAAF,QAAA,EAAApC,OAAA,OAAAqC,cAAA,QAAAA,cAAA,KAAA9B,gBAAA,mBAAA8B,cAAA,qBAAArC,OAAA,CAAAkB,MAAA,EAAAlB,OAAA,CAAAuC,IAAA,GAAAvC,OAAA,CAAAwC,KAAA,GAAAxC,OAAA,CAAAK,GAAA,sBAAAL,OAAA,CAAAkB,MAAA,6BAAAe,KAAA,QAAAA,KAAA,gBAAAjC,OAAA,CAAAK,GAAA,EAAAL,OAAA,CAAAyC,iBAAA,CAAAzC,OAAA,CAAAK,GAAA,uBAAAL,OAAA,CAAAkB,MAAA,IAAAlB,OAAA,CAAA0C,MAAA,WAAA1C,OAAA,CAAAK,GAAA,GAAA4B,KAAA,oBAAAR,MAAA,GAAAtB,QAAA,CAAAX,OAAA,EAAAE,IAAA,EAAAM,OAAA,oBAAAyB,MAAA,CAAAnB,IAAA,QAAA2B,KAAA,GAAAjC,OAAA,CAAAhC,IAAA,mCAAAyD,MAAA,CAAApB,GAAA,KAAAE,gBAAA,qBAAArC,KAAA,EAAAuD,MAAA,CAAApB,GAAA,EAAArC,IAAA,EAAAgC,OAAA,CAAAhC,IAAA,kBAAAyD,MAAA,CAAAnB,IAAA,KAAA2B,KAAA,gBAAAjC,OAAA,CAAAkB,MAAA,YAAAlB,OAAA,CAAAK,GAAA,GAAAoB,MAAA,CAAApB,GAAA,mBAAAiC,oBAAAF,QAAA,EAAApC,OAAA,QAAA2C,UAAA,GAAA3C,OAAA,CAAAkB,MAAA,EAAAA,MAAA,GAAAkB,QAAA,CAAAvG,QAAA,CAAA8G,UAAA,OAAAC,SAAA,KAAA1B,MAAA,SAAAlB,OAAA,CAAAoC,QAAA,qBAAAO,UAAA,IAAAP,QAAA,CAAAvG,QAAA,CAAAuC,MAAA,KAAA4B,OAAA,CAAAkB,MAAA,aAAAlB,OAAA,CAAAK,GAAA,GAAAuC,SAAA,EAAAN,mBAAA,CAAAF,QAAA,EAAApC,OAAA,eAAAA,OAAA,CAAAkB,MAAA,kBAAAyB,UAAA,KAAA3C,OAAA,CAAAkB,MAAA,YAAAlB,OAAA,CAAAK,GAAA,OAAA9D,SAAA,uCAAAoG,UAAA,iBAAApC,gBAAA,MAAAkB,MAAA,GAAAtB,QAAA,CAAAe,MAAA,EAAAkB,QAAA,CAAAvG,QAAA,EAAAmE,OAAA,CAAAK,GAAA,mBAAAoB,MAAA,CAAAnB,IAAA,SAAAN,OAAA,CAAAkB,MAAA,YAAAlB,OAAA,CAAAK,GAAA,GAAAoB,MAAA,CAAApB,GAAA,EAAAL,OAAA,CAAAoC,QAAA,SAAA7B,gBAAA,MAAAsC,IAAA,GAAApB,MAAA,CAAApB,GAAA,SAAAwC,IAAA,GAAAA,IAAA,CAAA7E,IAAA,IAAAgC,OAAA,CAAAoC,QAAA,CAAAU,UAAA,IAAAD,IAAA,CAAA3E,KAAA,EAAA8B,OAAA,CAAAjC,IAAA,GAAAqE,QAAA,CAAAW,OAAA,eAAA/C,OAAA,CAAAkB,MAAA,KAAAlB,OAAA,CAAAkB,MAAA,WAAAlB,OAAA,CAAAK,GAAA,GAAAuC,SAAA,GAAA5C,OAAA,CAAAoC,QAAA,SAAA7B,gBAAA,IAAAsC,IAAA,IAAA7C,OAAA,CAAAkB,MAAA,YAAAlB,OAAA,CAAAK,GAAA,OAAA9D,SAAA,sCAAAyD,OAAA,CAAAoC,QAAA,SAAA7B,gBAAA,cAAAyC,aAAAC,IAAA,QAAAC,KAAA,KAAAC,MAAA,EAAAF,IAAA,YAAAA,IAAA,KAAAC,KAAA,CAAAE,QAAA,GAAAH,IAAA,WAAAA,IAAA,KAAAC,KAAA,CAAAG,UAAA,GAAAJ,IAAA,KAAAC,KAAA,CAAAI,QAAA,GAAAL,IAAA,WAAAM,UAAA,CAAAtF,IAAA,CAAAiF,KAAA,cAAAM,cAAAN,KAAA,QAAAzB,MAAA,GAAAyB,KAAA,CAAAO,UAAA,QAAAhC,MAAA,CAAAnB,IAAA,oBAAAmB,MAAA,CAAApB,GAAA,EAAA6C,KAAA,CAAAO,UAAA,GAAAhC,MAAA,aAAAxB,QAAAN,WAAA,SAAA4D,UAAA,MAAAJ,MAAA,aAAAxD,WAAA,CAAAsB,OAAA,CAAA+B,YAAA,cAAAU,KAAA,iBAAA5C,OAAA6C,QAAA,QAAAA,QAAA,QAAAC,cAAA,GAAAD,QAAA,CAAA7E,cAAA,OAAA8E,cAAA,SAAAA,cAAA,CAAA9G,IAAA,CAAA6G,QAAA,4BAAAA,QAAA,CAAA5F,IAAA,SAAA4F,QAAA,OAAAE,KAAA,CAAAF,QAAA,CAAAtG,MAAA,SAAAnB,CAAA,OAAA6B,IAAA,YAAAA,KAAA,aAAA7B,CAAA,GAAAyH,QAAA,CAAAtG,MAAA,OAAAmB,MAAA,CAAA1B,IAAA,CAAA6G,QAAA,EAAAzH,CAAA,UAAA6B,IAAA,CAAAG,KAAA,GAAAyF,QAAA,CAAAzH,CAAA,GAAA6B,IAAA,CAAAC,IAAA,OAAAD,IAAA,SAAAA,IAAA,CAAAG,KAAA,GAAA0E,SAAA,EAAA7E,IAAA,CAAAC,IAAA,OAAAD,IAAA,YAAAA,IAAA,CAAAA,IAAA,GAAAA,IAAA,eAAAA,IAAA,EAAAoE,UAAA,eAAAA,WAAA,aAAAjE,KAAA,EAAA0E,SAAA,EAAA5E,IAAA,iBAAAwC,iBAAA,CAAAzE,SAAA,GAAA0E,0BAAA,EAAA/B,cAAA,CAAAqC,EAAA,mBAAA7C,KAAA,EAAAuC,0BAAA,EAAApB,YAAA,SAAAX,cAAA,CAAA+B,0BAAA,mBAAAvC,KAAA,EAAAsC,iBAAA,EAAAnB,YAAA,SAAAmB,iBAAA,CAAAsD,WAAA,GAAA3E,MAAA,CAAAsB,0BAAA,EAAAxB,iBAAA,wBAAA7D,OAAA,CAAA2I,mBAAA,aAAAC,MAAA,QAAAC,IAAA,wBAAAD,MAAA,IAAAA,MAAA,CAAAlI,WAAA,WAAAmI,IAAA,KAAAA,IAAA,KAAAzD,iBAAA,6BAAAyD,IAAA,CAAAH,WAAA,IAAAG,IAAA,CAAAjH,IAAA,OAAA5B,OAAA,CAAA8I,IAAA,aAAAF,MAAA,WAAApH,MAAA,CAAAuH,cAAA,GAAAvH,MAAA,CAAAuH,cAAA,CAAAH,MAAA,EAAAvD,0BAAA,KAAAuD,MAAA,CAAAI,SAAA,GAAA3D,0BAAA,EAAAtB,MAAA,CAAA6E,MAAA,EAAA/E,iBAAA,yBAAA+E,MAAA,CAAAjI,SAAA,GAAAa,MAAA,CAAAmD,MAAA,CAAAgB,EAAA,GAAAiD,MAAA,KAAA5I,OAAA,CAAAiJ,KAAA,aAAAhE,GAAA,aAAAsB,OAAA,EAAAtB,GAAA,OAAAW,qBAAA,CAAAI,aAAA,CAAArF,SAAA,GAAAoD,MAAA,CAAAiC,aAAA,CAAArF,SAAA,EAAAgD,mBAAA,iCAAA3D,OAAA,CAAAgG,aAAA,GAAAA,aAAA,EAAAhG,OAAA,CAAAkJ,KAAA,aAAA9E,OAAA,EAAAC,OAAA,EAAAC,IAAA,EAAAC,WAAA,EAAA0B,WAAA,eAAAA,WAAA,KAAAA,WAAA,GAAAkD,OAAA,OAAAC,IAAA,OAAApD,aAAA,CAAA7B,IAAA,CAAAC,OAAA,EAAAC,OAAA,EAAAC,IAAA,EAAAC,WAAA,GAAA0B,WAAA,UAAAjG,OAAA,CAAA2I,mBAAA,CAAAtE,OAAA,IAAA+E,IAAA,GAAAA,IAAA,CAAAzG,IAAA,GAAA6D,IAAA,WAAAF,MAAA,WAAAA,MAAA,CAAA1D,IAAA,GAAA0D,MAAA,CAAAxD,KAAA,GAAAsG,IAAA,CAAAzG,IAAA,WAAAiD,qBAAA,CAAAD,EAAA,GAAA5B,MAAA,CAAA4B,EAAA,EAAA9B,iBAAA,gBAAAE,MAAA,CAAA4B,EAAA,EAAAjC,cAAA,iCAAAK,MAAA,CAAA4B,EAAA,6DAAA3F,OAAA,CAAAqJ,IAAA,aAAAC,GAAA,QAAAC,MAAA,GAAA/H,MAAA,CAAA8H,GAAA,GAAAD,IAAA,gBAAA9F,GAAA,IAAAgG,MAAA,EAAAF,IAAA,CAAAxG,IAAA,CAAAU,GAAA,UAAA8F,IAAA,CAAAG,OAAA,aAAA7G,KAAA,WAAA0G,IAAA,CAAApH,MAAA,SAAAsB,GAAA,GAAA8F,IAAA,CAAAI,GAAA,QAAAlG,GAAA,IAAAgG,MAAA,SAAA5G,IAAA,CAAAG,KAAA,GAAAS,GAAA,EAAAZ,IAAA,CAAAC,IAAA,OAAAD,IAAA,WAAAA,IAAA,CAAAC,IAAA,OAAAD,IAAA,QAAA3C,OAAA,CAAA0F,MAAA,GAAAA,MAAA,EAAAb,OAAA,CAAAlE,SAAA,KAAAD,WAAA,EAAAmE,OAAA,EAAAyD,KAAA,WAAAA,MAAAoB,aAAA,aAAAC,IAAA,WAAAhH,IAAA,WAAAwE,IAAA,QAAAC,KAAA,GAAAI,SAAA,OAAA5E,IAAA,YAAAoE,QAAA,cAAAlB,MAAA,gBAAAb,GAAA,GAAAuC,SAAA,OAAAW,UAAA,CAAAtC,OAAA,CAAAuC,aAAA,IAAAsB,aAAA,WAAA9H,IAAA,kBAAAA,IAAA,CAAAgI,MAAA,OAAAxG,MAAA,CAAA1B,IAAA,OAAAE,IAAA,MAAA6G,KAAA,EAAA7G,IAAA,CAAAD,KAAA,cAAAC,IAAA,IAAA4F,SAAA,MAAAqC,IAAA,WAAAA,KAAA,SAAAjH,IAAA,WAAAkH,UAAA,QAAA3B,UAAA,IAAAE,UAAA,kBAAAyB,UAAA,CAAA5E,IAAA,QAAA4E,UAAA,CAAA7E,GAAA,cAAA8E,IAAA,KAAA1C,iBAAA,WAAAA,kBAAA2C,SAAA,aAAApH,IAAA,QAAAoH,SAAA,MAAApF,OAAA,kBAAAqF,OAAAC,GAAA,EAAAC,MAAA,WAAA9D,MAAA,CAAAnB,IAAA,YAAAmB,MAAA,CAAApB,GAAA,GAAA+E,SAAA,EAAApF,OAAA,CAAAjC,IAAA,GAAAuH,GAAA,EAAAC,MAAA,KAAAvF,OAAA,CAAAkB,MAAA,WAAAlB,OAAA,CAAAK,GAAA,GAAAuC,SAAA,KAAA2C,MAAA,aAAArJ,CAAA,QAAAqH,UAAA,CAAAlG,MAAA,MAAAnB,CAAA,SAAAA,CAAA,QAAAgH,KAAA,QAAAK,UAAA,CAAArH,CAAA,GAAAuF,MAAA,GAAAyB,KAAA,CAAAO,UAAA,iBAAAP,KAAA,CAAAC,MAAA,SAAAkC,MAAA,aAAAnC,KAAA,CAAAC,MAAA,SAAA4B,IAAA,QAAAS,QAAA,GAAAhH,MAAA,CAAA1B,IAAA,CAAAoG,KAAA,eAAAuC,UAAA,GAAAjH,MAAA,CAAA1B,IAAA,CAAAoG,KAAA,qBAAAsC,QAAA,IAAAC,UAAA,aAAAV,IAAA,GAAA7B,KAAA,CAAAE,QAAA,SAAAiC,MAAA,CAAAnC,KAAA,CAAAE,QAAA,gBAAA2B,IAAA,GAAA7B,KAAA,CAAAG,UAAA,SAAAgC,MAAA,CAAAnC,KAAA,CAAAG,UAAA,cAAAmC,QAAA,aAAAT,IAAA,GAAA7B,KAAA,CAAAE,QAAA,SAAAiC,MAAA,CAAAnC,KAAA,CAAAE,QAAA,qBAAAqC,UAAA,YAAAvD,KAAA,qDAAA6C,IAAA,GAAA7B,KAAA,CAAAG,UAAA,SAAAgC,MAAA,CAAAnC,KAAA,CAAAG,UAAA,YAAAX,MAAA,WAAAA,OAAApC,IAAA,EAAAD,GAAA,aAAAnE,CAAA,QAAAqH,UAAA,CAAAlG,MAAA,MAAAnB,CAAA,SAAAA,CAAA,QAAAgH,KAAA,QAAAK,UAAA,CAAArH,CAAA,OAAAgH,KAAA,CAAAC,MAAA,SAAA4B,IAAA,IAAAvG,MAAA,CAAA1B,IAAA,CAAAoG,KAAA,wBAAA6B,IAAA,GAAA7B,KAAA,CAAAG,UAAA,QAAAqC,YAAA,GAAAxC,KAAA,aAAAwC,YAAA,iBAAApF,IAAA,mBAAAA,IAAA,KAAAoF,YAAA,CAAAvC,MAAA,IAAA9C,GAAA,IAAAA,GAAA,IAAAqF,YAAA,CAAArC,UAAA,KAAAqC,YAAA,cAAAjE,MAAA,GAAAiE,YAAA,GAAAA,YAAA,CAAAjC,UAAA,cAAAhC,MAAA,CAAAnB,IAAA,GAAAA,IAAA,EAAAmB,MAAA,CAAApB,GAAA,GAAAA,GAAA,EAAAqF,YAAA,SAAAxE,MAAA,gBAAAnD,IAAA,GAAA2H,YAAA,CAAArC,UAAA,EAAA9C,gBAAA,SAAAoF,QAAA,CAAAlE,MAAA,MAAAkE,QAAA,WAAAA,SAAAlE,MAAA,EAAA6B,QAAA,oBAAA7B,MAAA,CAAAnB,IAAA,QAAAmB,MAAA,CAAApB,GAAA,qBAAAoB,MAAA,CAAAnB,IAAA,mBAAAmB,MAAA,CAAAnB,IAAA,QAAAvC,IAAA,GAAA0D,MAAA,CAAApB,GAAA,gBAAAoB,MAAA,CAAAnB,IAAA,SAAA6E,IAAA,QAAA9E,GAAA,GAAAoB,MAAA,CAAApB,GAAA,OAAAa,MAAA,kBAAAnD,IAAA,yBAAA0D,MAAA,CAAAnB,IAAA,IAAAgD,QAAA,UAAAvF,IAAA,GAAAuF,QAAA,GAAA/C,gBAAA,KAAAqF,MAAA,WAAAA,OAAAvC,UAAA,aAAAnH,CAAA,QAAAqH,UAAA,CAAAlG,MAAA,MAAAnB,CAAA,SAAAA,CAAA,QAAAgH,KAAA,QAAAK,UAAA,CAAArH,CAAA,OAAAgH,KAAA,CAAAG,UAAA,KAAAA,UAAA,cAAAsC,QAAA,CAAAzC,KAAA,CAAAO,UAAA,EAAAP,KAAA,CAAAI,QAAA,GAAAE,aAAA,CAAAN,KAAA,GAAA3C,gBAAA,OAAAsF,KAAA,WAAAC,OAAA3C,MAAA,aAAAjH,CAAA,QAAAqH,UAAA,CAAAlG,MAAA,MAAAnB,CAAA,SAAAA,CAAA,QAAAgH,KAAA,QAAAK,UAAA,CAAArH,CAAA,OAAAgH,KAAA,CAAAC,MAAA,KAAAA,MAAA,QAAA1B,MAAA,GAAAyB,KAAA,CAAAO,UAAA,kBAAAhC,MAAA,CAAAnB,IAAA,QAAAyF,MAAA,GAAAtE,MAAA,CAAApB,GAAA,EAAAmD,aAAA,CAAAN,KAAA,YAAA6C,MAAA,gBAAA7D,KAAA,8BAAA8D,aAAA,WAAAA,cAAArC,QAAA,EAAAb,UAAA,EAAAC,OAAA,gBAAAX,QAAA,KAAAvG,QAAA,EAAAiF,MAAA,CAAA6C,QAAA,GAAAb,UAAA,EAAAA,UAAA,EAAAC,OAAA,EAAAA,OAAA,oBAAA7B,MAAA,UAAAb,GAAA,GAAAuC,SAAA,GAAArC,gBAAA,OAAAnF,OAAA;AFYA,AEZA,EEcE,EDAE,IAAI8W,CDdRjM,MCce,EAAE,WDdjBC,GAAA,EAAA3E,OAAA,EAAAC,MAAA,EAAA2E,KAAA,EAAAC,MAAA,EAAAzH,GAAA,EAAA0B,GAAA,cAAAwC,IAAA,GAAAqD,GAAA,CAAAvH,GAAA,EAAA0B,GAAA,OAAAnC,KAAA,GAAA2E,IAAA,CAAA3E,KAAA,WAAA4D,KAAA,IAAAN,MAAA,CAAAM,KAAA,iBAAAe,IAAA,CAAA7E,IAAA,IAAAuD,OAAA,CAAArD,KAAA,YAAAqG,OAAA,CAAAhD,OAAA,CAAArD,KAAA,EAAA0D,IAAA,CAAAuE,KAAA,EAAAC,MAAA;AFaA,AEbA,EEgBEgN,IDDI,GDfN/M,GEgBY,CDDC+L,ECCE9C,QDDQ,CAAC4C,CCCC,CAAC,CFhB1B9R,EAAA,ECe+B,CAAC,CAAC,CAAC,CAAC,GCCG,oBFhBtCV,IAAA,SAAA4G,IAAA,GAAAC,SAAA,aAAAhC,OAAA,WAAAhD,OAAA,EAAAC,MAAA,QAAA0E,GAAA,GAAA9F,EAAA,CAAAoG,KAAA,CAAA9G,IAAA,EAAA4G,IAAA,YAAAH,MAAAjI,KAAA,IAAA+H,kBAAA,CAAAC,GAAA,EAAA3E,OAAA,EAAAC,MAAA,EAAA2E,KAAA,EAAAC,MAAA,UAAAlI,KAAA,cAAAkI,OAAAjI,GAAA,IAAA8H,kBAAA,CAAAC,GAAA,EAAA3E,OAAA,EAAAC,MAAA,EAAA2E,KAAA,EAAAC,MAAA,WAAAjI,GAAA,KAAAgI,KAAA,CAAAvD,SAAA;AFcA,AEdA,ICgBI,ACCA,IAAI0Q,CFjBR7M,IEiBa,GAAGwB,CFjBhBtD,MAAA,CEiBwB,CAACqE,AFjBzBtC,cAAA,EEiByC,CAAC,KFjB1CjC,IAAA,GAAA7H,MAAA,CAAA6H,IAAA,CEiBkE,AFjBlEE,CEiBmE,KFjBnE,OAAA/H,MAAA,CAAA+J,qBAAA,QAAAC,OAAA,GAAAhK,MAAA,CAAA+J,qBAAA,CAAAhC,MAAA,GAAA+B,cAAA,KAAAE,OAAA,GAAAA,OAAA,CAAAC,MAAA,WAAAC,GAAA,WAAAlK,MAAA,CAAAmK,wBAAA,CAAApC,MAAA,EAAAmC,GAAA,EAAA1H,UAAA,OAAAqF,IAAA,CAAAxG,IAAA,CAAAuI,KAAA,CAAA/B,IAAA,EAAAmC,OAAA,YAAAnC,IAAA;AFeA,AEfA,ECiBE,ECCE,KAAK,AFlBTuC,IEkBa9K,CAAC,GAAG,CAAC,EAAEA,CAAC,EFlBrB+K,CEkBwBqM,KAAK,AFlB7B,CEkB8BjW,MAAM,EAAEnB,CAAC,EAAE,CFlBzCA,CEkB2C,AFlB3C,MAAAA,CAAA,GAAAqK,SAAA,CAAAlJ,MAAA,EAAAnB,CAAA,UAAAgL,MAAA,WAAAX,SAAA,CAAArK,CAAA,IAAAqK,SAAA,CAAArK,CAAA,QAAAA,CAAA,OAAAuK,OAAA,CAAA7J,MAAA,CAAAsK,MAAA,OAAAjG,OAAA,WAAAtC,GAAA,IAAAwI,eAAA,CAAAF,MAAA,EAAAtI,GAAA,EAAAuI,MAAA,CAAAvI,GAAA,SAAA/B,MAAA,CAAAwK,yBAAA,GAAAxK,MAAA,CAAAyK,gBAAA,CAAAJ,MAAA,EAAArK,MAAA,CAAAwK,yBAAA,CAAAF,MAAA,KAAAT,OAAA,CAAA7J,MAAA,CAAAsK,MAAA,GAAAjG,OAAA,WAAAtC,GAAA,IAAA/B,MAAA,CAAA8B,cAAA,CAAAuI,MAAA,EAAAtI,GAAA,EAAA/B,MAAA,CAAAmK,wBAAA,CAAAG,MAAA,EAAAvI,GAAA,iBAAAsI,MAAA;AFgBA,AEhBA,ECmBE,ICAI,GDAG,ADnBTE,CEmBUoL,EDAE,ICAI,CAACH,QFnBjB5W,EEmB2B,CAAC8X,AFnB5B,EAAA3U,GEmBiC,AFnBjC,CEmBkCzC,CAAC,AFnBnCgC,CEmBoC,CAAC2U,GFnBrC,CEmByC,CAAC,EFnB1ClU,GEmB+C4T,AFnB/C,GAAAjL,GEmBqD,CAAC2K,UFnBtD,CAAAtT,CEmBkE,EAAE,AFnBpE,EEmBsE,KFnBtEA,GAAA,IAAAnD,GAAA,IAAAoB,MAAA,CAAA8B,cAAA,CAAAlD,GAAA,EAAAmD,GAAA,IAAAT,KAAA,EAAAA,KAAA,EAAAkB,UAAA,QAAAC,YAAA,QAAAC,QAAA,oBAAA9D,GAAA,CAAAmD,GAAA,IAAAT,KAAA,WAAA1C,GAAA;ACoBA,AHHA,AEjBA,QEoBQgX,CFpBRlL,SEoBkB,CAACgM,KAAK,AFpBxBjT,CEoByBnE,CAAC,CAAC,AFpB3B,CEoB4B,OFpB5ByC,GAAA,GAAA4I,YAAA,CAAAlH,GAAA,oBAAA1E,OAAA,CAAAgD,GAAA,iBAAAA,GAAA,GAAA6I,MAAA,CAAA7I,GAAA;ACsBA,AHJA,AElBA,MEqBM,GDCGyT,ADtBT7K,UCsBmB6K,CAACC,EDtBpB5K,CCsBuB,EAAE,EDtBzB,EAAAC,IAAA,QAAA/L,OAAA,CAAA8L,KAAA,kBAAAA,KAAA,kBAAAA,KAAA,MAAAE,IAAA,GAAAF,KAAA,CAAA7L,MAAA,CAAAgM,WAAA,OAAAD,IAAA,KAAA/E,SAAA,QAAAiF,GAAA,GAAAF,IAAA,CAAA7K,IAAA,CAAA2K,KAAA,EAAAC,IAAA,oBAAA/L,OAAA,CAAAkM,GAAA,uBAAAA,GAAA,YAAAtL,SAAA,4DAAAmL,IAAA,gBAAAF,MAAA,GAAAM,MAAA,EAAAL,KAAA;AFmBA,AEhBA,ECoBE,ECDE,AFnBAM,KCoBK,CAAC,EAAE,GAAGsK,GAAG,EAAEC,EDpBE,GAAG,CAAC,CCoBC,CAAC,gFAAgF,EAAE,IAAI,CAAC,GAAG,GAAG;AACzH,AHJA,AEhBA,IEoBIc,AFpBApL,UEoBU,AFpBA,GEoBG,AFpBA,CAAC,GEoBG;ADErB5M,AHLA,EIIE,CAAC,EAAE,EDCE,ACDA,CDCC6W,ACDA,YDCY,GAAGD,kBAAkB;AACzC5W,ACDA,AJJA,AEhBA,OCqBO,CAACgX,UAAU,GAAGA,UAAU;ACC/BjX,AJLA,AEhBA,CAAC,KEqBK,CAACC,MFrBK,CEqBE,GAAGiY,SAAS;AJJ1B,EEhBI;AFiBJ,EEhBI;AFiBJ;AACA,EEhBIpL,QAAQ,CAACC,cAAc,CAAC,mBAAmB,CAAC,CAACC,OAAO,GAAGC,iBAAiB;AFiB5E,EEhBIH,QAAQ,CAACC,cAAc,CAAC,aAAa,CAAC,CAACG,QAAQ,GAAGC,gBAAgB;AFiBtE,EEfI,IAAMC,YAAY,GAAGN,QAAQ,CAACC,cAAc,CAAC,aAAa,CAAC;AFgB/D,EEfI,IAAIM,UAAU,GAAGC,QAAQ,CAACF,YAAY,CAACrK,KAAK,CAAC,GAAC,GAAG;AFgBrD,EEdIwK,yBAAyB,CAACF,UAAU,CAAC;AFezC,EEbIG,oBAAoB,EAAE;AFc1B,EEbIV,QAAQ,CAACW,gBAAgB,CAAC,WAAW,EAACC,UAAU,CAAC;AFcrD,AEZA,CAAC,GAAG;AFaJ,AEVA,SAASC,cAAcA,CAAA,EACvB;AFUA,EETI,IAAIC,IAAI,GAAGd,QAAQ,CAACe,gBAAgB,CAAC,2BAA2B,CAAC;AFUrE,EETID,IAAI,CAAC9H,OAAO,CAAC,UAACgI,GAAG,EAAK;AFU1B,IETQ,IAAIC,QAAQ,GAACD,GAAG,CAACE,sBAAsB,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;AFUhE,IETQ,IAAIC,SAAS,GAACH,GAAG,CAACE,sBAAsB,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;AFUpE,IETQD,QAAQ,CAACG,KAAK,CAACC,KAAK,GAACF,SAAS,CAACG,WAAW,GAAC,EAAE,GAAC,IAAI;AFU1D,EETI,CAAC,CAAC;AFUN,EETIC,OAAO,CAACC,GAAG,CAACV,IAAI,CAAC;AFUrB,AETA;AFUA,AERA,SAASW,cAAcA,CAAA,EAAG;AFS1B,EERI,IAAMC,MAAM,GAAG1B,QAAQ,CAACe,gBAAgB,CAAC,gBAAgB,CAAC;AFS9D,EERIQ,OAAO,CAACC,GAAG,CAAC,SAAS,EAAEE,MAAM,CAAC;AFSlC,EERI,IAAIC,QAAQ,GAAG,CAAC;AFSpB,EEPID,MAAM,CAAC1I,OAAO,CAAC,UAAC4I,KAAK,EAAK;AFQ9B,IEPM,IAAMP,KAAK,GAAGO,KAAK,CAACN,WAAW;AFQrC,IEPMK,QAAQ,GAAGE,IAAI,CAACC,GAAG,CAACH,QAAQ,EAAEN,KAAK,CAAC;AFQ1C,IEPM,IAAMU,MAAM,GAAGH,KAAK,CAACI,YAAY;AFQvC,IEPMT,OAAO,CAACC,GAAG,iBAAAS,MAAA,CAAiBZ,KAAK,kBAAAY,MAAA,CAAeF,MAAM,QAAK;AFQjE,EEPI,CAAC,CAAC;AFQN,EENI,IAAIG,eAAe,GAAGlC,QAAQ,CAACC,cAAc,CAAC,OAAO,CAAC;AFO1D,EENI,IAAIkC,aAAa,GAAGnC,QAAQ,CAACC,cAAc,CAAC,OAAO,CAAC;AFOxD,EELIF,UAAU,GAAGmC,eAAe,CAACZ,WAAW,GAAGK,QAAQ;AFMvD,EELIJ,OAAO,CAACC,GAAG,CAAC,aAAa,EAAEzB,UAAU,CAAC;AFM1C,EELI,IAAIA,UAAU,IAAI,CAAC,EAAE;AFMzB,IELMA,UAAU,GAACA,UAAU,GAAE,IAAI;AFMjC,IELMoC,aAAa,CAACf,KAAK,CAACgB,SAAS,YAAAH,MAAA,CAAYlC,UAAU,MAAG;AFM5D,EELI,CAAC,MAAM;AFMX,IELMA,UAAU,GAACA,UAAU,GAAE,GAAG;AFMhC,IELMoC,aAAa,CAACf,KAAK,CAACgB,SAAS,YAAAH,MAAA,CAAYlC,UAAU,MAAG;AFM5D,EELI;AFMJ,EEJID,kBAAkB,GAAG,CAAC,GAAGC,UAAU;AFKvC,AEHE;AFIF,AEHA,SAASM,gBAAgBA,CAACgC,KAAK,EAAE;AFIjC,EEHId,OAAO,CAACC,GAAG,CAAC,aAAa,EAAEa,KAAK,CAAC;AFIrC,EEFI,IAAM/B,YAAY,GAAG+B,KAAK,CAACrD,MAAM;AFGrC,EEFIuC,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAElB,YAAY,CAAC;AFG/C,EEDI,IAAIC,UAAU,GAAGC,QAAQ,CAACF,YAAY,CAACrK,KAAK,CAAC,GAAC,GAAG;AFErD,EEAIwK,yBAAyB,CAACF,UAAU,CAAC;AFCzC,AEAA;AFCA,AECA,SAASE,yBAAyBA,CAACF,UAAU,EAAE;AFA/C,EEEI,IAAI4B,aAAa,GAAGnC,QAAQ,CAACC,cAAc,CAAC,OAAO,CAAC;AFDxD,EEEIkC,aAAa,CAACf,KAAK,CAACkB,eAAe,GAAG,SAAS;AFDnD,EEGIf,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAE5F,KAAK,CAAC2E,UAAU,CAAC,CAAC;AFFxD,EEGI,IAAG3E,KAAK,CAAC2E,UAAU,CAAC,EACpB;AFHJ,IEIQkB,cAAc,EAAE;AFHxB,EEII,CAAC,MAED;AFLJ,IEMQ3B,kBAAkB,GAAG,CAAC,GAAGS,UAAU;AFL3C,IEMQgB,OAAO,CAACC,GAAG,CAAC,qBAAqB,EAAE1B,kBAAkB,CAAC;AFL9D,IEMQqC,aAAa,CAACf,KAAK,CAACgB,SAAS,GAAG,QAAQ,GAAC7B,UAAU,GAAC,GAAG;AFL/D,EEMI;AFLJ,AEOA;AFNA,AEQA,SAASJ,iBAAiBA,CAAA,EAAG;AFP7B,EESIoB,OAAO,CAACC,GAAG,CAAC,aAAa,EAAEe,UAAU,CAAC;AFR1C,AEWA;AFVA,AEYA,IAAIC,OAAO,GAAG,KAAK;AFXnB,AEYA,IAAIC,iBAAiB,GAAG,IAAI;AFX5B,AEYA,IAAIC,oBAAoB,GAAG,IAAI;AFX/B,AEaA,IAAMC,OAAO,GAAA5D,aAAA;AFZb,EEaI6D,SAAS,EAAE,QAAQ;AFZvB,EEaIC,IAAI,EAAE;AFZV,IEaQC,CAAC,EAAE,CAAC;AFZZ,IEaQC,CAAC,EAAE,CAAC;AFZZ,IEaQC,KAAK,EAAE;AFZf,EEaI,CAAC;AFZL,EEaIC,UAAU,EAAE,MAAM;AFZtB,EEaIC,YAAY,EAAE,WAAW;AFZ7B,EEaIC,YAAY,EAAE,SAAS;AFZ3B,EEaIC,SAAS,EAAG;AFZhB,AEYqB,GAEdC,OAAO,CAEb;AFfD,AEiBA,IAAMA,OAAO,GAAG;AFhBhB,EEiBIC,MAAM,WAAAA,OAACC,QAAQ,EAAE;AFhBrB,IEiBQ;AFhBR,IEiBQhC,OAAO,CAACC,GAAG,CAAC,SAAS,EAAE+B,QAAQ,CAAC;AFhBxC,EEiBI,CAAC;AFhBL,EEiBIC,MAAM,WAAAA,OAAAC,IAAA,EAMH;AFtBP,IEsBO,IALCC,OAAO,GAAAD,IAAA,CAAPC,OAAO;AFhBf,MEiBQC,OAAO,GAAAF,IAAA,CAAPE,OAAO;AFhBf,MEiBQC,EAAE,GAAAH,IAAA,CAAFG,EAAE;AFhBV,MEiBQC,EAAE,GAAAJ,IAAA,CAAFI,EAAE;AFhBV,MEiBQzB,SAAS,GAAAqB,IAAA,CAATrB,SAAS;AFhBjB,IEkBQ;AFjBR,IEkBQb,OAAO,CAACC,GAAG,CAAC,SAAS,EAAEkC,OAAO,CAAC;AFjBvC,EEkBI,CAAC;AFjBL,EEkBII,QAAQ,WAAAA,SAAAC,KAAA,EAQL;AFzBP,IEyBO,IAPCL,OAAO,GAAAK,KAAA,CAAPL,OAAO;AFjBf,MEkBQC,OAAO,GAAAI,KAAA,CAAPJ,OAAO;AFjBf,MEkBQC,EAAE,GAAAG,KAAA,CAAFH,EAAE;AFjBV,MEkBQC,EAAE,GAAAE,KAAA,CAAFF,EAAE;AFjBV,MEkBQzB,SAAS,GAAA2B,KAAA,CAAT3B,SAAS;AFjBjB,MEkBQf,KAAK,GAAA0C,KAAA,CAAL1C,KAAK;AFjBb,MEkBQU,MAAM,GAAAgC,KAAA,CAANhC,MAAM;AFjBd,IEmBQ;AFlBR,IEmBQR,OAAO,CAACC,GAAG,CAAC,WAAW,EAAEkC,OAAO,CAAC;AFlBzC,EEmBI,CAAC;AFlBL,EEmBIM,QAAQ,WAAAA,SAAAC,KAAA,EAKL;AFvBP,IEuBO,IAJCP,OAAO,GAAAO,KAAA,CAAPP,OAAO;AFlBf,MEmBQC,OAAO,GAAAM,KAAA,CAAPN,OAAO;AFlBf,MEmBQO,KAAK,GAAAD,KAAA,CAALC,KAAK;AFlBb,MEmBQ9B,SAAS,GAAA6B,KAAA,CAAT7B,SAAS;AFlBjB,IEoBQ;AFnBR,IEoBQb,OAAO,CAACC,GAAG,CAAC,WAAW,EAAEkC,OAAO,CAAC;AFnBzC,EEoBI,CAAC;AFnBL,EEoBIS,MAAM,WAAAA,OAAAC,KAAA,EAGH;AFtBP,IEsBO,IAFCV,OAAO,GAAAU,KAAA,CAAPV,OAAO;AFnBf,MEoBQC,OAAO,GAAAS,KAAA,CAAPT,OAAO;AFnBf,IEqBQ;AFpBR,IEqBQpC,OAAO,CAACC,GAAG,CAAC,SAAS,EAAEkC,OAAO,CAAC;AFpBvC,EEqBI,CAAC;AFpBL,EEqBIW,SAAS,WAAAA,UAACC,EAAE,EAAE;AFpBlB,IEqBQ;AFpBR,IEqBQ/C,OAAO,CAACC,GAAG,CAAC,YAAY,EAAE8C,EAAE,CAAC;AFpBrC,EEqBI;AFpBJ,AEqBA,CAAC;AFpBD,AEsBA,IAAI/B,UAAU,GAAG,EAAE;AFrBnB,AEuBA,SAASgC,YAAYA,CAACC,CAAC,EAACF,EAAE,EAAC;AFtB3B,EEwBQ/C,OAAO,CAACC,GAAG,CAAC,WAAW,EAAEgD,CAAC,CAAC;AFvBnC,EEwBQjD,OAAO,CAACC,GAAG,CAAC,YAAY,EAAE8C,EAAE,CAAC;AFvBrC,EEwBQ;AFvBR,EEwBQ,IAAIG,MAAM,GAAGzE,QAAQ,CAACC,cAAc,CAAC,OAAO,CAAC;AFvBrD;AACA,EEwBQ;AFvBR,EEwBQ,IAAMyE,KAAK,GAAG,IAAAC,eAAK,EAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;AFvBxC,IEwBYC,MAAM,GAAGF,KAAK,CAACG,qBAAqB,EAAE;AFvBlD,IEwBYC,QAAQ,GAAG9E,QAAQ,CAAC+E,aAAa,CAAC,KAAK,CAAC;AFvBpD;AACA,EEwBQ;AFvBR,EEwBQD,QAAQ,CAACE,YAAY,CAAC,OAAO,EAAE,WAAW,CAAC;AFvBnD,EEwBQF,QAAQ,CAACE,YAAY,CAAC,aAAa,EAAER,CAAC,CAACxF,MAAM,CAACiG,EAAE,CAAC;AFvBzD,EEwBQH,QAAQ,CAAC1D,KAAK,CAAC8D,GAAG,MAAAjD,MAAA,CAAM,CAACuC,CAAC,CAACb,OAAO,GAAGiB,MAAM,CAACM,GAAG,IAAEpF,kBAAkB,OAAI;AFvB/E,EEwBQgF,QAAQ,CAAC1D,KAAK,CAAC+D,IAAI,MAAAlD,MAAA,CAAM,CAACuC,CAAC,CAACd,OAAO,GAAGkB,MAAM,CAACO,IAAI,IAAErF,kBAAkB,OAAI;AFvBjF,EEyBQyB,OAAO,CAACC,GAAG,CAAC,MAAM,EAAEgD,CAAC,CAACb,OAAO,EAAE,GAAG,EAAEiB,MAAM,CAACM,GAAG,EAAE,MAAM,EAAG,CAACV,CAAC,CAACb,OAAO,GAAGiB,MAAM,CAACM,GAAG,IAAIpF,kBAAkB,CAAE;AFxBhH,EEyBQyB,OAAO,CAACC,GAAG,CAAC,OAAO,EAAEgD,CAAC,CAACd,OAAO,EAAE,GAAG,EAAEkB,MAAM,CAACO,IAAI,EAAE,MAAM,EAAG,CAACX,CAAC,CAACd,OAAO,GAAGkB,MAAM,CAACO,IAAI,IAAIrF,kBAAkB,CAAE;AFxBnH,EE0BQ,IAAIsF,QAAQ,GAAGpF,QAAQ,CAAC+E,aAAa,CAAC,KAAK,CAAC;AFzBpD,EE0BQK,QAAQ,CAAChE,KAAK,CAACiE,UAAU,GAAG,8GAA8G;AFzBlJ,EE0BQD,QAAQ,CAAChE,KAAK,CAACkE,OAAO,GAAG,GAAG;AFzBpC,EE0BQF,QAAQ,CAAChE,KAAK,CAACmE,MAAM,GAAI,8BAA8B;AFzB/D,EE0BQH,QAAQ,CAAChE,KAAK,CAACoE,YAAY,GAAI,KAAK;AFzB5C,EE0BQJ,QAAQ,CAAChE,KAAK,CAACC,KAAK,GAAG,MAAM;AFzBrC,EE0BQ+D,QAAQ,CAAChE,KAAK,CAACW,MAAM,GAAI,MAAM;AFzBvC,EE2BQ,IAAM0D,iBAAiB,GAAGnB,EAAE,CAACoB,YAAY,CAAC,mBAAmB,CAAC;AF1BtE,EE2BQN,QAAQ,CAACH,EAAE,GAAGU,MAAM,CAACF,iBAAiB,CAAC;AF1B/C,EE4BQX,QAAQ,CAACc,WAAW,CAACR,QAAQ,CAAC;AF3BtC,EE4BQX,MAAM,CAACmB,WAAW,CAACd,QAAQ,CAAC;AF3BpC,EE6BQvC,UAAU,CAACvM,IAAI,CACX,IAAA2O,eAAK,EAACG,QAAQ,CAAC,CAACe,IAAI,CAAClD,OAAO,CAAC,CAChC;AF9BT,AEgCA;AF/BA,AEgCA,SAASmD,mBAAmBA,CAACpC,OAAO,EAACC,OAAO,EAACoC,SAAS,EACtD;AFhCA,EEkCQ;AFjCR,EEkCQ,IAAItB,MAAM,GAAGzE,QAAQ,CAACC,cAAc,CAAC,OAAO,CAAC;AFjCrD;AACA,EEkCQ;AFjCR,EEkCQ,IAAMyE,KAAK,GAAG,IAAAC,eAAK,EAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;AFjCxC,IEkCYC,MAAM,GAAGF,KAAK,CAACG,qBAAqB,EAAE;AFjClD,IEkCYC,QAAQ,GAAG9E,QAAQ,CAAC+E,aAAa,CAAC,KAAK,CAAC;AFjCpD;AACA,EEkCQ;AFjCR,EEkCQD,QAAQ,CAACE,YAAY,CAAC,OAAO,EAAE,WAAW,CAAC;AFjCnD,EEkCQF,QAAQ,CAACE,YAAY,CAAC,aAAa,EAAEe,SAAS,CAAC;AFjCvD,EEkCQjB,QAAQ,CAAC1D,KAAK,CAAC8D,GAAG,MAAAjD,MAAA,CAAM,CAAC0B,OAAO,GAAGiB,MAAM,CAACM,GAAG,IAAEpF,kBAAkB,OAAI;AFjC7E,EEkCQgF,QAAQ,CAAC1D,KAAK,CAAC+D,IAAI,MAAAlD,MAAA,CAAM,CAACyB,OAAO,GAAGkB,MAAM,CAACO,IAAI,IAAErF,kBAAkB,OAAI;AFjC/E,EEmCQyB,OAAO,CAACC,GAAG,CAAC,MAAM,EAAEmC,OAAO,EAAE,GAAG,EAAEiB,MAAM,CAACM,GAAG,EAAE,MAAM,EAAG,CAACvB,OAAO,GAAGiB,MAAM,CAACM,GAAG,IAAIpF,kBAAkB,CAAE;AFlC5G,EEmCQyB,OAAO,CAACC,GAAG,CAAC,OAAO,EAAEkC,OAAO,EAAE,GAAG,EAAEkB,MAAM,CAACO,IAAI,EAAE,MAAM,EAAG,CAACzB,OAAO,GAAGkB,MAAM,CAACO,IAAI,IAAIrF,kBAAkB,CAAE;AFlC/G,EEoCQ,IAAIsF,QAAQ,GAAGpF,QAAQ,CAAC+E,aAAa,CAAC,KAAK,CAAC;AFnCpD,EEoCQK,QAAQ,CAAChE,KAAK,CAACiE,UAAU,GAAG,8GAA8G;AFnClJ,EEoCQD,QAAQ,CAAChE,KAAK,CAACkE,OAAO,GAAG,GAAG;AFnCpC,EEoCQF,QAAQ,CAAChE,KAAK,CAACmE,MAAM,GAAI,8BAA8B;AFnC/D,EEoCQH,QAAQ,CAAChE,KAAK,CAACoE,YAAY,GAAI,KAAK;AFnC5C,EEoCQJ,QAAQ,CAAChE,KAAK,CAACC,KAAK,GAAG,MAAM;AFnCrC,EEoCQ+D,QAAQ,CAAChE,KAAK,CAACW,MAAM,GAAI,MAAM;AFnCvC,EEqCQ,IAAM0D,iBAAiB,GAAGnB,EAAE,CAACoB,YAAY,CAAC,mBAAmB,CAAC;AFpCtE,EEqCQN,QAAQ,CAACH,EAAE,GAAGU,MAAM,CAACF,iBAAiB,CAAC;AFpC/C,EEsCQX,QAAQ,CAACc,WAAW,CAACR,QAAQ,CAAC;AFrCtC,EEsCQX,MAAM,CAACmB,WAAW,CAACd,QAAQ,CAAC;AFrCpC,EEuCQvC,UAAU,CAACvM,IAAI,CACX,IAAA2O,eAAK,EAACG,QAAQ,CAAC,CAACe,IAAI,CAAClD,OAAO,CAAC,CAChC;AFxCT,AEyCA;AFxCA,AE0CA,IAAAgC,eAAK,EAAC,QAAQ,CAAC,CAACqB,KAAK,CAAC;AFzCtB,EE0CItB,KAAK,EAAE,YAAY;AFzCvB,EE0CIuB,QAAQ,EAAE,QAAQ;AFzCtB,EE0CI3C,MAAM,WAAAA,OAACgB,EAAE,EAAE;AFzCf,IE0CQ;AFzCR,IE0CQ/C,OAAO,CAACC,GAAG,CAAC,YAAY,CAAC;AFzCjC,EE0CI,CAAC;AFzCL,EE0CIgC,MAAM,WAAAA,OAACI,EAAE,EAAEC,EAAE,EAAE;AFzCnB,IE0CQ;AFzCR,IE0CQ;AFzCR,EEyCQ,CACH;AFzCL,EE0CIM,MAAM,WAAAA,OAACK,CAAC,EAAEF,EAAE,EAAE0B,KAAK,EAAE;AFzCzB,IE0CQ;AFzCR,IE0CQzE,OAAO,CAACC,GAAG,CAAC,WAAW,EAAEgD,CAAC,CAAC;AFzCnC,IE0CQjD,OAAO,CAACC,GAAG,CAAC,YAAY,EAAE8C,EAAE,CAAC;AFzCrC,IE0CQ/C,OAAO,CAACC,GAAG,CAAC,eAAe,EAAEwE,KAAK,CAAC;AFzC3C,IE0CQzB,YAAY,CAACC,CAAC,EAACF,EAAE,CAAC;AFzC1B,EE0CI,CAAC;AFzCL,EE0CID,SAAS,WAAAA,UAAA,EAAG;AFzChB,IE0CQ;AFzCR,EEyCQ;AFxCR,AE0CA,CAAC,CAAC;AFzCF,AE2CA,IAAAM,eAAK,EAAC,YAAY,CAAC,CAACuB,EAAE,CAAC,OAAO;AF1C9B,EE0C8B,IAAAC,KAAA,GAAA/H,iBAAA,eAAA/H,mBAAA,GAAA4F,IAAA,CAAE,SAAAmK,QAAOC,CAAC;AFzCxC,IEyCwC,IAAAzD,SAAA;AFxCxC,IEwCwC,OAAAvM,mBAAA,GAAAiB,IAAA,UAAAgP,SAAAC,QAAA;AFvCxC,MEuCwC,kBAAAA,QAAA,CAAAzJ,IAAA,GAAAyJ,QAAA,CAAAzQ,IAAA;AFtCxC,QEsCwC;AFrCxC,UEsCIyL,OAAO,CAACC,GAAG,CAAC,IAAI,EAAE6E,CAAC,CAAC;AFrCxB,UEsCI9E,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAEiB,iBAAiB,CAAC;AFrCxD,UEsCI,IAAGD,OAAO,IAAI,IAAI,EAClB;AFtCJ,YEuCQA,OAAO,GAAG,KAAK;AFtCvB,YEuCQ+B,YAAY,CAAC8B,CAAC,EAAC5D,iBAAiB,CAAC;AFtCzC,YEuCYG,SAAS,GAAC5C,QAAQ,CAACC,cAAc,CAAC,WAAW,CAAC;AFtC1D,YEuCQ2C,SAAS,CAAC4D,WAAW,CAAC9D,oBAAoB,CAAC;AFtCnD,UEuCI;AFtCJ,QEsCK;AFrCL,QEqCK;AFpCL,UEoCK,OAAA6D,QAAA,CAAAvJ,IAAA;AFnCL,MEmCK;AFlCL,IEkCK,GAAAoJ,OAAA;AFjCL,EEiCK,CACJ;AFjCD,EEiCC,iBAAA3Q,EAAA;AFhCD,IEgCC,OAAA0Q,KAAA,CAAA5H,KAAA,OAAAD,SAAA;AF/BD,EE+BC;AF9BD,AE8BC,IAAC;AF7BF,AEgCA,SAASsC,UAAUA,CAACyB,KAAK,EACzB;AFhCA,EEiCI;AFhCJ,EEiCI,IAAMoE,MAAM,GAAEpE,KAAK,CAACsB,OAAO;AFhC/B,EEiCI,IAAM+C,MAAM,GAAErE,KAAK,CAACqB,OAAO;AFhC/B,EEiCI,IAAIiD,OAAO,GAAC3G,QAAQ,CAACC,cAAc,CAAC,WAAW,CAAC;AFhCpD,EEiCI,IAAM2G,OAAO,GAAG,SAAVA,OAAOA,CAAGpC,CAAC;AFhCrB,IEgCqB,OAAIA,CAAC,CAACqC,aAAa,CAACC,aAAa,CAAC,QAAQ,CAAC,KAAKtC,CAAC;AF/BtE,EE+BsE;AF9BtE,EE+BI,IAAGhC,OAAO,IAAI,IAAI,IAAIoE,OAAO,CAACD,OAAO,CAAC,IAAIjE,oBAAoB,EAC9D;AF/BJ,IEgCQA,oBAAoB,CAACtB,KAAK,CAAC+D,IAAI,GAAGuB,MAAM,GAAG,IAAI;AF/BvD,IEgCQhE,oBAAoB,CAACtB,KAAK,CAAC8D,GAAG,GAAGuB,MAAM,GAAG,IAAI;AF/BtD,IEgCQ/D,oBAAoB,CAACtB,KAAK,CAAC2F,OAAO,GAAC,OAAO;AF/BlD,EEgCI,CAAC,MACI,IAAGrE,oBAAoB,EAC5B;AFjCJ,IEkCQA,oBAAoB,CAACtB,KAAK,CAAC2F,OAAO,GAAC,MAAM;AFjCjD,EEkCI;AFjCJ,AEmCA;AFlCA,AEoCA,IAAApC,eAAK,EAAC,QAAQ,CAAC,CAACuB,EAAE,CAAC,OAAO;AFnC1B,EEmC0B,IAAAc,KAAA,GAAA5I,iBAAA,eAAA/H,mBAAA,GAAA4F,IAAA,CAAE,SAAAgL,SAAOZ,CAAC;AFlCpC,IEkCoC,IAAA/B,EAAA,EAAA1B,SAAA,EAAAsE,UAAA;AFjCpC,IEiCoC,OAAA7Q,mBAAA,GAAAiB,IAAA,UAAA6P,UAAAC,SAAA;AFhCpC,MEgCoC,kBAAAA,SAAA,CAAAtK,IAAA,GAAAsK,SAAA,CAAAtR,IAAA;AF/BpC,QE+BoC;AF9BpC,UE+BIyL,OAAO,CAACC,GAAG,CAAC,IAAI,EAAE6E,CAAC,CAAC;AF9BxB,UE+BQ/B,EAAE,GAAC+B,CAAC,CAACrH,MAAM;AF9BnB,UE+BIuC,OAAO,CAACC,GAAG,CAAC,KAAK,EAAE8C,EAAE,CAAC;AF9B1B,UE+BI/C,OAAO,CAACC,GAAG,CAAC,QAAQ,CAAC;AF9BzB,UE+BI,IAAGgB,OAAO,IAAI,IAAI,EAClB;AF/BJ,YEgCQA,OAAO,GAAG,KAAK;AF/BvB,YEgCYI,SAAS,GAAC5C,QAAQ,CAACC,cAAc,CAAC,WAAW,CAAC;AF/B1D,YEgCQ2C,SAAS,CAAC4D,WAAW,CAAC9D,oBAAoB,CAAC;AF/BnD,UEgCI,CAAC,MAED;AFjCJ,YEkCQ2E,UAAU,CAAC,YAAI;AFjCvB,cEiCwB7E,OAAO,GAAG,IAAI;AFhCtC,YEgCuC,CAAC,EAAC,CAAC,CAAC;AF/B3C,YEiCQC,iBAAiB,GAAG6B,EAAE;AFhC9B,YEiCQ5B,oBAAoB,GAACD,iBAAiB,CAAC6E,SAAS,CAAC,IAAI,CAAC;AFhC9D,YEiCY1E,UAAS,GAAC5C,QAAQ,CAACC,cAAc,CAAC,WAAW,CAAC;AFhC1D,YEiCQyC,oBAAoB,CAACtB,KAAK,CAAC2F,OAAO,GAAC,MAAM;AFhCjD,YEiCQrE,oBAAoB,CAACtB,KAAK,CAACmG,QAAQ,GAAC,OAAO;AFhCnD,YEiCQ7E,oBAAoB,CAACtB,KAAK,CAACoG,aAAa,GAAC,MAAM;AFhCvD,YEkCQ5E,UAAS,CAACgD,WAAW,CAAClD,oBAAoB,CAAC;AFjCnD,UEmCI;AFlCJ,QEkCK;AFjCL,QEiCK;AFhCL,UEgCK,OAAA0E,SAAA,CAAApK,IAAA;AF/BL,ME+BK;AF9BL,IE8BK,GAAAiK,QAAA;AF7BL,EE6BK,CAEJ;AF9BD,EE8BC,iBAAAQ,GAAA;AF7BD,IE6BC,OAAAT,KAAA,CAAAzI,KAAA,OAAAD,SAAA;AF5BD,EE4BC;AF3BD,AE2BC,IAAC;AF1BF,AE4BA,IAAAqG,eAAK,EAAC,QAAQ,CAAC,CAACuB,EAAE,CAAC,UAAU,eAAA9H,iBAAA,eAAA/H,mBAAA,GAAA4F,IAAA,CAAE,SAAAyL,SAAA;AF3B/B,EE2B+B,IAClBC,WAAW,EAAA7G,IAAA,EAAA8B,SAAA,EAAAgF,YAAA,EAAAC,aAAA,EAAAC,cAAA,EAAAC,YAAA,EAAAC,YAAA,EAAAC,aAAA,EAAAC,MAAA,EAAAC,UAAA,EAAAC,YAAA;AF3BxB,EE2BwB,OAAA/R,mBAAA,GAAAiB,IAAA,UAAA+Q,UAAAC,SAAA;AF1BxB,IE0BwB,kBAAAA,SAAA,CAAAxL,IAAA,GAAAwL,SAAA,CAAAxS,IAAA;AFzBxB,MEyBwB;AFxBxB,QEwBa6R,WAAW,YAAAY,cAAC5B,OAAO,EAC5B;AFxBJ,UEyBQ,IAAI6B,WAAW,GAAE7B,OAAO,CAAC9B,qBAAqB,EAAE;AFxBxD,UEyBQ,IAAI4D,YAAY,GAACD,WAAW,CAACzF,CAAC;AFxBtC,UEyBQ,IAAI2F,UAAU,GAACF,WAAW,CAACzF,CAAC,GAAGyF,WAAW,CAACzG,MAAM;AFxBzD,UEyBQ,OAAO,CAAC0G,YAAY,EAACC,UAAU,CAAC;AFxBxC,QE0BI,CAAC;AFzBL,QE0BInH,OAAO,CAACC,GAAG,CAAC,cAAc,CAAC;AFzB/B,QE0BI;AFzBJ,QE0BQV,IAAI,GAAGd,QAAQ,CAACe,gBAAgB,CAAC,0BAA0B,CAAC;AFzBpE,QE0BQ6B,SAAS,GAAC5C,QAAQ,CAACC,cAAc,CAAC,WAAW,CAAC;AFzBtD,QEyBsD2H,YAAA,GAChBD,WAAW,CAAC/E,SAAS,CAAC,EAAAiF,aAAA,GAAA9T,cAAA,CAAA6T,YAAA,MAAnDE,cAAc,GAAAD,aAAA,KAACE,YAAY,GAAAF,aAAA;AFzBpC,QE0BQG,YAAY,GAACF,cAAc,GAAC,CAACC,YAAY,GAACD,cAAc,IAAE,CAAC;AFzBnE,QE2BQG,aAAa,GAAC,CAAC;AF1BvB,QE2BQC,MAAM,GAAC,IAAI;AF1BnB,QE2BIpH,IAAI,CAAC9H,OAAO,CAAC,UAACgI,GAAG,EAAK;AF1B1B,UE4BQ,IAAA2H,aAAA,GAA8BhB,WAAW,CAAC3G,GAAG,CAAC;AF3BtD,YE2BsD4H,aAAA,GAAA7U,cAAA,CAAA4U,aAAA;AF1BtD,YE0BaF,YAAY,GAAAG,aAAA;AFzBzB,YEyB0BF,UAAU,GAAAE,aAAA;AFxBpC,UEyBQrH,OAAO,CAACC,GAAG,CAACmG,WAAW,CAAC3G,GAAG,CAAC,CAAC;AFxBrC,UEyBQyH,YAAY,GAAC5G,IAAI,CAACC,GAAG,CAAC2G,YAAY,EAACX,cAAc,CAAC;AFxB1D,UEyBQY,UAAU,GAAC7G,IAAI,CAACgH,GAAG,CAACH,UAAU,EAACX,YAAY,CAAC;AFxBpD,UEyBQxG,OAAO,CAACC,GAAG,CAAC,cAAc,EAACiH,YAAY,CAAC;AFxBhD,UEyBQlH,OAAO,CAACC,GAAG,CAAC,YAAY,EAACkH,UAAU,CAAC;AFxB5C,UEyBQ,IAAGD,YAAY,GAACC,UAAU,EAC1B;AFzBR,YE0BY,IAAII,YAAY,GAACJ,UAAU,GAACD,YAAY;AFzBpD,YE0BY,IAAGK,YAAY,GAACb,aAAa,EAC7B;AF1BZ,cE2BgBA,aAAa,GAACa,YAAY;AF1B1C,cE2BgBZ,MAAM,GAAClH,GAAG;AF1B1B,YE2BY;AF1BZ,UE2BQ;AF1BR,QE2BI,CAAC,CAAC;AF1BN,QE2BIO,OAAO,CAACC,GAAG,CAAC,SAAS,CAAC;AF1B1B,QE2BID,OAAO,CAACC,GAAG,CAAC0G,MAAM,CAAC;AF1BvB,QE2BQC,UAAU,GAACD,MAAM,CAACrD,qBAAqB,EAAE;AF1BjD,QE2BQuD,YAAY,GAACvG,IAAI,CAACC,GAAG,CAACgG,cAAc,EAACK,UAAU,CAACpF,CAAC,CAAC;AF1B1D,QE2BI+C,mBAAmB,CAACqC,UAAU,CAACrF,CAAC,EAACsF,YAAY,EAACF,MAAM,CAACjD,EAAE,CAAC;AF1B5D,ME0B4D;AFzB5D,MEyB4D;AFxB5D,QEwB4D,OAAAqD,SAAA,CAAAtL,IAAA;AFvB5D,IEuB4D;AFtB5D,EEsB4D,GAAA0K,QAAA;AFrB5D,AEqB4D,CAE3D,GAAC;AFtBF,AEwBA,IAAA/C,eAAK,EAAC,gBAAgB,CAAC,CAACuB,EAAE,CAAC,OAAO;AFvBlC,EEuBkC,IAAA6C,KAAA,GAAA3K,iBAAA,eAAA/H,mBAAA,GAAA4F,IAAA,CAAC,SAAA+M,SAAO3C,CAAC;AFtB3C,IEsB2C,IAAAzD,SAAA;AFrB3C,IEqB2C,OAAAvM,mBAAA,GAAAiB,IAAA,UAAA2R,UAAAC,SAAA;AFpB3C,MEoB2C,kBAAAA,SAAA,CAAApM,IAAA,GAAAoM,SAAA,CAAApT,IAAA;AFnB3C,QEmB2C;AFlB3C,UEmBI,IAAG0M,OAAO,IAAI,IAAI,EAClB;AFnBJ,YEoBQA,OAAO,GAAG,KAAK;AFnBvB,YEoBYI,SAAS,GAAC5C,QAAQ,CAACC,cAAc,CAAC,WAAW,CAAC;AFnB1D,YEoBQ2C,SAAS,CAAC4D,WAAW,CAAC9D,oBAAoB,CAAC;AFnBnD,UEoBI;AFnBJ,QEmBK;AFlBL,QEkBK;AFjBL,UEiBK,OAAAwG,SAAA,CAAAlM,IAAA;AFhBL,MEgBK;AFfL,IEeK,GAAAgM,QAAA;AFdL,EEcK,CAEJ;AFfD,EEeC,iBAAAG,GAAA;AFdD,IEcC,OAAAJ,KAAA,CAAAxK,KAAA,OAAAD,SAAA;AFbD,EEaC;AFZD,AEYC,IAAC;AFXF,AEaA,SAASoC,oBAAoBA,CAAA,EAAG;AFZhC,EEaI,IAAI0I,IAAI,GAAGpJ,QAAQ,CAAC0B,MAAM;AFZ9B,IEaIvM,GAAG,GAAGiU,IAAI,CAAChU,MAAM;AFZrB,IEaIiU,OAAO,GAAG,CAAC;AFZf,EEcI,EAAE,CAACrQ,OAAO,CAACnE,IAAI,CAAEuU,IAAI,EAAE,UAAUE,GAAG,EAAG;AFb3C,IEcQ,IAAGA,GAAG,CAAC5L,QAAQ,EACf6L,gBAAgB,EAAE,CAAC,KAEnBD,GAAG,CAAC3I,gBAAgB,CAAE,MAAM,EAAE4I,gBAAgB,EAAE,KAAK,CAAE;AFhB/D,EEiBI,CAAC,CAAE;AFhBP,EEkBI,SAASA,gBAAgBA,CAAA,EAAG;AFjBhC,IEkBQF,OAAO,EAAE;AFjBjB,IEkBQ,IAAKA,OAAO,KAAKlU,GAAG,EAAG;AFjB/B,MEkBYoM,OAAO,CAACC,GAAG,CAAE,oBAAoB,CAAE;AFjB/C,MEkBYgI,UAAU,EAAE;AFjBxB,IEkBQ;AFjBR,EEkBI;AFjBJ,AEmBA;AFlBA,AEoBA,SAASA,UAAUA,CAAA,EAAG;AFnBtB,EEoBI;AFnBJ,EEoBI3I,cAAc,EAAE;AFnBpB,AEoBA;AFnBA,AEqBA,SAAS8E,MAAMA,CAAC8D,MAAM,EAAE;AFpBxB,EEqBI,IAAIhQ,MAAM,GAAG,EAAE;AFpBnB,EEqBI,IAAIiQ,UAAU,GACZ,gEAAgE;AFrBtE,EEsBI,IAAIC,gBAAgB,GAAGD,UAAU,CAACtU,MAAM;AFrB5C,EEsBI,KAAK,IAAInB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE;AFrBjC,IEsBMwF,MAAM,IAAIiQ,UAAU,CAAC3M,MAAM,CAAC8E,IAAI,CAAC+H,KAAK,CAAC/H,IAAI,CAACgI,MAAM,EAAE,GAAGF,gBAAgB,CAAC,CAAC;AFrB/E,EEsBI;AFrBJ,EEsBI,OAAOF,MAAM,GAAG,GAAG,GAAGhQ,MAAM;AFrBhC,AEsBA;AFrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"src.a2b27638.js","sourceRoot":"..","sourcesContent":["/*@license\n* Drag/Rotate/Resize Library\n* Released under the MIT license, 2018-2020\n* Karen Sarksyan\n* nichollascarter@gmail.com\n*/\n'use strict';\n\nconst requestAnimFrame = \r\n    window.requestAnimationFrame ||\r\n    window.mozRequestAnimationFrame ||\r\n    window.webkitRequestAnimationFrame ||\r\n    window.msRequestAnimationFrame ||\r\n    function (f) {\r\n        return setTimeout(f, 1000 / 60);\r\n    };\r\n\r\nconst cancelAnimFrame =\r\n    window.cancelAnimationFrame ||\r\n    window.mozCancelAnimationFrame ||\r\n    function (requestID) {\r\n        clearTimeout(requestID);\r\n    };\r\n\r\nconst {\r\n    forEach,\r\n    slice: arrSlice,\r\n    map: arrMap,\r\n    reduce: arrReduce\r\n} = Array.prototype;\r\n/* eslint-disable no-console */\r\nconst { warn } = console;\r\n/* eslint-disable no-console */\r\n\r\nfunction isDef(val) {\r\n    return val !== undefined && val !== null;\r\n}\r\n\r\nfunction isUndef(val) {\r\n    return val === undefined || val === null;\r\n}\r\n\r\nfunction isFunc(val) {\r\n    return typeof val === 'function';\r\n}\r\n\r\nfunction createMethod(fn) {\r\n    return isFunc(fn)\r\n        ? function () {\r\n            fn.call(this, ...arguments);\r\n        }\r\n        : () => { };\r\n}\n\nclass Helper {\n\n    constructor(params) {\n        if (typeof params === 'string') {\n            const selector = document.querySelectorAll(params);\n            this.length = selector.length;\n            for (let count = 0; count < this.length; count++) {\n                this[count] = selector[count];\n            }\n        } else if (typeof params === 'object' &&\n            (params.nodeType === 1 || params === document)) {\n            this[0] = params;\n            this.length = 1;\n        } else if (params instanceof Helper) {\n            this.length = params.length;\n            for (let count = 0; count < this.length; count++) {\n                this[count] = params[count];\n            }\n        } else if (isIterable(params)) {\n            this.length = 0;\n            for (let count = 0; count < this.length; count++) {\n                if (params.nodeType === 1) {\n                    this[count] = params[count];\n                    this.length++;\n                }\n            }\n        } else {\n            throw new Error(`Passed parameter must be selector/element/elementArray`);\n        }\n    }\n\n    css(prop) {\n        const _getStyle = obj => {\n            let len = obj.length;\n\n            while (len--) {\n                if (obj[len].currentStyle) {\n                    return obj[len].currentStyle[prop];\n                } else if (document.defaultView && document.defaultView.getComputedStyle) {\n                    return document.defaultView.getComputedStyle(obj[len], '')[prop];\n                } else {\n                    return obj[len].style[prop];\n                }\n            }\n        };\n\n        const _setStyle = (obj, options) => {\n            let len = obj.length;\n\n            while (len--) {\n                for (const property in options) {\n                    obj[len].style[property] = options[property];\n                }\n            }\n            return obj.style;\n        };\n\n        const methods = {\n            setStyle(options) {\n                return _setStyle(this, options);\n            },\n            getStyle() {\n                return _getStyle(this);\n            }\n        };\n\n        if (typeof prop === 'string') {\n            return methods.getStyle.apply(this, arrSlice.call(arguments, 1));\n        } else if (typeof prop === 'object' || !prop) {\n            return methods.setStyle.apply(this, arguments);\n        } else {\n            warn(`Method ${prop} does not exist`);\n        }\n        return false;\n    }\n\n    on() {\n        let len = this.length;\n\n        while (len--) {\n            if (!this[len].events) {\n                this[len].events = {};\n                this[len].events[arguments[0]] = [];\n            }\n\n            if (typeof (arguments[1]) !== 'string') {\n                if (document.addEventListener) {\n                    this[len].addEventListener(\n                        arguments[0], \n                        arguments[1], \n                        arguments[2] || { passive: false }\n                    );\n                } else if (document.attachEvent) {\n                    this[len].attachEvent(`on${arguments[0]}`, arguments[1]);\n                } else {\n                    this[len][`on${arguments[0]}`] = arguments[1];\n                }\n            } else {\n                listenerDelegate(\n                    this[len], \n                    arguments[0], \n                    arguments[1], \n                    arguments[2], \n                    arguments[3], \n                    true\n                );\n            }\n        }\n        return this;\n    }\n\n    off() {\n        let len = this.length;\n\n        while (len--) {\n            if (!this[len].events) {\n                this[len].events = {};\n                this[len].events[arguments[0]] = [];\n            }\n\n            if (typeof (arguments[1]) !== 'string') {\n                if (document.removeEventListener) {\n                    this[len].removeEventListener(arguments[0], arguments[1], arguments[2]);\n                } else if (document.detachEvent) {\n                    this[len].detachEvent(`on${arguments[0]}`, arguments[1]);\n                } else {\n                    this[len][`on${arguments[0]}`] = null;\n                }\n            } else {\n                listenerDelegate(this[len], arguments[0], arguments[1], arguments[2], arguments[3], false);\n            }\n        }\n\n        return this;\n    }\n\n    is(selector) {\n        if (isUndef(selector)) return false;\n        \n        const _sel = helper(selector);\n        let len = this.length;\n\n        while (len--) {\n            if (this[len] === _sel[len]) return true;\n        }\n        return false;\n    }\n\n}\n\nfunction listenerDelegate(el, evt, sel, handler, options, act) {\n    const doit = function (event) {\n        let t = event.target;\n        while (t && t !== this) {\n            if (t.matches(sel)) {\n                handler.call(t, event);\n            }\n            t = t.parentNode;\n        }\n    };\n\n    if (act === true) {\n        if (document.addEventListener) {\n            el.addEventListener(evt, doit, options || { passive: false });\n        } else if (document.attachEvent) {\n            el.attachEvent(`on${evt}`, doit);\n        } else {\n            el[`on${evt}`] = doit;\n        }\n    } else {\n        if (document.removeEventListener) {\n            el.removeEventListener(evt, doit, options || { passive: false });\n        } else if (document.detachEvent) {\n            el.detachEvent(`on${evt}`, doit);\n        } else {\n            el[`on${evt}`] = null;\n        }\n    }\n}\n\nfunction isIterable(obj) {\n    return isDef(obj) &&\n        typeof obj === 'object' &&\n        (\n            Array.isArray(obj) ||\n            (\n                isDef(window.Symbol) &&\n                typeof obj[window.Symbol.iterator] === 'function'\n            ) ||\n            isDef(obj.forEach) ||\n            (\n                typeof (obj.length) === \"number\" &&\n                (obj.length === 0 ||\n                    (obj.length > 0 &&\n                        (obj.length - 1) in obj)\n                )\n            )\n        );\n}\n\nfunction helper(params) {\n    return new Helper(params);\n}\n\nclass Observable {\r\n\r\n    constructor() {\n        this.observers = {};\n    }\r\n\r\n    subscribe(eventName, sub) {\n        const obs = this.observers;\r\n\r\n        if (isUndef(obs[eventName])) {\n            Object.defineProperty(obs, eventName, {\r\n                value: []\r\n            });\n        }\r\n\r\n        obs[eventName].push(sub);\r\n\r\n        return this;\n    }\r\n\r\n    unsubscribe(eventName, f) {\n        const obs = this.observers;\r\n\r\n        if (isDef(obs[eventName])) {\n            const index = obs[eventName].indexOf(f);\r\n            obs[eventName].splice(index, 1);\n        }\r\n\r\n        return this;\n    }\r\n\r\n    notify(eventName, source, data) {\n        if (isUndef(this.observers[eventName])) return;\r\n\r\n        this.observers[eventName].forEach(observer => {\n            if (source === observer) return;\r\n            switch (eventName) {\n\r\n                case 'onmove':\r\n                    observer.notifyMove(data);\r\n                    break;\r\n                case 'onrotate':\r\n                    observer.notifyRotate(data);\r\n                    break;\r\n                case 'onresize':\r\n                    observer.notifyResize(data);\r\n                    break;\r\n                case 'onapply':\r\n                    observer.notifyApply(data);\r\n                    break;\r\n                case 'ongetstate':\r\n                    observer.notifyGetState(data);\r\n                    break;\r\n            \n            }\n        });\n    }\r\n\n}\n\nclass Event {\r\n\r\n    constructor(name) {\r\n        this.name = name;\r\n        this.callbacks = [];\r\n    }\r\n\r\n    registerCallback(cb) {\r\n        this.callbacks.push(cb);\r\n    }\r\n\r\n    removeCallback(cb) {\r\n        const ix = this.callbacks(cb);\r\n        this.callbacks.splice(ix, 1);\r\n    }\r\n\r\n}\r\n\r\nclass EventDispatcher {\r\n\r\n    constructor() {\r\n        this.events = {};\r\n    }\r\n\r\n    registerEvent(eventName) {\r\n        this.events[eventName] = new Event(eventName);\r\n    }\r\n\r\n    emit(ctx, eventName, eventArgs) {\r\n        this.events[eventName].callbacks.forEach((cb) => {\r\n            cb.call(ctx, eventArgs);\r\n        });\r\n    };\r\n    \r\n    addEventListener(eventName, cb) {\r\n        this.events[eventName].registerCallback(cb);\r\n    }\r\n\r\n    removeEventListener(eventName, cb) {\r\n        this.events[eventName].removeCallback(cb);\r\n    }\r\n\r\n}\n\nclass SubjectModel {\r\n\r\n    constructor(el) {\r\n        this.el = el;\r\n        this.storage = null;\r\n        this.proxyMethods = null;\r\n\r\n        this.eventDispatcher = new EventDispatcher();\r\n\r\n        this._onMouseDown = this._onMouseDown.bind(this);\r\n        this._onTouchStart = this._onTouchStart.bind(this);\r\n        this._onMouseMove = this._onMouseMove.bind(this);\r\n        this._onTouchMove = this._onTouchMove.bind(this);\r\n        this._onMouseUp = this._onMouseUp.bind(this);\r\n        this._onTouchEnd = this._onTouchEnd.bind(this);\r\n        this._animate = this._animate.bind(this);\r\n    }\r\n\r\n    enable(options) {\r\n        this._processOptions(options);\r\n        this._init(this.el);\r\n        this.proxyMethods.onInit.call(this, this.el);\r\n    }\r\n\r\n    disable() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _init() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _destroy() {\r\n        throwNotImplementedError();\r\n    }\r\n    \r\n    _processOptions() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _start() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _moving() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _end() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _animate() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _drag({ dx, dy, ...rest }) {\r\n        const transform = this._processMove(dx, dy);\r\n\r\n        const finalArgs = {\r\n            dx,\r\n            dy,\r\n            transform,\r\n            ...rest\r\n        };\r\n\r\n        this.proxyMethods.onMove.call(this, finalArgs);\r\n        this._emitEvent('drag', finalArgs);\r\n    }\r\n\r\n    _draw() {\r\n        this._animate();\r\n    }\r\n\r\n    _onMouseDown(e) {\r\n        this._start(e);\r\n        helper(document)\r\n            .on('mousemove', this._onMouseMove)\r\n            .on('mouseup', this._onMouseUp);\r\n    }\r\n\r\n    _onTouchStart(e) {\r\n        this._start(e.touches[0]);\r\n        helper(document)\r\n            .on('touchmove', this._onTouchMove)\r\n            .on('touchend', this._onTouchEnd);\r\n    }\r\n\r\n    _onMouseMove(e) {\r\n        if (e.preventDefault) {\r\n            e.preventDefault();\r\n        }\r\n        this._moving(\r\n            e,\r\n            this.el\r\n        );\r\n    }\r\n\r\n    _onTouchMove(e) {\r\n        if (e.preventDefault) {\r\n            e.preventDefault();\r\n        }\r\n        this._moving(\r\n            e.touches[0],\r\n            this.el\r\n        );\r\n    }\r\n\r\n    _onMouseUp(e) {\r\n        helper(document)\r\n            .off('mousemove', this._onMouseMove)\r\n            .off('mouseup', this._onMouseUp);\r\n\r\n        this._end(\r\n            e,\r\n            this.el\r\n        );\r\n    }\r\n\r\n    _onTouchEnd(e) {\r\n        helper(document)\r\n            .off('touchmove', this._onTouchMove)\r\n            .off('touchend', this._onTouchEnd);\r\n\r\n        if (e.touches.length === 0) {\r\n            this._end(\r\n                e.changedTouches[0],\r\n                this.el\r\n            );\r\n        }\r\n    }\r\n\r\n    _emitEvent() {\r\n        this.eventDispatcher.emit(this, ...arguments);\r\n    }\r\n\r\n    on(name, cb) {\r\n        this.eventDispatcher.addEventListener(name, cb);\r\n        return this;\r\n    }\r\n\r\n    off(name, cb) {\r\n        this.eventDispatcher.removeEventListener(name, cb);\r\n        return this;\r\n    }\r\n\r\n}\r\n\r\nfunction throwNotImplementedError() {\r\n    throw Error(`Method not implemented`);\r\n}\n\nconst EVENTS = [\r\n    'dragStart',\r\n    'drag',\r\n    'dragEnd',\r\n    'resizeStart',\r\n    'resize',\r\n    'resizeEnd',\r\n    'rotateStart',\r\n    'rotate',\r\n    'rotateEnd',\r\n    'setPointStart',\r\n    'setPointEnd'\r\n];\n\nconst RAD = Math.PI / 180;\r\n\r\nfunction snapToGrid(value, snap) {\r\n    if (snap === 0) {\r\n        return value;\r\n    } else {\r\n        const result = snapCandidate(value, snap);\r\n\r\n        if (result - value < snap) {\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\nfunction snapCandidate(value, gridSize) {\r\n    if (gridSize === 0) return value;\r\n    return Math.round(value / gridSize) * gridSize;\r\n}\r\n\r\nfunction floatToFixed(val, size = 6) {\r\n    return Number(val.toFixed(size));\r\n}\n\nfunction getOffset(node) {\r\n    return node.getBoundingClientRect();\r\n}\r\n\r\nfunction getTransform(el) {\r\n    const transform = el.css('-webkit-transform') ||\r\n        el.css('-moz-transform') ||\r\n        el.css('-ms-transform') ||\r\n        el.css('-o-transform') ||\r\n        el.css('transform') ||\r\n        'none';\r\n    return transform;\r\n}\r\n\r\nfunction parseMatrix(value) {\r\n    const transform = value.match(/[+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g);\r\n\r\n    if (transform) {\r\n        return transform.map(item => {\r\n            return parseFloat(item);\r\n        });\r\n    } else {\r\n        return [1, 0, 0, 1, 0, 0];\r\n    }\r\n}\r\n\r\nfunction addClass(node, cls) {\r\n    if (!cls) return;\r\n\r\n    if (node.classList) {\r\n        if (cls.indexOf(' ') > -1) {\r\n            cls.split(/\\s+/).forEach(cl => {\r\n                return node.classList.add(cl);\r\n            });\r\n        } else {\r\n            return node.classList.add(cls);\r\n        }\r\n    }\r\n    return node;\r\n}\r\n\r\nfunction removeClass(node, cls) {\r\n    if (!cls) return;\r\n\r\n    if (node.classList) {\r\n        if (cls.indexOf(' ') > -1) {\r\n            cls.split(/\\s+/).forEach(cl => {\r\n                return node.classList.remove(cl);\r\n            });\r\n        } else {\r\n            return node.classList.remove(cls);\r\n        }\r\n    }\r\n    return node;\r\n}\r\n\r\nfunction objectsCollide(a, b) {\r\n    const {\r\n            top: aTop,\r\n            left: aLeft\r\n        } = getOffset(a),\r\n        {\r\n            top: bTop,\r\n            left: bLeft\r\n        } = getOffset(b),\r\n        _a = helper(a),\r\n        _b = helper(b);\r\n\r\n    return !(\r\n        ((aTop < bTop) ||\r\n            (aTop + parseFloat(_a.css('height'))) > (bTop + parseFloat(_b.css('height')))) ||\r\n        ((aLeft < bLeft) ||\r\n            (aLeft + parseFloat(_a.css('width'))) > (bLeft + parseFloat(_b.css('width'))))\r\n    );\r\n}\r\n\r\nfunction matrixToCSS(arr) {\r\n    const style = `matrix(${arr.join()})`;\r\n\r\n    return {\r\n        transform: style,\r\n        webkitTranform: style,\r\n        mozTransform: style,\r\n        msTransform: style,\r\n        otransform: style\r\n    };\r\n}\n\nclass Transformable extends SubjectModel {\r\n\r\n    constructor(el, options, observable) {\r\n        super(el);\r\n        if (this.constructor === Transformable) {\r\n            throw new TypeError('Cannot construct Transformable instances directly');\r\n        }\r\n        this.observable = observable;\r\n\r\n        EVENTS.forEach((eventName) => {\r\n            this.eventDispatcher.registerEvent(eventName);\r\n        });\r\n        \r\n        this.enable(options);\r\n    }\r\n\r\n    _cursorPoint() {\r\n        throw Error(`'_cursorPoint()' method not implemented`);\r\n    }\r\n\r\n    _rotate({ radians, ...rest }) {\r\n        const resultMtrx = this._processRotate(radians);\r\n        const finalArgs = {\r\n            transform: resultMtrx,\r\n            delta: radians,\r\n            ...rest\r\n        };\r\n        this.proxyMethods.onRotate.call(this, finalArgs);\r\n        this._emitEvent('rotate', finalArgs);\r\n    }\r\n\r\n    _resize({ dx, dy, ...rest }) {\r\n        const finalValues = this._processResize(dx, dy);\r\n        const finalArgs = {\r\n            ...finalValues,\r\n            dx,\r\n            dy,\r\n            ...rest\r\n        };\r\n        this.proxyMethods.onResize.call(this, finalArgs);\r\n        this._emitEvent('resize', finalArgs);\r\n    }\r\n\r\n    _processOptions(options) {\r\n        const { el } = this;\r\n\r\n        addClass(el, 'sjx-drag');\r\n\r\n        const _snap = {\r\n            x: 10,\r\n            y: 10,\r\n            angle: 10 * RAD\r\n        };\r\n\r\n        const _each = {\r\n            move: false,\r\n            resize: false,\r\n            rotate: false\r\n        };\r\n\r\n        let _restrict = null,\r\n            _proportions = false,\r\n            _axis = 'xy',\r\n            _cursorMove = 'auto',\r\n            _cursorResize = 'auto',\r\n            _cursorRotate = 'auto',\r\n            _themeColor = '#00a8ff',\r\n            _rotationPoint = false,\r\n            _draggable = true,\r\n            _resizable = true,\r\n            _rotatable = true,\r\n            _onInit = () => { },\r\n            _onMove = () => { },\r\n            _onRotate = () => { },\r\n            _onResize = () => { },\r\n            _onDrop = () => { },\r\n            _onDestroy = () => { };\r\n\r\n        let _container = el.parentNode;\r\n\r\n        if (isDef(options)) {\r\n            const {\r\n                snap,\r\n                each,\r\n                axis,\r\n                cursorMove,\r\n                cursorResize,\r\n                cursorRotate,\r\n                rotationPoint,\r\n                restrict,\r\n                draggable,\r\n                resizable,\r\n                rotatable,\r\n                onInit,\r\n                onDrop,\r\n                onMove,\r\n                onResize,\r\n                onRotate,\r\n                onDestroy,\r\n                container,\r\n                proportions,\r\n                themeColor\r\n            } = options;\r\n\r\n            if (isDef(snap)) {\r\n                const { x, y, angle } = snap;\r\n\r\n                _snap.x = isUndef(x) ? 10 : x;\r\n                _snap.y = isUndef(y) ? 10 : y;\r\n                _snap.angle = isUndef(angle)\r\n                    ? _snap.angle\r\n                    : angle * RAD;\r\n            }\r\n\r\n            if (isDef(each)) {\r\n                const { move, resize, rotate } = each;\r\n\r\n                _each.move = move || false;\r\n                _each.resize = resize || false;\r\n                _each.rotate = rotate || false;\r\n            }\r\n\r\n            if (isDef(restrict)) {\r\n                _restrict = restrict === 'parent'\r\n                    ? el.parentNode\r\n                    : helper(restrict)[0] || document;\r\n            }\r\n\r\n            _themeColor = themeColor || '#00a8ff';\r\n            _cursorMove = cursorMove || 'auto';\r\n            _cursorResize = cursorResize || 'auto';\r\n            _cursorRotate = cursorRotate || 'auto';\r\n            _axis = axis || 'xy';\r\n\r\n            _container = isDef(container) && helper(container)[0]\r\n                ? helper(container)[0]\r\n                : _container;\r\n\r\n            _rotationPoint = rotationPoint || false;\r\n            _proportions = proportions || false;\r\n\r\n            _draggable = isDef(draggable) ? draggable : true;\r\n            _resizable = isDef(resizable) ? resizable : true;\r\n            _rotatable = isDef(rotatable) ? rotatable : true;\r\n\r\n            _onInit = createMethod(onInit);\r\n            _onDrop = createMethod(onDrop);\r\n            _onMove = createMethod(onMove);\r\n            _onResize = createMethod(onResize);\r\n            _onRotate = createMethod(onRotate);\r\n            _onDestroy = createMethod(onDestroy);\r\n        }\r\n\r\n        this.options = {\r\n            axis: _axis,\r\n            themeColor: _themeColor,\r\n            cursorMove: _cursorMove,\r\n            cursorRotate: _cursorRotate,\r\n            cursorResize: _cursorResize,\r\n            rotationPoint: _rotationPoint,\r\n            restrict: _restrict,\r\n            container: _container,\r\n            snap: _snap,\r\n            each: _each,\r\n            proportions: _proportions,\r\n            draggable: _draggable,\r\n            resizable: _resizable,\r\n            rotatable: _rotatable\r\n        };\r\n\r\n        this.proxyMethods = {\r\n            onInit: _onInit,\r\n            onDrop: _onDrop,\r\n            onMove: _onMove,\r\n            onResize: _onResize,\r\n            onRotate: _onRotate,\r\n            onDestroy: _onDestroy\r\n        };\r\n\r\n        this.subscribe(_each);\r\n    }\r\n\r\n    _animate() {\r\n        const self = this;\r\n        const {\r\n            observable,\r\n            storage,\r\n            options\r\n        } = self;\r\n\r\n        if (isUndef(storage)) return;\r\n\r\n        storage.frame = requestAnimFrame(self._animate);\r\n\r\n        if (!storage.doDraw) return;\r\n        storage.doDraw = false;\r\n\r\n        let {\r\n            dox,\r\n            doy,\r\n            clientX,\r\n            clientY,\r\n            doDrag,\r\n            doResize,\r\n            doRotate,\r\n            doSetCenter,\r\n            revX,\r\n            revY\r\n        } = storage;\r\n\r\n        const {\r\n            snap,\r\n            each: {\r\n                move: moveEach,\r\n                resize: resizeEach,\r\n                rotate: rotateEach\r\n            },\r\n            restrict,\r\n            draggable,\r\n            resizable,\r\n            rotatable\r\n        } = options;\r\n\r\n        if (doResize && resizable) {\r\n            const {\r\n                transform,\r\n                cx,\r\n                cy\r\n            } = storage;\r\n\r\n            const { x, y } = this._pointToElement(\r\n                {\r\n                    x: clientX,\r\n                    y: clientY\r\n                }\r\n            );\r\n\r\n            let dx = dox\r\n                ? snapToGrid(x - cx, snap.x / transform.scX)\r\n                : 0;\r\n\r\n            let dy = doy\r\n                ? snapToGrid(y - cy, snap.y / transform.scY)\r\n                : 0;\r\n\r\n            dx = dox ? (revX ? - dx : dx) : 0,\r\n            dy = doy ? (revY ? - dy : dy) : 0;\r\n\r\n            const args = {\r\n                dx,\r\n                dy,\r\n                clientX,\r\n                clientY\r\n            };\r\n\r\n            self._resize(args);\r\n\r\n            if (resizeEach) {\r\n                observable.notify(\r\n                    'onresize',\r\n                    self,\r\n                    args\r\n                );\r\n            }\r\n        }\r\n\r\n        if (doDrag && draggable) {\r\n            const {\r\n                restrictOffset,\r\n                elementOffset,\r\n                nx,\r\n                ny\r\n            } = storage;\r\n\r\n            if (isDef(restrict)) {\r\n                if ((clientX - restrictOffset.left) < nx - elementOffset.left) {\r\n                    clientX = nx - elementOffset.left + restrictOffset.left;\r\n                }\r\n\r\n                if ((clientY - restrictOffset.top) < ny - elementOffset.top) {\r\n                    clientY = ny - elementOffset.top + restrictOffset.top;\r\n                }\r\n            }\r\n\r\n            const dx = dox\r\n                ? snapToGrid(clientX - nx, snap.x)\r\n                : 0;\r\n\r\n            const dy = doy\r\n                ? snapToGrid(clientY - ny, snap.y)\r\n                : 0;\r\n\r\n            const args = {\r\n                dx,\r\n                dy,\r\n                clientX,\r\n                clientY\r\n            };\r\n\r\n            self._drag(\r\n                args\r\n            );\r\n\r\n            if (moveEach) {\r\n                observable.notify('onmove',\r\n                    self,\r\n                    args\r\n                );\r\n            }\r\n        }\r\n\r\n        if (doRotate && rotatable) {\r\n            const {\r\n                pressang,\r\n                center\r\n            } = storage;\r\n\r\n            const radians = Math.atan2(\r\n                clientY - center.y,\r\n                clientX - center.x\r\n            ) - pressang;\r\n\r\n            const args = {\r\n                clientX,\r\n                clientY\r\n            };\r\n\r\n            self._rotate(\r\n                {\r\n                    radians: snapToGrid(radians, snap.angle),\r\n                    ...args\r\n                }\r\n            );\r\n\r\n            if (rotateEach) {\r\n                observable.notify('onrotate',\r\n                    self,\r\n                    {\r\n                        radians,\r\n                        ...args\r\n                    }\r\n                );\r\n            }\r\n        }\r\n\r\n        if (doSetCenter && rotatable) {\r\n            const {\r\n                bx,\r\n                by\r\n            } = storage;\r\n\r\n            const { x, y } = this._pointToControls(\r\n                {\r\n                    x: clientX,\r\n                    y: clientY\r\n                }\r\n            );\r\n\r\n            self._moveCenterHandle(\r\n                x - bx,\r\n                y - by\r\n            );\r\n        }\r\n    }\r\n\r\n    _start(e) {\r\n        const {\r\n            observable,\r\n            storage,\r\n            options: { axis, restrict, each },\r\n            el\r\n        } = this;\r\n\r\n        const computed = this._compute(e);\r\n\r\n        Object.keys(computed).forEach(prop => {\r\n            storage[prop] = computed[prop];\r\n        });\r\n\r\n        const {\r\n            onRightEdge,\r\n            onBottomEdge,\r\n            onTopEdge,\r\n            onLeftEdge,\r\n            handle,\r\n            factor,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        } = computed;\r\n\r\n        const doResize =\r\n            onRightEdge ||\r\n            onBottomEdge ||\r\n            onTopEdge ||\r\n            onLeftEdge;\r\n\r\n        const {\r\n            handles\r\n        } = storage;\r\n\r\n        const {\r\n            rotator,\r\n            center,\r\n            radius\r\n        } = handles;\r\n\r\n        if (isDef(radius)) {\r\n            removeClass(radius, 'sjx-hidden');\r\n        }\r\n\r\n        const doRotate = handle.is(rotator),\r\n            doSetCenter = isDef(center)\r\n                ? handle.is(center)\r\n                : false;\r\n\r\n        const doDrag = !(doRotate || doResize || doSetCenter);\r\n\r\n        const {\r\n            clientX,\r\n            clientY\r\n        } = e;\r\n\r\n        const {\r\n            x,\r\n            y\r\n        } = this._cursorPoint(\r\n            {\r\n                clientX,\r\n                clientY\r\n            }\r\n        );\r\n\r\n        const {\r\n            x: nx,\r\n            y: ny\r\n        } = this._pointToElement({ x, y });\r\n\r\n        const {\r\n            x: bx,\r\n            y: by\r\n        } = this._pointToControls({ x, y });\r\n\r\n        const newStorageValues = {\r\n            clientX,\r\n            clientY,\r\n            nx: x,\r\n            ny: y,\r\n            cx: nx,\r\n            cy: ny,\r\n            bx,\r\n            by,\r\n            doResize,\r\n            doDrag,\r\n            doRotate,\r\n            doSetCenter,\r\n            onExecution: true,\r\n            cursor: null,\r\n            elementOffset: getOffset(el),\r\n            restrictOffset: isDef(restrict)\r\n                ? getOffset(restrict)\r\n                : null,\r\n            dox: /\\x/.test(axis) && (doResize\r\n                ?\r\n                handle.is(handles.ml) ||\r\n                handle.is(handles.mr) ||\r\n                handle.is(handles.tl) ||\r\n                handle.is(handles.tr) ||\r\n                handle.is(handles.bl) ||\r\n                handle.is(handles.br)\r\n                : true),\r\n            doy: /\\y/.test(axis) && (doResize\r\n                ?\r\n                handle.is(handles.br) ||\r\n                handle.is(handles.bl) ||\r\n                handle.is(handles.bc) ||\r\n                handle.is(handles.tr) ||\r\n                handle.is(handles.tl) ||\r\n                handle.is(handles.tc)\r\n                : true)\r\n        };\r\n\r\n        this.storage = {\r\n            ...storage,\r\n            ...newStorageValues\r\n        };\r\n\r\n        const eventArgs = {\r\n            clientX,\r\n            clientY\r\n        };\r\n\r\n        if (doResize) {\r\n            this._emitEvent('resizeStart', eventArgs);\r\n        } else if (doRotate) {\r\n            this._emitEvent('rotateStart', eventArgs);\r\n        } else if (doDrag) {\r\n            this._emitEvent('dragStart', eventArgs);\r\n        }\r\n\r\n        const {\r\n            move,\r\n            resize,\r\n            rotate\r\n        } = each;\r\n\r\n        const actionName = doResize\r\n            ? 'resize'\r\n            : (doRotate? 'rotate' : 'drag');\r\n        \r\n        const triggerEvent = \r\n            (doResize && resize) ||\r\n            (doRotate && rotate) ||\r\n            (doDrag && move);\r\n\r\n        observable.notify(\r\n            'ongetstate',\r\n            this,\r\n            {   \r\n                clientX,\r\n                clientY,\r\n                actionName,\r\n                triggerEvent,\r\n                factor,\r\n                revX,\r\n                revY,\r\n                doW,\r\n                doH\r\n            }\r\n        );\r\n        \r\n        this._draw();\r\n    }\r\n\r\n    _moving(e) {\r\n        const {\r\n            storage,\r\n            options\r\n        } = this;\r\n\r\n        const {\r\n            x,\r\n            y\r\n        } = this._cursorPoint(e);\r\n\r\n        storage.e = e;\r\n        storage.clientX = x;\r\n        storage.clientY = y;\r\n        storage.doDraw = true;\r\n\r\n        let {\r\n            doRotate,\r\n            doDrag,\r\n            doResize,\r\n            cursor\r\n        } = storage;\r\n\r\n        const {\r\n            cursorMove,\r\n            cursorResize,\r\n            cursorRotate\r\n        } = options;\r\n\r\n        if (isUndef(cursor)) {\r\n            if (doDrag) {\r\n                cursor = cursorMove;\r\n            } else if (doRotate) {\r\n                cursor = cursorRotate;\r\n            } else if (doResize) {\r\n                cursor = cursorResize;\r\n            }\r\n            helper(document.body).css({ cursor });\r\n        }\r\n    }\r\n\r\n    _end({ clientX, clientY }) {\r\n        const {\r\n            options: { each },\r\n            observable,\r\n            storage,\r\n            proxyMethods\r\n        } = this;\r\n\r\n        const {\r\n            doResize,\r\n            doDrag,\r\n            doRotate,\r\n            //doSetCenter,\r\n            frame,\r\n            handles: { radius }\r\n        } = storage;\r\n\r\n        const actionName = doResize\r\n            ? 'resize'\r\n            : (doDrag ? 'drag' : 'rotate');\r\n\r\n        storage.doResize = false;\r\n        storage.doDrag = false;\r\n        storage.doRotate = false;\r\n        storage.doSetCenter = false;\r\n        storage.doDraw = false;\r\n        storage.onExecution = false;\r\n        storage.cursor = null;\r\n\r\n        this._apply(actionName);\r\n\r\n        const eventArgs = {\r\n            clientX, \r\n            clientY\r\n        };\r\n\r\n        proxyMethods.onDrop.call(this, eventArgs);\r\n\r\n        if (doResize) {\r\n            this._emitEvent('resizeEnd', eventArgs);\r\n        } else if (doRotate) {\r\n            this._emitEvent('rotateEnd', eventArgs);\r\n        } else if (doDrag) {\r\n            this._emitEvent('dragEnd', eventArgs);\r\n        }\r\n\r\n        const {\r\n            move,\r\n            resize,\r\n            rotate\r\n        } = each;\r\n\r\n        const triggerEvent = \r\n            (doResize && resize) ||\r\n            (doRotate && rotate) ||\r\n            (doDrag && move);\r\n\r\n        observable.notify(\r\n            'onapply',\r\n            this,\r\n            {\r\n                clientX, \r\n                clientY,\r\n                actionName,\r\n                triggerEvent\r\n            }\r\n        );\r\n\r\n        cancelAnimFrame(frame);\r\n\r\n        helper(document.body).css({ cursor: 'auto' });\r\n        if (isDef(radius)) {\r\n            addClass(radius, 'sjx-hidden');\r\n        }  \r\n    }\r\n\r\n    _compute(e) {\r\n        const {\r\n            handles\r\n        } = this.storage;\r\n\r\n        const handle = helper(e.target);\r\n\r\n        const {\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH,\r\n            ...rest\r\n        } = this._checkHandles(handle, handles);\r\n\r\n        const _computed = this._getState({\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        });\r\n\r\n        const {\r\n            x: clientX,\r\n            y: clientY\r\n        } = this._cursorPoint(e);\r\n\r\n        const pressang = Math.atan2(\r\n            clientY - _computed.center.y,\r\n            clientX - _computed.center.x\r\n        );\r\n\r\n        return {\r\n            ..._computed,\r\n            ...rest,\r\n            handle,\r\n            pressang\r\n        };\r\n    }\r\n\r\n    _checkHandles(handle, handles) {\r\n        const { tl, tc, tr, bl, br, bc, ml, mr } = handles;\r\n        const isTL = isDef(tl) ? handle.is(tl) : false,\r\n            isTC = isDef(tc) ? handle.is(tc) : false,\r\n            isTR = isDef(tr) ? handle.is(tr) : false,\r\n            isBL = isDef(bl) ? handle.is(bl) : false,\r\n            isBC = isDef(bc) ? handle.is(bc) : false,\r\n            isBR = isDef(br) ? handle.is(br) : false,\r\n            isML = isDef(ml) ? handle.is(ml) : false,\r\n            isMR = isDef(mr) ? handle.is(mr) : false;\r\n\r\n        //reverse axis\r\n        const revX = isTL || isML || isBL || isTC,\r\n            revY = isTL || isTR || isTC || isML;\r\n\r\n        const onTopEdge = isTC || isTR || isTL,\r\n            onLeftEdge = isTL || isML || isBL,\r\n            onRightEdge = isTR || isMR || isBR,\r\n            onBottomEdge = isBR || isBC || isBL;\r\n\r\n        const doW = isML || isMR,\r\n            doH = isTC || isBC;\r\n\r\n        return {\r\n            revX,\r\n            revY,\r\n            onTopEdge,\r\n            onLeftEdge,\r\n            onRightEdge,\r\n            onBottomEdge,\r\n            doW,\r\n            doH\r\n        };\r\n    }\r\n\r\n    notifyMove() {\r\n        this._drag(...arguments);\r\n    }\r\n\r\n    notifyRotate({ radians, ...rest }) {\r\n        const {\r\n            snap: { angle }\r\n        } = this.options;\r\n\r\n        this._rotate(\r\n            {\r\n                radians: snapToGrid(radians, angle),\r\n                ...rest\r\n            }\r\n        );\r\n    }\r\n\r\n    notifyResize() {\r\n        this._resize(...arguments);\r\n    }\r\n\r\n    notifyApply({ clientX, clientY, actionName, triggerEvent }) {\r\n        this.proxyMethods.onDrop.call(this, { clientX, clientY });\r\n        if (triggerEvent) {\r\n            this._apply(actionName);\r\n            this._emitEvent(`${actionName}End`, { clientX, clientY });\r\n        }\r\n    }\r\n\r\n    notifyGetState({ clientX, clientY, actionName, triggerEvent, ...rest}) {\r\n        if (triggerEvent) {\r\n            const recalc = this._getState(\r\n                rest\r\n            );\r\n    \r\n            this.storage = {\r\n                ...this.storage,\r\n                ...recalc\r\n            };\r\n            this._emitEvent(`${actionName}Start`, { clientX, clientY });\r\n        }\r\n    }\r\n\r\n    subscribe({ resize, move, rotate }) {\r\n        const { observable: ob } = this;\r\n\r\n        if (move || resize || rotate) {\r\n            ob.subscribe('ongetstate', this)\r\n                .subscribe('onapply', this);\r\n        }\r\n\r\n        if (move) {\r\n            ob.subscribe('onmove', this);\r\n        }\r\n        if (resize) {\r\n            ob.subscribe('onresize', this);\r\n        }\r\n        if (rotate) {\r\n            ob.subscribe('onrotate', this);\r\n        }\r\n    }\r\n\r\n    unsubscribe() {\r\n        const { observable: ob } = this;\r\n\r\n        ob.unsubscribe('ongetstate', this)\r\n            .unsubscribe('onapply', this)\r\n            .unsubscribe('onmove', this)\r\n            .unsubscribe('onresize', this)\r\n            .unsubscribe('onrotate', this);\r\n    }\r\n\r\n    disable() {\r\n        const {\r\n            storage,\r\n            proxyMethods,\r\n            el\r\n        } = this;\r\n\r\n        if (isUndef(storage)) return;\r\n\r\n        // unexpected case\r\n        if (storage.onExecution) {\r\n            this._end();\r\n            helper(document)\r\n                .off('mousemove', this._onMouseMove)\r\n                .off('mouseup', this._onMouseUp)\r\n                .off('touchmove', this._onTouchMove)\r\n                .off('touchend', this._onTouchEnd);\r\n        }\r\n\r\n        removeClass(el, 'sjx-drag');\r\n\r\n        this._destroy();\r\n        this.unsubscribe();\r\n\r\n        proxyMethods.onDestroy.call(this, el);\r\n        delete this.storage;\r\n    }\r\n\r\n    exeDrag({ dx, dy }) {\r\n        const { draggable } = this.options;\r\n        if (!draggable) return;\r\n    \r\n        this.storage = {\r\n            ...this.storage,\r\n            ...this._getState({ \r\n                revX: false, \r\n                revY: false, \r\n                doW: false, \r\n                doH: false \r\n            })\r\n        };\r\n\r\n        this._drag({ dx, dy });\r\n        this._apply('drag');\r\n    }\r\n\r\n    exeResize({ dx, dy, revX, revY, doW, doH }) {\r\n        const { resizable } = this.options;\r\n        if (!resizable) return;\r\n\r\n        this.storage = {\r\n            ...this.storage,\r\n            ...this._getState({ \r\n                revX: revX || false,\r\n                revY: revY || false,\r\n                doW: doW || false,\r\n                doH: doH || false\r\n            })\r\n        };\r\n\r\n        this._resize({ dx, dy });\r\n        this._apply('resize');\r\n    }\r\n\r\n    exeRotate({ delta }) {\r\n        const { rotatable } = this.options;\r\n        if (!rotatable) return;\r\n\r\n        this.storage = {\r\n            ...this.storage,\r\n            ...this._getState({ \r\n                revX: false, \r\n                revY: false, \r\n                doW: false, \r\n                doH: false \r\n            })\r\n        };\r\n\r\n        this._rotate({ radians: delta });\r\n        this._apply('rotate');\r\n    }\r\n\r\n}\n\nfunction matrixTransform({ x, y }, matrix) {\r\n    const [a, b, c, d, e, f] = matrix;\r\n\r\n    return {\r\n        x: a * x + c * y + e,\r\n        y: b * x + d * y + f\r\n    };\r\n}\r\n\r\n//http://blog.acipo.com/matrix-inversion-in-javascript/\r\nfunction matrixInvert(ctm) {\r\n    // I use Guassian Elimination to calculate the inverse:\r\n    // (1) 'augment' the matrix (left) by the identity (on the right)\r\n    // (2) Turn the matrix on the left into the identity by elemetry row ops\r\n    // (3) The matrix on the right is the inverse (was the identity matrix)\r\n    // There are 3 elemtary row ops: (I combine b and c in my code)\r\n    // (a) Swap 2 rows\r\n    // (b) Multiply a row by a scalar\r\n    // (c) Add 2 rows\r\n\r\n    const M = [\r\n        [ctm[0], ctm[2], ctm[4]],\r\n        [ctm[1], ctm[3], ctm[5]],\r\n        [0, 0, 1]\r\n    ];\r\n\r\n    //if the matrix isn't square: exit (error)\r\n    if (M.length !== M[0].length) {\r\n        return;\r\n    }\r\n\r\n    //create the identity matrix (I), and a copy (C) of the original\r\n    const dim = M.length;\r\n\r\n    const I = [],\r\n        C = [];\r\n\r\n    for (let i = 0; i < dim; i += 1) {\r\n        // Create the row\r\n        I[I.length] = [];\r\n        C[C.length] = [];\r\n        for (let j = 0; j < dim; j += 1) {\r\n            //if we're on the diagonal, put a 1 (for identity)\r\n            if (i == j) {\r\n                I[i][j] = 1;\r\n            } else {\r\n                I[i][j] = 0;\r\n            }\r\n\r\n            // Also, make the copy of the original\r\n            C[i][j] = M[i][j];\r\n        }\r\n    }\r\n\r\n    // Perform elementary row operations\r\n    for (let i = 0; i < dim; i += 1) {\r\n        // get the element e on the diagonal\r\n        let e = C[i][i];\r\n\r\n        // if we have a 0 on the diagonal (we'll need to swap with a lower row)\r\n        if (e === 0) {\r\n            //look through every row below the i'th row\r\n            for (let ii = i + 1; ii < dim; ii += 1) {\r\n                //if the ii'th row has a non-0 in the i'th col\r\n                if (C[ii][i] !== 0) {\r\n                    //it would make the diagonal have a non-0 so swap it\r\n                    for (let j = 0; j < dim; j++) {\r\n                        e = C[i][j]; //temp store i'th row\r\n                        C[i][j] = C[ii][j]; //replace i'th row by ii'th\r\n                        C[ii][j] = e; //repace ii'th by temp\r\n                        e = I[i][j]; //temp store i'th row\r\n                        I[i][j] = I[ii][j]; //replace i'th row by ii'th\r\n                        I[ii][j] = e; //repace ii'th by temp\r\n                    }\r\n                    //don't bother checking other rows since we've swapped\r\n                    break;\r\n                }\r\n            }\r\n            //get the new diagonal\r\n            e = C[i][i];\r\n            //if it's still 0, not invertable (error)\r\n            if (e === 0) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Scale this row down by e (so we have a 1 on the diagonal)\r\n        for (let j = 0; j < dim; j++) {\r\n            C[i][j] = C[i][j] / e; //apply to original matrix\r\n            I[i][j] = I[i][j] / e; //apply to identity\r\n        }\r\n\r\n        // Subtract this row (scaled appropriately for each row) from ALL of\r\n        // the other rows so that there will be 0's in this column in the\r\n        // rows above and below this one\r\n        for (let ii = 0; ii < dim; ii++) {\r\n            // Only apply to other rows (we want a 1 on the diagonal)\r\n            if (ii == i) {\r\n                continue;\r\n            }\r\n\r\n            // We want to change this element to 0\r\n            e = C[ii][i];\r\n\r\n            // Subtract (the row above(or below) scaled by e) from (the\r\n            // current row) but start at the i'th column and assume all the\r\n            // stuff left of diagonal is 0 (which it should be if we made this\r\n            // algorithm correctly)\r\n            for (let j = 0; j < dim; j++) {\r\n                C[ii][j] -= e * C[i][j]; //apply to original matrix\r\n                I[ii][j] -= e * I[i][j]; //apply to identity\r\n            }\r\n        }\r\n    }\r\n\r\n    //we've done all operations, C should be the identity\r\n    //matrix I should be the inverse:\r\n    return [\r\n        I[0][0], I[1][0],\r\n        I[0][1], I[1][1],\r\n        I[0][2], I[1][2]\r\n    ];\r\n}\r\n\r\nfunction multiplyMatrix(\r\n    [a1, b1, c1, d1, e1, f1], \r\n    [a2, b2, c2, d2, e2, f2]\r\n) {\r\n    const m1 = [\r\n        [a1, c1, e1],\r\n        [b1, d1, f1],\r\n        [0, 0, 1]\r\n    ];\r\n\r\n    const m2 = [\r\n        [a2, c2, e2],\r\n        [b2, d2, f2],\r\n        [0, 0, 1]\r\n    ];\r\n\r\n    const result = [];\r\n\r\n    for (let j = 0; j < m2.length; j++) {\r\n        result[j] = [];\r\n        for (let k = 0; k < m1[0].length; k++) {\r\n            let sum = 0;\r\n            for (let i = 0; i < m1.length; i++) {\r\n                sum += m1[i][k] * m2[j][i];\r\n            }\r\n            result[j].push(sum);\r\n        }\r\n    }\r\n\r\n    return [\r\n        result[0][0], result[1][0],\r\n        result[0][1], result[1][1],\r\n        result[0][2], result[1][2]\r\n    ];\r\n}\r\n\r\nfunction rotatedTopLeft(\r\n    x,\r\n    y,\r\n    width,\r\n    height,\r\n    rotationAngle,\r\n    revX,\r\n    revY,\r\n    doW,\r\n    doH\r\n) {\r\n    const hw = parseFloat(width) / 2,\r\n        hh = parseFloat(height) / 2;\r\n\r\n    const cx = x + hw,\r\n        cy = y + hh;\r\n\r\n    const dx = x - cx,\r\n        dy = y - cy;\r\n\r\n    const originalTopLeftAngle = Math.atan2(doW ? 0 : dy, doH ? 0 : dx);\r\n    const rotatedTopLeftAngle = originalTopLeftAngle + rotationAngle;\r\n\r\n    const radius = Math.sqrt(Math.pow(doH ? 0 : hw, 2) + Math.pow(doW ? 0 : hh, 2));\r\n\r\n    let cos = Math.cos(rotatedTopLeftAngle),\r\n        sin = Math.sin(rotatedTopLeftAngle);\r\n\r\n    cos = revX === true ? -cos : cos;\r\n    sin = revY === true ? -sin : sin;\r\n\r\n    const rx = cx + radius * cos,\r\n        ry = cy + radius * sin;\r\n\r\n    return {\r\n        left: floatToFixed(rx),\r\n        top: floatToFixed(ry)\r\n    };\r\n}\n\nconst MIN_SIZE = 2;\r\nconst CENTER_DELTA = 7;\r\n\r\nclass Draggable extends Transformable {\r\n\r\n    _init(el) {\r\n        const {\r\n            rotationPoint,\r\n            container,\r\n            resizable,\r\n            rotatable\r\n        } = this.options;\r\n\r\n        const {\r\n            left,\r\n            top,\r\n            width,\r\n            height\r\n        } = el.style;\r\n\r\n        const wrapper = document.createElement('div');\r\n        addClass(wrapper, 'sjx-wrapper');\r\n        container.appendChild(wrapper);\r\n\r\n        const $el = helper(el);\r\n\r\n        const w = width || $el.css('width'),\r\n            h = height || $el.css('height'),\r\n            t = top || $el.css('top'),\r\n            l = left || $el.css('left');\r\n\r\n        const css = {\r\n            top: t,\r\n            left: l,\r\n            width: w,\r\n            height: h,\r\n            transform: getTransform($el)\r\n        };\r\n\r\n        const controls = document.createElement('div');\r\n        addClass(controls, 'sjx-controls');\r\n\r\n        const resizingHandles = {\r\n            tl: ['sjx-hdl', 'sjx-hdl-t', 'sjx-hdl-l', 'sjx-hdl-tl'],\r\n            tr: ['sjx-hdl', 'sjx-hdl-t', 'sjx-hdl-r', 'sjx-hdl-tr'],\r\n            br: ['sjx-hdl', 'sjx-hdl-b', 'sjx-hdl-r', 'sjx-hdl-br'],\r\n            bl: ['sjx-hdl', 'sjx-hdl-b', 'sjx-hdl-l', 'sjx-hdl-bl'],\r\n            tc: ['sjx-hdl', 'sjx-hdl-t', 'sjx-hdl-c', 'sjx-hdl-tc'],\r\n            bc: ['sjx-hdl', 'sjx-hdl-b', 'sjx-hdl-c', 'sjx-hdl-bc'],\r\n            ml: ['sjx-hdl', 'sjx-hdl-m', 'sjx-hdl-l', 'sjx-hdl-ml'],\r\n            mr: ['sjx-hdl', 'sjx-hdl-m', 'sjx-hdl-r', 'sjx-hdl-mr']\r\n        };\r\n\r\n        const rotationHandles = {\r\n            normal: ['sjx-normal'],\r\n            rotator: ['sjx-hdl', 'sjx-hdl-m', 'sjx-rotator']\r\n        };\r\n\r\n        const handles = {\r\n            ...(rotatable && rotationHandles),\r\n            ...(resizable && resizingHandles),\r\n            center: rotationPoint && rotatable ? ['sjx-hdl', 'sjx-hdl-m', 'sjx-hdl-c', 'sjx-hdl-mc'] : undefined\r\n        };\r\n\r\n        Object.keys(handles).forEach(key => {\r\n            const data = handles[key];\r\n            if (isUndef(data)) return;\r\n            const handler = createHandler(data);\r\n            handles[key] = handler;\r\n            controls.appendChild(handler);\r\n        });\r\n\r\n        if (isDef(handles.center)) {\r\n            const cHandle = helper(handles.center);\r\n            cHandle.css({\r\n                left: `${el.getAttribute('data-cx')}px`,\r\n                top: `${el.getAttribute('data-cy')}px`\r\n            });\r\n        }\r\n\r\n        wrapper.appendChild(controls);\r\n\r\n        const $controls = helper(controls);\r\n        $controls.css(css);\r\n\r\n        this.storage = {\r\n            controls,\r\n            handles,\r\n            radius: undefined,\r\n            parent: el.parentNode\r\n        };\r\n\r\n        $controls\r\n            .on('mousedown', this._onMouseDown)\r\n            .on('touchstart', this._onTouchStart);\r\n    }\r\n\r\n    _destroy() {\r\n        const {\r\n            controls\r\n        } = this.storage;\r\n\r\n        helper(controls)\r\n            .off('mousedown', this._onMouseDown)\r\n            .off('touchstart', this._onTouchStart);\r\n\r\n        const wrapper = controls.parentNode;\r\n        wrapper.parentNode.removeChild(wrapper);\r\n    }\r\n\r\n    _pointToElement({ x, y }) {\r\n        const {\r\n            transform\r\n        } = this.storage;\r\n\r\n        const ctm = [...transform.matrix];\r\n        ctm[4] = ctm[5] = 0;\r\n\r\n        return this._applyMatrixToPoint(\r\n            matrixInvert(ctm),\r\n            x,\r\n            y\r\n        );\r\n    }\r\n\r\n    _pointToControls(data) {\r\n        return this._pointToElement(data);\r\n    }\r\n\r\n    _applyMatrixToPoint(matrix, x, y) {\r\n        return matrixTransform(\r\n            {\r\n                x,\r\n                y\r\n            },\r\n            matrix\r\n        );\r\n    }\r\n\r\n    _cursorPoint({ clientX, clientY }) {\r\n        const {\r\n            container\r\n        } = this.options;\r\n\r\n        const globalMatrix = parseMatrix(\r\n            getTransform(helper(container))\r\n        );\r\n\r\n        return matrixTransform(\r\n            {\r\n                x: clientX,\r\n                y: clientY\r\n            },\r\n            matrixInvert(\r\n                globalMatrix\r\n            )\r\n        );\r\n    }\r\n\r\n    _apply() {\r\n        const {\r\n            el,\r\n            storage\r\n        } = this;\r\n\r\n        const {\r\n            // cached,\r\n            controls,\r\n            // transform,\r\n            handles\r\n        } = storage;\r\n\r\n        const $controls = helper(controls);\r\n\r\n        const cw = parseFloat($controls.css('width')),\r\n            ch = parseFloat($controls.css('height'));\r\n\r\n        const hW = cw / 2,\r\n            hH = ch / 2;\r\n\r\n        const {\r\n            center: cHandle\r\n        } = handles;\r\n\r\n        const isDefCenter = isDef(cHandle);\r\n\r\n        const centerX = isDefCenter\r\n            ? parseFloat(helper(cHandle).css('left'))\r\n            : hW;\r\n        const centerY = isDefCenter\r\n            ? parseFloat(helper(cHandle).css('top'))\r\n            : hH;\r\n\r\n        el.setAttribute('data-cx', centerX);\r\n        el.setAttribute('data-cy', centerY);\r\n\r\n        // if (isUndef(cached)) return;\r\n\r\n        // const $el = helper(el);\r\n\r\n        // const { dx, dy } = cached;\r\n\r\n        // const css = matrixToCSS(transform.matrix);\r\n\r\n        // const left = parseFloat(\r\n        //     el.style.left || $el.css('left')\r\n        // );\r\n\r\n        // const top = parseFloat(\r\n        //     el.style.top || $el.css('top')\r\n        // );\r\n\r\n        // css.left = `${left + dx}px`;\r\n        // css.top = `${top + dy}px`;\r\n\r\n        // $el.css(css);\r\n        // $controls.css(css);\r\n\r\n        this.storage.cached = null;\r\n    }\r\n\r\n    _processResize(dx, dy) {\r\n        const {\r\n            el,\r\n            storage,\r\n            options: { proportions }\r\n        } = this;\r\n\r\n        const {\r\n            controls,\r\n            coords,\r\n            cw,\r\n            ch,\r\n            transform,\r\n            refang,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        } = storage;\r\n\r\n        const ratio = doW || (!doW && !doH)\r\n            ? (cw + dx) / cw\r\n            : (ch + dy) / ch;\r\n\r\n        const newWidth = proportions ? cw * ratio : cw + dx,\r\n            newHeight = proportions ? ch * ratio : ch + dy;\r\n\r\n        if (newWidth < MIN_SIZE || newHeight < MIN_SIZE) return;\r\n\r\n        const matrix = [...transform.matrix];\r\n\r\n        const newCoords = rotatedTopLeft(\r\n            matrix[4],\r\n            matrix[5],\r\n            newWidth,\r\n            newHeight,\r\n            refang,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        );\r\n\r\n        const nx = coords.left - newCoords.left,\r\n            ny = coords.top - newCoords.top;\r\n\r\n        matrix[4] += nx;\r\n        matrix[5] += ny;\r\n\r\n        const css = matrixToCSS(matrix);\r\n\r\n        css.width = `${newWidth}px`;\r\n        css.height = `${newHeight}px`;\r\n\r\n        helper(controls).css(css);\r\n        helper(el).css(css);\r\n\r\n        storage.cached = {\r\n            dx: nx,\r\n            dy: ny\r\n        };\r\n        \r\n        return {\r\n            width: newWidth,\r\n            height: newHeight,\r\n            ox: nx,\r\n            oy: ny\r\n        };\r\n    }\r\n\r\n    _processMove(dx, dy) {\r\n        const {\r\n            el,\r\n            storage\r\n        } = this;\r\n\r\n        const {\r\n            controls,\r\n            transform: {\r\n                matrix,\r\n                parentMatrix\r\n            }\r\n        } = storage;\r\n\r\n        const pctm = [...parentMatrix];\r\n        pctm[4] = pctm[5] = 0;\r\n\r\n        const nMatrix = [...matrix];\r\n\r\n        nMatrix[4] = matrix[4] + dx;\r\n        nMatrix[5] = matrix[5] + dy;\r\n\r\n        const css = matrixToCSS(nMatrix);\r\n\r\n        helper(controls).css(css);\r\n        helper(el).css(css);\r\n\r\n        storage.cached = {\r\n            dx,\r\n            dy\r\n        };\r\n\r\n        return nMatrix;\r\n    }\r\n\r\n    _processRotate(radians) {\r\n        const {\r\n            el,\r\n            storage: {\r\n                controls,\r\n                transform,\r\n                center\r\n            }\r\n        } = this;\r\n\r\n        const {\r\n            matrix,\r\n            parentMatrix\r\n        } = transform;\r\n\r\n        const cos = floatToFixed(Math.cos(radians), 4),\r\n            sin = floatToFixed(Math.sin(radians), 4);\r\n\r\n        const translateMatrix = [\r\n            1,\r\n            0,\r\n            0,\r\n            1,\r\n            center.cx,\r\n            center.cy\r\n        ];\r\n\r\n        const rotMatrix = [\r\n            cos,\r\n            sin,\r\n            -sin,\r\n            cos,\r\n            0,\r\n            0\r\n        ];\r\n\r\n        const pctm = [...parentMatrix];\r\n        pctm[4] = pctm[5] = 0;\r\n\r\n        const resRotMatrix = multiplyMatrix(\r\n            matrixInvert(pctm),\r\n            multiplyMatrix(rotMatrix, pctm)\r\n        );\r\n\r\n        const nMatrix = multiplyMatrix(\r\n            multiplyMatrix(translateMatrix, resRotMatrix),\r\n            matrixInvert(translateMatrix)\r\n        );\r\n\r\n        const resMatrix = multiplyMatrix(nMatrix, matrix);\r\n\r\n        const css = matrixToCSS(resMatrix);\r\n\r\n        helper(controls).css(css);\r\n        helper(el).css(css);\r\n\r\n        return resMatrix;\r\n    }\r\n\r\n    _getState(params) {\r\n        const {\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        } = params;\r\n\r\n        const factor = revX !== revY\r\n            ? -1\r\n            : 1;\r\n\r\n        const {\r\n            el,\r\n            storage: {\r\n                handles,\r\n                controls,\r\n                parent\r\n            },\r\n            options: { container }\r\n        } = this;\r\n\r\n        const {\r\n            center: cHandle\r\n        } = handles;\r\n\r\n        const $controls = helper(controls);\r\n\r\n        const containerMatrix = parseMatrix(\r\n            getTransform(helper(container))\r\n        );\r\n\r\n        const matrix = parseMatrix(\r\n            getTransform(helper(controls))\r\n        );\r\n\r\n        const pMatrix = parseMatrix(\r\n            getTransform(helper(parent))\r\n        );\r\n\r\n        const refang = Math.atan2(\r\n            matrix[1], matrix[0]\r\n        ) * factor;\r\n\r\n        const parentMatrix = parent !== container\r\n            ? multiplyMatrix(\r\n                pMatrix,\r\n                containerMatrix\r\n            )\r\n            : containerMatrix;\r\n\r\n        const transform = {\r\n            matrix,\r\n            parentMatrix,\r\n            scX: Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]),\r\n            scY: Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3])\r\n        };\r\n\r\n        const cw = parseFloat($controls.css('width')),\r\n            ch = parseFloat($controls.css('height'));\r\n\r\n        // getting current coordinates considering rotation angle                                                                                                  \r\n        const coords = rotatedTopLeft(\r\n            matrix[4],\r\n            matrix[5],\r\n            cw,\r\n            ch,\r\n            refang,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        );\r\n\r\n        const hW = cw / 2,\r\n            hH = ch / 2;\r\n\r\n        const offset_ = getOffset(el),\r\n            isDefCenter = isDef(cHandle);\r\n\r\n        const centerX = isDefCenter\r\n            ? parseFloat(helper(cHandle).css('left'))\r\n            : hW;\r\n        const centerY = isDefCenter\r\n            ? parseFloat(helper(cHandle).css('top'))\r\n            : hH;\r\n\r\n        const cDelta = isDefCenter ? CENTER_DELTA : 0;\r\n\r\n        const { x: el_x, y: el_y } = matrixTransform(\r\n            {\r\n                x: offset_.left,\r\n                y: offset_.top\r\n            },\r\n            matrixInvert(parentMatrix)\r\n        );\r\n\r\n        return {\r\n            transform,\r\n            cw,\r\n            ch,\r\n            coords,\r\n            center: {\r\n                x: el_x + centerX - cDelta,\r\n                y: el_y + centerY - cDelta,\r\n                cx: -centerX + hW - cDelta,\r\n                cy: -centerY + hH - cDelta,\r\n                hx: centerX,\r\n                hy: centerY\r\n            },\r\n            factor,\r\n            refang,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        };\r\n    }\r\n\r\n    _moveCenterHandle(x, y) {\r\n        const { \r\n            handles: { center }, \r\n            center: { hx, hy }\r\n        } = this.storage;\r\n\r\n        const left = `${hx + x}px`,\r\n            top = `${hy + y}px`;\r\n\r\n        helper(center).css(\r\n            {\r\n                left,\r\n                top\r\n            }\r\n        );\r\n    }\r\n\r\n    resetCenterPoint() {\r\n        const {\r\n            handles: { center }\r\n        } = this.storage;\r\n\r\n        helper(center).css(\r\n            {\r\n                left: null,\r\n                top: null\r\n            }\r\n        );\r\n    }\r\n\r\n    fitControlsToSize() {}\r\n\r\n    get controls() {\r\n        return this.storage.controls;\r\n    }\r\n\r\n}\r\n\r\nfunction createHandler(classList) {\r\n    const element = document.createElement('div');\r\n    classList.forEach(cls => {\r\n        addClass(element, cls);\r\n    });\r\n    return element;\r\n}\n\nconst svgPoint = createSVGElement('svg').createSVGPoint();\r\nconst floatRE = /[+-]?\\d+(\\.\\d+)?/g;\r\n\r\nconst ALLOWED_ELEMENTS = [\r\n    'circle', 'ellipse',\r\n    'image', 'line',\r\n    'path', 'polygon',\r\n    'polyline', 'rect',\r\n    'text', 'g'\r\n];\r\n\r\nfunction checkChildElements(element) {\r\n    const arrOfElements = [];\r\n\r\n    if (isGroup(element)) {\r\n        forEach.call(element.childNodes, item => {\r\n            if (item.nodeType === 1) {\r\n                const tagName = item.tagName.toLowerCase();\r\n\r\n                if (ALLOWED_ELEMENTS.indexOf(tagName) !== -1) {\r\n                    if (tagName === 'g') {\r\n                        arrOfElements.push(...checkChildElements(item));\r\n                    }\r\n                    arrOfElements.push(item);\r\n                }\r\n            }\r\n        });\r\n    } else {\r\n        arrOfElements.push(element);\r\n    }\r\n\r\n    return arrOfElements;\r\n}\r\n\r\nfunction createSVGElement(name) {\r\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\r\n}\r\n\r\nfunction createSVGMatrix() {\r\n    return createSVGElement('svg').createSVGMatrix();\r\n}\r\n\r\nfunction getTransformToElement(toElement, g) {\r\n    const gTransform = g.getScreenCTM() || createSVGMatrix();\r\n    return gTransform.inverse().multiply(\r\n        toElement.getScreenCTM() || createSVGMatrix()\r\n    );\r\n}\r\n\r\nfunction matrixToString(m) {\r\n    const { a, b, c, d, e, f } = m;\r\n    return `matrix(${a},${b},${c},${d},${e},${f})`;\r\n}\r\n\r\nfunction pointTo(ctm, x, y) {\r\n    svgPoint.x = x;\r\n    svgPoint.y = y;\r\n    return svgPoint.matrixTransform(ctm);\r\n}\r\n\r\nfunction cloneMatrix(b) {\r\n    const a = createSVGMatrix();\r\n\r\n    a.a = b.a;\r\n    a.b = b.b;\r\n    a.c = b.c;\r\n    a.d = b.d;\r\n    a.e = b.e;\r\n    a.f = b.f;\r\n\r\n    return a;\r\n}\r\n\r\nfunction checkElement(el) {\r\n    const tagName = el.tagName.toLowerCase();\r\n\r\n    if (ALLOWED_ELEMENTS.indexOf(tagName) === -1) {\r\n        warn(\r\n            'Selected element is not allowed to transform. Allowed elements:\\n' +\r\n            'circle, ellipse, image, line, path, polygon, polyline, rect, text, g'\r\n        );\r\n        return false;\r\n    } else {\r\n        return true;\r\n    }\r\n}\r\n\r\nfunction isIdentity(matrix) {\r\n    const { a, b, c, d, e, f } = matrix;\r\n    return a === 1 &&\r\n        b === 0 &&\r\n        c === 0 &&\r\n        d === 1 &&\r\n        e === 0 &&\r\n        f === 0;\r\n}\r\n\r\nfunction createPoint(svg, x, y) {\r\n    if (isUndef(x) || isUndef(y)) {\r\n        return null;\r\n    }\r\n    const pt = svg.createSVGPoint();\r\n    pt.x = x;\r\n    pt.y = y;\r\n    return pt;\r\n}\r\n\r\nfunction isGroup(element) {\r\n    return element.tagName.toLowerCase() === 'g';\r\n}\r\n\r\nfunction parsePoints(pts) {\r\n    return pts.match(floatRE).reduce(\r\n        (result, value, index, array) => {\r\n            if (index % 2 === 0) {\r\n                result.push(array.slice(index, index + 2));\r\n            }\r\n            return result;\r\n        },\r\n        []\r\n    );\r\n}\n\nconst dRE = /\\s*([achlmqstvz])([^achlmqstvz]*)\\s*/gi;\r\nconst sepRE = /\\s*,\\s*|\\s+/g;\r\n\r\nfunction parsePath(path) {\r\n    let match = dRE.lastIndex = 0;\r\n\r\n    const serialized = [];\r\n\r\n    while ((match = dRE.exec(path))) {\r\n        const cmd = match[1];\r\n        const upCmd = cmd.toUpperCase();\r\n\r\n        // normalize the data\r\n        const data = match[2]\r\n            .replace(/([^e])-/g, '$1 -')\r\n            .replace(/ +/g, ' ');\r\n\r\n        serialized.push({\r\n            relative: cmd !== upCmd,\r\n            key: upCmd,\r\n            cmd: cmd,\r\n            values: data.trim().split(sepRE).map(val => {\r\n                if (!isNaN(val)) {\r\n                    return Number(val);\r\n                }\r\n            })\r\n        });\r\n    }\r\n\r\n    return serialized;\r\n}\r\n\r\nfunction movePath(params) {\r\n    const {\r\n        path,\r\n        dx,\r\n        dy\r\n    } = params;\r\n\r\n    try {\r\n        const serialized = parsePath(path);\r\n\r\n        let str = '';\r\n        let space = ' ';\r\n\r\n        let firstCommand = true;\r\n\r\n        for (let i = 0, len = serialized.length; i < len; i++) {\r\n            const item = serialized[i];\r\n\r\n            const {\r\n                values,\r\n                key: cmd,\r\n                relative\r\n            } = item;\r\n\r\n            const coordinates = [];\r\n\r\n            switch (cmd) {\r\n\r\n                case 'M': {\r\n                    for (let k = 0, len = values.length; k < len; k += 2) {\r\n                        let [x, y] = values.slice(k, k + 2);\r\n\r\n                        if (!(relative && !firstCommand)) {\r\n                            x += dx;\r\n                            y += dy;\r\n                        }\r\n\r\n                        coordinates.push(\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        firstCommand = false;\r\n                    }\r\n                    break;\r\n                }              \r\n                case 'A': {\r\n                    for (let k = 0, len = values.length; k < len; k += 7) {\r\n                        const set = values.slice(k, k + 7);\r\n\r\n                        if (!relative) {\r\n                            set[5] += dx;\r\n                            set[6] += dy;\r\n                        }\r\n\r\n                        coordinates.push(...set);\r\n                    }\r\n                    break;\r\n                }\r\n                case 'C': {\r\n                    for (let k = 0, len = values.length; k < len; k += 6) {\r\n                        const set = values.slice(k, k + 6);\r\n\r\n                        if (!relative) {\r\n                            set[0] += dx;\r\n                            set[1] += dy;\r\n                            set[2] += dx;\r\n                            set[3] += dy;\r\n                            set[4] += dx;\r\n                            set[5] += dy;\r\n                        }\r\n\r\n                        coordinates.push(...set);\r\n                    }\r\n                    break;\r\n                }\r\n                case 'H': {\r\n                    for (let k = 0, len = values.length; k < len; k += 1) {\r\n                        const set = values.slice(k, k + 1);\r\n\r\n                        if (!relative) {\r\n                            set[0] += dx;\r\n                        }\r\n\r\n                        coordinates.push(set[0]);\r\n                    }\r\n\r\n                    break;\r\n                }\r\n                case 'V': {\r\n                    for (let k = 0, len = values.length; k < len; k += 1) {\r\n                        const set = values.slice(k, k + 1);\r\n\r\n                        if (!relative) {\r\n                            set[0] += dy;\r\n                        }\r\n                        coordinates.push(set[0]);\r\n                    }\r\n\r\n                    break;\r\n                }\r\n                case 'L':\r\n                case 'T': {\r\n                    for (let k = 0, len = values.length; k < len; k += 2) {\r\n                        let [x, y] = values.slice(k, k + 2);\r\n\r\n                        if (!relative) {\r\n                            x += dx;\r\n                            y += dy;\r\n                        }\r\n\r\n                        coordinates.push(\r\n                            x,\r\n                            y\r\n                        );\r\n                    }\r\n                    break;\r\n                }\r\n                case 'Q':\r\n                case 'S': {\r\n                    for (let k = 0, len = values.length; k < len; k += 4) {\r\n                        let [x1, y1, x2, y2] = values.slice(k, k + 4);\r\n\r\n                        if (!relative) {\r\n                            x1 += dx;\r\n                            y1 += dy;\r\n                            x2 += dx;\r\n                            y2 += dy;\r\n                        }\r\n\r\n                        coordinates.push(\r\n                            x1,\r\n                            y1,\r\n                            x2,\r\n                            y2\r\n                        );\r\n                    }\r\n                    break;\r\n                }\r\n                case 'Z': {\r\n                    values[0] = '';\r\n                    space = '';\r\n                    break;\r\n                }\r\n\r\n            }\r\n\r\n            str += item.cmd + coordinates.join(',') + space;\r\n        }\r\n\r\n        return str;\r\n    } catch (err) {\r\n        warn('Path parsing error: ' + err);\r\n    }\r\n}\r\n\r\nfunction resizePath(params) {\r\n    const {\r\n        path,\r\n        localCTM\r\n    } = params;\r\n\r\n    try {\r\n        const serialized = parsePath(path);\r\n\r\n        let str = '';\r\n        let space = ' ';\r\n\r\n        const res = [];\r\n\r\n        let firstCommand = true;\r\n\r\n        for (let i = 0, len = serialized.length; i < len; i++) {\r\n            const item = serialized[i];\r\n\r\n            const {\r\n                values,\r\n                key: cmd,\r\n                relative\r\n            } = item;\r\n\r\n            switch (cmd) {\r\n\r\n                case 'A': {\r\n                //A rx ry x-axis-rotation large-arc-flag sweep-flag x y\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 7) {\r\n                        const [rx, ry, x_axis_rot, large_arc_flag, sweep_flag, x, y] =\r\n                            values.slice(k, k + 7);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n\r\n                        mtrx.e = mtrx.f = 0;\r\n\r\n                        const {\r\n                            x: newRx,\r\n                            y: newRy\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            rx,\r\n                            ry\r\n                        );\r\n\r\n                        coordinates.unshift(\r\n                            floatToFixed(newRx),\r\n                            floatToFixed(newRy),\r\n                            x_axis_rot,\r\n                            large_arc_flag,\r\n                            sweep_flag\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'C': {\r\n                //C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 6) {\r\n                        const [x1, y1, x2, y2, x, y] = values.slice(k, k + 6);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX1,\r\n                            y: resY1\r\n                        } = pointTo(\r\n                            mtrx,                          \r\n                            x1,\r\n                            y1\r\n                        );\r\n\r\n                        const {\r\n                            x: resX2,\r\n                            y: resY2\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x2,\r\n                            y2\r\n                        );\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX1),\r\n                            floatToFixed(resY1),\r\n                            floatToFixed(resX2),\r\n                            floatToFixed(resY2),\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                // this command makes impossible free transform within group\r\n                // todo: use proportional resizing only or need to be converted to L\r\n                case 'H': {\r\n                // H x (or h dx)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 1) {\r\n                        const [x] = values.slice(k, k + 1);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            0\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                // this command makes impossible free transform within group\r\n                // todo: use proportional resizing only or need to be converted to L\r\n                case 'V': {\r\n                // V y (or v dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 1) {\r\n                        const [y] = values.slice(k, k + 1);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            0,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resY)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'T':\r\n                case 'L': {\r\n                // T x y (or t dx dy)\r\n                // L x y (or l dx dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 2) {\r\n                        const [x, y] = values.slice(k, k + 2);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'M': {\r\n                // M x y (or dx dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 2) {\r\n                        const [x, y] = values.slice(k, k + 2);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative && !firstCommand) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n\r\n                        firstCommand = false;\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'Q': {\r\n                //Q x1 y1, x y (or q dx1 dy1, dx dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 4) {\r\n                        const [x1, y1, x, y] = values.slice(k, k + 4);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX1,\r\n                            y: resY1\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x1,\r\n                            y1\r\n                        );\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX1),\r\n                            floatToFixed(resY1),\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'S': {\r\n                //S x2 y2, x y (or s dx2 dy2, dx dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 4) {\r\n                        const [x2, y2, x, y] = values.slice(k, k + 4);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX2,\r\n                            y: resY2\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x2,\r\n                            y2\r\n                        );\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX2),\r\n                            floatToFixed(resY2),\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'Z': {\r\n                    res.push(['']);\r\n                    space = '';\r\n                    break;\r\n                }\r\n\r\n            }\r\n\r\n            str += item.cmd + res[i].join(',') + space;\r\n        }\r\n\r\n        return str;\r\n    } catch (err) {\r\n        warn('Path parsing error: ' + err);\r\n    }\r\n}\n\nconst MIN_SIZE$1 = 5;\r\nconst ROT_OFFSET = 50;\r\n\r\nclass DraggableSVG extends Transformable {\r\n\r\n    _init(el) {\r\n        const {\r\n            rotationPoint,\r\n            container,\r\n            themeColor,\r\n            resizable,\r\n            rotatable\r\n        } = this.options;\r\n\r\n        const wrapper = createSVGElement('g');\r\n        addClass(wrapper, 'sjx-svg-wrapper');\r\n        container.appendChild(wrapper);\r\n\r\n        const {\r\n            width: cw,\r\n            height: ch,\r\n            x: cx,\r\n            y: cy\r\n        } = el.getBBox();\r\n\r\n        const elCTM = getTransformToElement(el, container);\r\n        const box = createSVGElement('rect');\r\n\r\n        const attrs = [\r\n            ['width', cw],\r\n            ['height', ch],\r\n            ['x', cx],\r\n            ['y', cy],\r\n            ['fill', themeColor],\r\n            ['fill-opacity', 0.1],\r\n            ['stroke', themeColor],\r\n            ['stroke-dasharray', '3 3'],\r\n            ['vector-effect', 'non-scaling-stroke'],\r\n            ['transform', matrixToString(elCTM)]\r\n        ];\r\n\r\n        attrs.forEach(([key, value]) => {\r\n            box.setAttribute(key, value);\r\n        });\r\n\r\n        const handlesGroup = createSVGElement('g'),\r\n            normalLineGroup = createSVGElement('g'),\r\n            group = createSVGElement('g');\r\n\r\n        addClass(group, 'sjx-svg-box-group');\r\n        addClass(handlesGroup, 'sjx-svg-handles');\r\n        addClass(normalLineGroup, 'sjx-svg-normal-group');\r\n\r\n        group.appendChild(box);\r\n        wrapper.appendChild(group);\r\n        wrapper.appendChild(normalLineGroup);\r\n        wrapper.appendChild(handlesGroup);\r\n\r\n        const {\r\n            x: bX,\r\n            y: bY,\r\n            width: bW,\r\n            height: bH\r\n        } = box.getBBox();\r\n\r\n        const centerX = el.getAttribute('data-cx'),\r\n            centerY = el.getAttribute('data-cy');\r\n\r\n        const boxCTM = getTransformToElement(box, box.parentNode),\r\n            boxCenter = pointTo(boxCTM, bX + bW / 2, bY + bH / 2),\r\n            boxTL = pointTo(boxCTM, bX, bY),\r\n            boxTR = pointTo(boxCTM, bX + bW, bY),\r\n            boxMR = pointTo(boxCTM, bX + bW, bY + bH / 2);\r\n\r\n        const resizingHandles = {\r\n            tl: boxTL,\r\n            tr: boxTR,\r\n            br: pointTo(boxCTM, bX + bW, bY + bH),\r\n            bl: pointTo(boxCTM, bX, bY + bH),\r\n            tc: pointTo(boxCTM, bX + bW / 2, bY),\r\n            bc: pointTo(boxCTM, bX + bW / 2, bY + bH),\r\n            ml: pointTo(boxCTM, bX, bY + bH / 2),\r\n            mr: boxMR\r\n        };\r\n\r\n        let rotationHandles = {},\r\n            rotator = null;\r\n\r\n        if (rotatable) {\r\n            const theta = Math.atan2(\r\n                boxTL.y - boxTR.y,\r\n                boxTL.x - boxTR.x\r\n            );\r\n\r\n            rotator = {\r\n                x: boxMR.x - ROT_OFFSET * Math.cos(theta),\r\n                y: boxMR.y - ROT_OFFSET * Math.sin(theta)\r\n            }; \r\n\r\n            const normalLine = createSVGElement('line');\r\n\r\n            normalLine.x1.baseVal.value = boxMR.x;\r\n            normalLine.y1.baseVal.value = boxMR.y;\r\n            normalLine.x2.baseVal.value = rotator.x;\r\n            normalLine.y2.baseVal.value = rotator.y;\r\n\r\n            setLineStyle(normalLine, themeColor);\r\n            normalLineGroup.appendChild(normalLine);\r\n\r\n            let radius = null;\r\n\r\n            if (rotationPoint) {\r\n                radius = createSVGElement('line');\r\n\r\n                addClass(radius, 'sjx-hidden');\r\n\r\n                radius.x1.baseVal.value = boxCenter.x;\r\n                radius.y1.baseVal.value = boxCenter.y;\r\n                radius.x2.baseVal.value = centerX || boxCenter.x;\r\n                radius.y2.baseVal.value = centerY || boxCenter.y;\r\n\r\n                setLineStyle(radius, '#fe3232');\r\n                radius.setAttribute('opacity', 0.5);\r\n\r\n                normalLineGroup.appendChild(radius);\r\n            }\r\n\r\n            rotationHandles = {\r\n                normal: normalLine,\r\n                radius\r\n            };\r\n        }\r\n\r\n        const handles = {\r\n            ...(resizable && resizingHandles),\r\n            rotator,\r\n            center: rotationPoint && rotatable ? createPoint(container, centerX, centerY) || boxCenter : undefined\r\n        };\r\n\r\n        Object.keys(handles).forEach(key => {\r\n            const data = handles[key];\r\n            if (isUndef(data)) return;\r\n            const { x, y } = data;\r\n            const color = key === 'center'\r\n                ? '#fe3232'\r\n                : themeColor;\r\n\r\n            handles[key] = createHandler$1(\r\n                x,\r\n                y,\r\n                color,\r\n                key\r\n            );\r\n            handlesGroup.appendChild(handles[key]);\r\n        });\r\n\r\n        this.storage = {\r\n            wrapper,\r\n            box,\r\n            handles: {\r\n                ...handles,\r\n                ...rotationHandles\r\n            },\r\n            parent: el.parentNode,\r\n            center: {}\r\n        };\r\n\r\n        helper(wrapper)\r\n            .on('mousedown', this._onMouseDown)\r\n            .on('touchstart', this._onTouchStart);\r\n    }\r\n\r\n    _destroy() {\r\n        const {\r\n            wrapper\r\n        } = this.storage;\r\n\r\n        helper(wrapper)\r\n            .off('mousedown', this._onMouseDown)\r\n            .off('touchstart', this._onTouchStart);\r\n\r\n        wrapper.parentNode.removeChild(wrapper);\r\n    }\r\n\r\n    _cursorPoint({ clientX, clientY }) {\r\n        const {\r\n            container\r\n        } = this.options;\r\n\r\n        return pointTo(\r\n            container.getScreenCTM().inverse(),\r\n            clientX,\r\n            clientY\r\n        );\r\n    }\r\n\r\n    _pointToElement({ x, y }) {\r\n        const {\r\n            transform\r\n        } = this.storage;\r\n\r\n        const { ctm } = transform;\r\n        const matrix = ctm.inverse();\r\n\r\n        matrix.e = matrix.f = 0;\r\n\r\n        return this._applyMatrixToPoint(\r\n            matrix,\r\n            x,\r\n            y\r\n        );\r\n    }\r\n\r\n    _pointToControls({ x, y }) {\r\n        const {\r\n            transform\r\n        } = this.storage;\r\n\r\n        const { boxCTM } = transform;\r\n        const matrix = boxCTM.inverse();\r\n\r\n        matrix.e = matrix.f = 0;\r\n\r\n        return this._applyMatrixToPoint(\r\n            matrix,\r\n            x,\r\n            y\r\n        );\r\n    }\r\n\r\n    _applyMatrixToPoint(matrix, x, y) {\r\n        const {\r\n            container\r\n        } = this.options;\r\n\r\n        const pt = container.createSVGPoint();\r\n        pt.x = x;\r\n        pt.y = y;\r\n        return pt.matrixTransform(matrix);\r\n    }\r\n\r\n    _apply(actionName) {\r\n        const {\r\n            el: element,\r\n            storage,\r\n            options: { container }\r\n        } = this;\r\n\r\n        const {\r\n            box,\r\n            handles,\r\n            cached,\r\n            transform \r\n        } = storage;\r\n\r\n        const {\r\n            matrix,\r\n            boxCTM,\r\n            bBox,\r\n            ctm\r\n        } = transform;\r\n\r\n        const eBBox = element.getBBox();\r\n\r\n        const {\r\n            x: elX,\r\n            y: elY,\r\n            width: elW,\r\n            height: elH\r\n        } = eBBox;\r\n\r\n        const rotationPoint = isDef(handles.center)\r\n            ? pointTo(\r\n                boxCTM,\r\n                handles.center.cx.baseVal.value,\r\n                handles.center.cy.baseVal.value\r\n            )\r\n            : pointTo(\r\n                matrix,\r\n                elX + elW / 2,\r\n                elY + elH / 2\r\n            );\r\n\r\n        element.setAttribute('data-cx', rotationPoint.x);\r\n        element.setAttribute('data-cy', rotationPoint.y);\r\n\r\n        if (isUndef(cached)) return;\r\n\r\n        const {\r\n            scaleX,\r\n            scaleY,\r\n            dx,\r\n            dy,\r\n            ox,\r\n            oy\r\n        } = cached;\r\n\r\n        if (actionName === 'drag') {\r\n            if (dx === 0 && dy === 0) return;\r\n\r\n            const eM = createSVGMatrix();\r\n\r\n            eM.e = dx;\r\n            eM.f = dy;\r\n\r\n            const translateMatrix = eM.multiply(matrix)\r\n                .multiply(eM.inverse());\r\n\r\n            element.setAttribute(\r\n                'transform',\r\n                matrixToString(translateMatrix)\r\n            );\r\n\r\n            if (isGroup(element)) {\r\n                const els = checkChildElements(element);\r\n\r\n                els.forEach(child => {\r\n                    const pt = container.createSVGPoint();\r\n                    const ctm = getTransformToElement(element.parentNode, container).inverse();\r\n                    pt.x = ox;\r\n                    pt.y = oy;\r\n                    ctm.e = ctm.f = 0;\r\n                    const newPT = pt.matrixTransform(ctm);\r\n\r\n                    const eM = createSVGMatrix();\r\n\r\n                    eM.e = dx;\r\n                    eM.f = dy;\r\n\r\n                    const translateMatrix = eM.multiply(\r\n                        getTransformToElement(child, child.parentNode)\r\n                    ).multiply(eM.inverse());\r\n\r\n                    if (!isIdentity(translateMatrix)) {\r\n                        child.setAttribute(\r\n                            'transform',\r\n                            matrixToString(translateMatrix)\r\n                        );\r\n                    }\r\n\r\n                    if (!isGroup(child)) {\r\n                        applyTranslate(child, {\r\n                            x: newPT.x,\r\n                            y: newPT.y\r\n                        });\r\n                    }\r\n                });\r\n            } else {\r\n                applyTranslate(element, {\r\n                    x: dx,\r\n                    y: dy\r\n                });\r\n            }\r\n        }\r\n\r\n        if (actionName === 'resize') {\r\n            const {\r\n                x,\r\n                y,\r\n                width: newWidth,\r\n                height: newHeight\r\n            } = box.getBBox();\r\n\r\n            applyTransformToHandles(\r\n                storage,\r\n                {\r\n                    x,\r\n                    y,\r\n                    width: newWidth,\r\n                    height: newHeight,\r\n                    boxMatrix: null\r\n                }\r\n            );\r\n\r\n            if (isGroup(element)) {\r\n                const els = checkChildElements(element);\r\n\r\n                els.forEach(child => {\r\n                    if (!isGroup(child)) {\r\n                        applyResize(child, {\r\n                            scaleX,\r\n                            scaleY,\r\n                            defaultCTM: child.__ctm__,\r\n                            bBox: bBox,\r\n                            container,\r\n                            storage\r\n                        });\r\n                    }\r\n                });\r\n            } else {\r\n                applyResize(element, {\r\n                    scaleX,\r\n                    scaleY,\r\n                    defaultCTM: ctm,\r\n                    bBox: bBox,\r\n                    container,\r\n                    storage\r\n                });\r\n            }\r\n\r\n            element.setAttribute(\r\n                'transform',\r\n                matrixToString(matrix)\r\n            );\r\n        }\r\n\r\n        this.storage.cached = null;\r\n    }\r\n\r\n    _processResize(dx, dy) {\r\n        const {\r\n            el,\r\n            storage,\r\n            options: { proportions }\r\n        } = this;\r\n\r\n        const {\r\n            left,\r\n            top,\r\n            cw,\r\n            ch,\r\n            transform,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        } = storage;\r\n\r\n        const {\r\n            matrix,\r\n            scMatrix,\r\n            trMatrix,\r\n            scaleX: ptX,\r\n            scaleY: ptY\r\n        } = transform;\r\n\r\n        let {\r\n            width: newWidth,\r\n            height: newHeight\r\n        } = el.getBBox(); //box\r\n\r\n        const ratio = doW || (!doW && !doH)\r\n            ? (cw + dx) / cw\r\n            : (ch + dy) / ch;\r\n\r\n        newWidth = proportions ? cw * ratio : cw + dx;\r\n        newHeight = proportions ? ch * ratio : ch + dy;\r\n\r\n        if (Math.abs(newWidth) < MIN_SIZE$1 || Math.abs(newHeight) < MIN_SIZE$1) return;\r\n\r\n        const scaleX = newWidth / cw,\r\n            scaleY = newHeight / ch;\r\n\r\n        // setup scale matrix\r\n        scMatrix.a = scaleX;\r\n        scMatrix.b = 0;\r\n        scMatrix.c = 0;\r\n        scMatrix.d = scaleY;\r\n        scMatrix.e = 0;\r\n        scMatrix.f = 0;\r\n\r\n        // translate compensation matrix\r\n        trMatrix.e = ptX;\r\n        trMatrix.f = ptY;\r\n\r\n        //now must to do: translate(x y) scale(sx sy) translate(-x -y)\r\n        const scaleMatrix = trMatrix\r\n            .multiply(scMatrix)\r\n            .multiply(trMatrix.inverse());\r\n\r\n        const res = matrix.multiply(scaleMatrix);\r\n\r\n        el.setAttribute(\r\n            'transform',\r\n            matrixToString(res)\r\n        );\r\n\r\n        const deltaW = newWidth - cw,\r\n            deltaH = newHeight - ch;\r\n\r\n        const newX = left - deltaW * (doH ? 0.5 : (revX ? 1 : 0)),\r\n            newY = top - deltaH * (doW ? 0.5 : (revY ? 1 : 0));\r\n\r\n        this.storage.cached = {\r\n            scaleX,\r\n            scaleY\r\n        };\r\n\r\n        const finalValues = {\r\n            x: newX,\r\n            y: newY,\r\n            width: newWidth,\r\n            height: newHeight\r\n        };\r\n\r\n        applyTransformToHandles(\r\n            storage,\r\n            {\r\n                ...finalValues,\r\n                boxMatrix: null\r\n            }\r\n        );\r\n\r\n        return finalValues;\r\n    }\r\n\r\n    _processMove(dx, dy) {\r\n        const {\r\n            transform,\r\n            wrapper,\r\n            center\r\n        } = this.storage;\r\n\r\n        const {\r\n            matrix,\r\n            trMatrix,\r\n            scMatrix,\r\n            wrapperMatrix,\r\n            parentMatrix\r\n        } = transform;\r\n\r\n        scMatrix.e = dx;\r\n        scMatrix.f = dy;\r\n\r\n        const moveWrapperMtrx = scMatrix.multiply(wrapperMatrix);\r\n\r\n        wrapper.setAttribute(\r\n            'transform',\r\n            matrixToString(moveWrapperMtrx)\r\n        );\r\n\r\n        parentMatrix.e = parentMatrix.f = 0;\r\n        const { x, y } = pointTo(\r\n            parentMatrix.inverse(),\r\n            dx,\r\n            dy\r\n        );\r\n\r\n        trMatrix.e = x;\r\n        trMatrix.f = y;\r\n\r\n        const moveElementMtrx = trMatrix.multiply(matrix);\r\n\r\n        this.el.setAttribute(\r\n            'transform',\r\n            matrixToString(moveElementMtrx)\r\n        );\r\n\r\n        this.storage.cached = {\r\n            dx: x,\r\n            dy: y,\r\n            ox: dx,\r\n            oy: dy\r\n        };\r\n\r\n        if (center.isShifted) {\r\n            const radiusMatrix = wrapperMatrix.inverse();\r\n            radiusMatrix.e = radiusMatrix.f = 0;\r\n            const { x: nx, y: ny } = pointTo(\r\n                radiusMatrix,\r\n                dx,\r\n                dy\r\n            );\r\n\r\n            this._moveCenterHandle(-nx, -ny);\r\n        }\r\n\r\n        return moveElementMtrx;\r\n    }\r\n\r\n    _processRotate(radians) {\r\n        const {\r\n            center,\r\n            transform,\r\n            wrapper\r\n        } = this.storage;\r\n\r\n        const {\r\n            matrix,\r\n            wrapperMatrix,\r\n            parentMatrix,\r\n            trMatrix,\r\n            scMatrix,\r\n            rotMatrix\r\n        } = transform;\r\n\r\n        const cos = floatToFixed(Math.cos(radians)),\r\n            sin = floatToFixed(Math.sin(radians));\r\n\r\n        // rotate(a cx cy) is equivalent to translate(cx cy) rotate(a) translate(-cx -cy)\r\n        trMatrix.e = center.x;\r\n        trMatrix.f = center.y;\r\n\r\n        rotMatrix.a = cos;\r\n        rotMatrix.b = sin;\r\n        rotMatrix.c = - sin;\r\n        rotMatrix.d = cos;\r\n\r\n        const wrapMatrix = trMatrix.multiply(rotMatrix)\r\n            .multiply(trMatrix.inverse())\r\n            .multiply(wrapperMatrix);\r\n\r\n        wrapper.setAttribute(\r\n            'transform',\r\n            matrixToString(wrapMatrix)\r\n        );\r\n\r\n        scMatrix.e = center.el_x;\r\n        scMatrix.f = center.el_y;\r\n\r\n        parentMatrix.e = parentMatrix.f = 0;\r\n        const resRotMatrix = parentMatrix.inverse()\r\n            .multiply(rotMatrix)\r\n            .multiply(parentMatrix);\r\n\r\n        const rotateMatrix = scMatrix.multiply(resRotMatrix)\r\n            .multiply(scMatrix.inverse());\r\n\r\n        const elMatrix = rotateMatrix.multiply(matrix);\r\n\r\n        this.el.setAttribute(\r\n            'transform',\r\n            matrixToString(elMatrix)\r\n        );\r\n\r\n        return elMatrix;\r\n    }\r\n\r\n    _getState({ revX, revY, doW, doH }) {\r\n        const {\r\n            el: element,\r\n            storage,\r\n            options: { container }\r\n        } = this;\r\n\r\n        const {\r\n            box,\r\n            wrapper,\r\n            parent,\r\n            handles: { center: cHandle }\r\n        } = storage;\r\n\r\n        const eBBox = element.getBBox();\r\n\r\n        const {\r\n            x: el_x,\r\n            y: el_y,\r\n            width: el_w,\r\n            height: el_h\r\n        } = eBBox;\r\n\r\n        const {\r\n            width: cw,\r\n            height: ch,\r\n            x: c_left,\r\n            y: c_top\r\n        } = box.getBBox();\r\n\r\n        const elMatrix = getTransformToElement(element, parent),\r\n            ctm = getTransformToElement(element, container),\r\n            boxCTM = getTransformToElement(box.parentNode, container);\r\n\r\n        const parentMatrix = getTransformToElement(parent, container);\r\n\r\n        const scaleX = el_x + el_w * (doH ? 0.5 : revX ? 1 : 0),\r\n            scaleY = el_y + el_h * (doW ? 0.5 : revY ? 1 : 0);\r\n\r\n        const transform = {\r\n            matrix: elMatrix,\r\n            ctm,\r\n            boxCTM,\r\n            parentMatrix,\r\n            wrapperMatrix: getTransformToElement(wrapper, wrapper.parentNode),\r\n            trMatrix: createSVGMatrix(),\r\n            scMatrix: createSVGMatrix(),\r\n            rotMatrix: createSVGMatrix(),\r\n            scaleX,\r\n            scaleY,\r\n            scX: Math.sqrt(ctm.a * ctm.a + ctm.b * ctm.b),\r\n            scY: Math.sqrt(ctm.c * ctm.c + ctm.d * ctm.d),\r\n            bBox: eBBox\r\n        };\r\n\r\n        const boxCenterX = c_left + cw / 2,\r\n            boxCenterY = c_top + ch / 2;\r\n\r\n        const centerX = cHandle\r\n                ? cHandle.cx.baseVal.value\r\n                : boxCenterX,\r\n            centerY = cHandle\r\n                ? cHandle.cy.baseVal.value\r\n                : boxCenterY;\r\n\r\n        // c-handle's coordinates\r\n        const { x: bcx, y: bcy } = pointTo(\r\n            boxCTM,\r\n            centerX,\r\n            centerY\r\n        );\r\n\r\n        // element's center coordinates\r\n        const { x: elcx, y: elcy } = isDef(cHandle)\r\n            ? pointTo(\r\n                parentMatrix.inverse(),\r\n                bcx,\r\n                bcy\r\n            )\r\n            : pointTo(\r\n                elMatrix,\r\n                el_x + el_w / 2,\r\n                el_y + el_h / 2\r\n            );\r\n\r\n        // box's center coordinates\r\n        const { x: rcx, y: rcy } = pointTo(\r\n            getTransformToElement(box, container),\r\n            boxCenterX,\r\n            boxCenterY\r\n        );\r\n\r\n        checkChildElements(element).forEach(child => {\r\n            child.__ctm__ = getTransformToElement(child, container);\r\n        });\r\n\r\n        return {\r\n            transform,\r\n            cw,\r\n            ch,\r\n            center: {\r\n                x: cHandle ? bcx : rcx,\r\n                y: cHandle ? bcy : rcy,\r\n                el_x: elcx,\r\n                el_y: elcy,\r\n                hx: cHandle ? cHandle.cx.baseVal.value : null,\r\n                hy: cHandle ? cHandle.cy.baseVal.value : null,\r\n                isShifted: (floatToFixed(rcx, 3) !== floatToFixed(bcx, 3)) &&\r\n                    (floatToFixed(rcy, 3) !== floatToFixed(bcy, 3))\r\n            },\r\n            left: c_left,\r\n            top: c_top,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        };\r\n    }\r\n\r\n    _moveCenterHandle(x, y) {\r\n        const {\r\n            handles: { center, radius },\r\n            center: { hx, hy }\r\n        } = this.storage;\r\n\r\n        if (isUndef(center)) return;\r\n\r\n        const mx = hx + x,\r\n            my = hy + y;\r\n\r\n        center.cx.baseVal.value = mx;\r\n        center.cy.baseVal.value = my;\r\n\r\n        radius.x2.baseVal.value = mx;\r\n        radius.y2.baseVal.value = my;\r\n    }\r\n\r\n    resetCenterPoint() {\r\n        const {\r\n            box,\r\n            handles: { center, radius }\r\n        } = this.storage;\r\n\r\n        const {\r\n            width: cw,\r\n            height: ch,\r\n            x: c_left,\r\n            y: c_top\r\n        } = box.getBBox();\r\n\r\n        const matrix = getTransformToElement(box, box.parentNode);\r\n\r\n        const { x: cx, y: cy } = pointTo(\r\n            matrix,\r\n            c_left + cw / 2,\r\n            c_top + ch / 2\r\n        );\r\n\r\n        center.cx.baseVal.value = cx;\r\n        center.cy.baseVal.value = cy;\r\n        center.isShifted = false;\r\n\r\n        radius.x2.baseVal.value = cx;\r\n        radius.y2.baseVal.value = cy;\r\n    }\r\n\r\n    fitControlsToSize() {\r\n        const { \r\n            el, \r\n            storage: { box, wrapper }, \r\n            options: { container }\r\n        } = this;\r\n\r\n        const {\r\n            width,\r\n            height,\r\n            x,\r\n            y\r\n        } = el.getBBox();\r\n\r\n        const containerMatrix = getTransformToElement(\r\n            el,\r\n            container\r\n        );\r\n        \r\n        wrapper.removeAttribute('transform');\r\n        box.setAttribute('transform', matrixToString(containerMatrix));\r\n\r\n        applyTransformToHandles(\r\n            this.storage,\r\n            {\r\n                x,\r\n                y,\r\n                width,\r\n                height,\r\n                boxMatrix: containerMatrix\r\n            }\r\n        );\r\n    }\r\n\r\n    get controls() {\r\n        return this.storage.wrapper;\r\n    }\r\n\r\n}\r\n\r\nfunction applyTranslate(element, { x, y }) {\r\n    const attrs = [];\r\n\r\n    switch (element.tagName.toLowerCase()) {\r\n\r\n        case 'text': {\r\n            const resX = isDef(element.x.baseVal[0])\r\n                ? element.x.baseVal[0].value + x\r\n                : (Number(element.getAttribute('x')) || 0) + x;\r\n            const resY = isDef(element.y.baseVal[0])\r\n                ? element.y.baseVal[0].value + y\r\n                : (Number(element.getAttribute('y')) || 0) + y;\r\n\r\n            attrs.push(\r\n                ['x', resX],\r\n                ['y', resY]\r\n            );\r\n            break;\r\n        }\r\n        case 'use':\r\n        case 'image':\r\n        case 'rect': {\r\n            const resX = isDef(element.x.baseVal.value)\r\n                ? element.x.baseVal.value + x\r\n                : (Number(element.getAttribute('x')) || 0) + x;\r\n            const resY = isDef(element.y.baseVal.value)\r\n                ? element.y.baseVal.value + y\r\n                : (Number(element.getAttribute('y')) || 0) + y;\r\n\r\n            attrs.push(\r\n                ['x', resX],\r\n                ['y', resY]\r\n            );\r\n            break;\r\n        }\r\n        case 'circle':\r\n        case 'ellipse': {\r\n            const resX = element.cx.baseVal.value + x,\r\n                resY = element.cy.baseVal.value + y;\r\n\r\n            attrs.push(\r\n                ['cx', resX],\r\n                ['cy', resY]\r\n            );\r\n            break;\r\n        }\r\n        case 'line': {\r\n            const resX1 = element.x1.baseVal.value + x,\r\n                resY1 = element.y1.baseVal.value + y,\r\n                resX2 = element.x2.baseVal.value + x,\r\n                resY2 = element.y2.baseVal.value + y;\r\n\r\n            attrs.push(\r\n                ['x1', resX1],\r\n                ['y1', resY1],\r\n                ['x2', resX2],\r\n                ['y2', resY2]\r\n            );\r\n            break;\r\n        }\r\n        case 'polygon':\r\n        case 'polyline': {\r\n            const points = parsePoints(element.getAttribute('points'));\r\n            const result = points.map(item => {\r\n                item[0] = Number(item[0]) + x;\r\n                item[1] = Number(item[1]) + y;\r\n\r\n                return item.join(' ');\r\n            }).join(' ');\r\n\r\n            attrs.push(\r\n                ['points', result]\r\n            );\r\n            break;\r\n        }\r\n        case 'path': {\r\n            const path = element.getAttribute('d');\r\n\r\n            attrs.push(['d', movePath(\r\n                {\r\n                    path,\r\n                    dx: x,\r\n                    dy: y\r\n                }\r\n            )]);\r\n            break;\r\n        }\r\n\r\n    }\r\n\r\n    attrs.forEach(item => {\r\n        element.setAttribute(item[0], item[1]);\r\n    });\r\n}\r\n\r\nfunction applyResize(element, data) {\r\n    const {\r\n        scaleX,\r\n        scaleY,\r\n        bBox,\r\n        defaultCTM,\r\n        container\r\n    } = data;\r\n\r\n    const {\r\n        width: boxW,\r\n        height: boxH\r\n    } = bBox;\r\n\r\n    const attrs = [];\r\n\r\n    const ctm = getTransformToElement(element, container);\r\n    const localCTM = defaultCTM.inverse().multiply(ctm);\r\n\r\n    switch (element.tagName.toLowerCase()) {\r\n\r\n        case 'text': {\r\n            const x = isDef(element.x.baseVal[0])\r\n                ? element.x.baseVal[0].value\r\n                : (Number(element.getAttribute('x')) || 0);\r\n            const y = isDef(element.y.baseVal[0])\r\n                ? element.y.baseVal[0].value\r\n                : (Number(element.getAttribute('y')) || 0);\r\n\r\n            const {\r\n                x: resX,\r\n                y: resY\r\n            } = pointTo(\r\n                localCTM,\r\n                x,\r\n                y\r\n            );\r\n\r\n            attrs.push(\r\n                ['x', resX + (scaleX < 0 ? boxW : 0)],\r\n                ['y', resY + (scaleY < 0 ? boxH : 0)]\r\n            );\r\n            break;\r\n        }\r\n        case 'circle': {\r\n            const r = element.r.baseVal.value,\r\n                cx = element.cx.baseVal.value,\r\n                cy = element.cy.baseVal.value,\r\n                newR = r * (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\r\n\r\n            const {\r\n                x: resX,\r\n                y: resY\r\n            } = pointTo(\r\n                localCTM,\r\n                cx,\r\n                cy\r\n            );\r\n\r\n            attrs.push(\r\n                ['r', newR],\r\n                ['cx', resX],\r\n                ['cy', resY]\r\n            );\r\n            break;\r\n        }\r\n        case 'image':\r\n        case 'rect': {\r\n            const width = element.width.baseVal.value,\r\n                height = element.height.baseVal.value,\r\n                x = element.x.baseVal.value,\r\n                y = element.y.baseVal.value;\r\n\r\n            const {\r\n                x: resX,\r\n                y: resY\r\n            } = pointTo(\r\n                localCTM,\r\n                x,\r\n                y\r\n            );\r\n\r\n            const newWidth = Math.abs(width * scaleX),\r\n                newHeight = Math.abs(height * scaleY);\r\n\r\n            attrs.push(\r\n                ['x', resX - (scaleX < 0 ? newWidth : 0)],\r\n                ['y', resY - (scaleY < 0 ? newHeight : 0)],\r\n                ['width', newWidth],\r\n                ['height', newHeight]\r\n            );\r\n            break;\r\n        }\r\n        case 'ellipse': {\r\n            const rx = element.rx.baseVal.value,\r\n                ry = element.ry.baseVal.value,\r\n                cx = element.cx.baseVal.value,\r\n                cy = element.cy.baseVal.value;\r\n\r\n            const {\r\n                x: cx1,\r\n                y: cy1\r\n            } = pointTo(\r\n                localCTM,\r\n                cx,\r\n                cy\r\n            );\r\n\r\n            const scaleMatrix = createSVGMatrix();\r\n\r\n            scaleMatrix.a = scaleX;\r\n            scaleMatrix.d = scaleY;\r\n\r\n            const {\r\n                x: nRx,\r\n                y: nRy\r\n            } = pointTo(\r\n                scaleMatrix,\r\n                rx,\r\n                ry\r\n            );\r\n\r\n            attrs.push(\r\n                ['rx', Math.abs(nRx)],\r\n                ['ry', Math.abs(nRy)],\r\n                ['cx', cx1],\r\n                ['cy', cy1]\r\n            );\r\n            break;\r\n        }\r\n        case 'line': {\r\n            const resX1 = element.x1.baseVal.value,\r\n                resY1 = element.y1.baseVal.value,\r\n                resX2 = element.x2.baseVal.value,\r\n                resY2 = element.y2.baseVal.value;\r\n\r\n            const {\r\n                x: resX1_,\r\n                y: resY1_\r\n            } = pointTo(\r\n                localCTM,\r\n                resX1,\r\n                resY1\r\n            );\r\n\r\n            const {\r\n                x: resX2_,\r\n                y: resY2_\r\n            } = pointTo(\r\n                localCTM,\r\n                resX2,\r\n                resY2\r\n            );\r\n\r\n            attrs.push(\r\n                ['x1', resX1_],\r\n                ['y1', resY1_],\r\n                ['x2', resX2_],\r\n                ['y2', resY2_]\r\n            );\r\n            break;\r\n        }\r\n        case 'polygon':\r\n        case 'polyline': {\r\n            const points = parsePoints(element.getAttribute('points'));\r\n            const result = points.map(item => {\r\n                const {\r\n                    x,\r\n                    y\r\n                } = pointTo(\r\n                    localCTM,\r\n                    Number(item[0]),\r\n                    Number(item[1])\r\n                );\r\n\r\n                item[0] = x;\r\n                item[1] = y;\r\n\r\n                return item.join(' ');\r\n            }).join(' ');\r\n\r\n            attrs.push(['points', result]);\r\n            break;\r\n        }\r\n        case 'path': {\r\n            const path = element.getAttribute('d');\r\n\r\n            attrs.push(['d', resizePath(\r\n                {\r\n                    path,\r\n                    localCTM\r\n                }\r\n            )]);\r\n            break;\r\n        }\r\n\r\n    }\r\n\r\n    attrs.forEach(([key, value]) => {\r\n        element.setAttribute(key, value);\r\n    });\r\n}\r\n\r\nfunction applyTransformToHandles(\r\n    storage,\r\n    data\r\n) {\r\n    const {\r\n        box,\r\n        handles,\r\n        center\r\n    } = storage;\r\n\r\n    let {\r\n        x,\r\n        y,\r\n        width,\r\n        height,\r\n        boxMatrix\r\n    } = data;\r\n\r\n    const hW = width / 2,\r\n        hH = height / 2;\r\n\r\n    const forced = boxMatrix !== null;\r\n\r\n    const boxCTM = !forced\r\n        ? getTransformToElement(\r\n            box,\r\n            box.parentNode\r\n        )\r\n        : boxMatrix;\r\n\r\n    const boxCenter = pointTo(boxCTM, x + hW, y + hH);\r\n\r\n    const attrs = {\r\n        tl: pointTo(boxCTM, x, y),\r\n        tr: pointTo(boxCTM, x + width, y),\r\n        br: pointTo(boxCTM, x + width, y + height),\r\n        bl: pointTo(boxCTM, x, y + height),\r\n        tc: pointTo(boxCTM, x + hW, y),\r\n        bc: pointTo(boxCTM, x + hW, y + height),\r\n        ml: pointTo(boxCTM, x, y + hH),\r\n        mr: pointTo(boxCTM, x + width, y + hH),\r\n        rotator: {},\r\n        center: isDef(handles.center) && !center.isShifted ? boxCenter : undefined\r\n    };\r\n\r\n    // if (forced) { \r\n    //     attrs.center = pointTo(\r\n    //         boxCTM, \r\n    //         center.x, \r\n    //         center.y\r\n    //     );\r\n    //     console.log(attrs.center);\r\n    // }\r\n\r\n    const theta = Math.atan2(\r\n        attrs.tl.y - attrs.tr.y,\r\n        attrs.tl.x - attrs.tr.x\r\n    );\r\n\r\n    attrs.rotator.x = attrs.mr.x - ROT_OFFSET * Math.cos(theta);\r\n    attrs.rotator.y = attrs.mr.y - ROT_OFFSET * Math.sin(theta);\r\n\r\n    const {\r\n        normal,\r\n        radius\r\n    } = handles;\r\n\r\n    if (isDef(normal)) {\r\n        normal.x1.baseVal.value = attrs.mr.x;\r\n        normal.y1.baseVal.value = attrs.mr.y;\r\n        normal.x2.baseVal.value = attrs.rotator.x;\r\n        normal.y2.baseVal.value = attrs.rotator.y;\r\n    }\r\n   \r\n    if (isDef(radius)) {\r\n        radius.x1.baseVal.value = boxCenter.x;\r\n        radius.y1.baseVal.value = boxCenter.y;\r\n        if (!center.isShifted) {\r\n            radius.x2.baseVal.value = boxCenter.x;\r\n            radius.y2.baseVal.value = boxCenter.y;\r\n        }\r\n    }\r\n\r\n    x += width < 0 ? width : 0;\r\n    y += height < 0 ? height : 0;\r\n\r\n    const boxAttrs = {\r\n        x,\r\n        y,\r\n        width: Math.abs(width),\r\n        height: Math.abs(height)\r\n    };\r\n\r\n    Object.keys(boxAttrs).forEach(attr => {\r\n        box.setAttribute(attr, boxAttrs[attr]);\r\n    });\r\n\r\n    Object.keys(attrs).forEach(key => {\r\n        const hdl = handles[key];\r\n        const attr = attrs[key];\r\n        if (isUndef(attr) || isUndef(hdl)) return;\r\n        hdl.setAttribute('cx', attr.x);\r\n        hdl.setAttribute('cy', attr.y);\r\n    });\r\n}\r\n\r\nfunction createHandler$1(l, t, color, key) {\r\n    const handler = createSVGElement('circle');\r\n    addClass(handler, `sjx-svg-hdl-${key}`);\r\n\r\n    const items = {\r\n        cx: l,\r\n        cy: t,\r\n        r: 5.5,\r\n        fill: color,\r\n        stroke: '#fff',\r\n        'fill-opacity': 1,\r\n        'vector-effect': 'non-scaling-stroke',\r\n        'stroke-width': 1\r\n    };\r\n\r\n    Object.keys(items).map(key => {\r\n        handler.setAttribute(key, items[key]);\r\n    });\r\n\r\n    return handler;\r\n}\r\n\r\nfunction setLineStyle(line, color) {\r\n    line.setAttribute('stroke', color);\r\n    line.setAttribute('stroke-dasharray', '3 3');\r\n    line.setAttribute('vector-effect', 'non-scaling-stroke');\r\n}\n\n// factory method for creating draggable elements\r\nfunction drag(options, obInstance) {\r\n    if (this.length) {\r\n        const Ob = (isDef(obInstance) && obInstance instanceof Observable)\r\n            ? obInstance\r\n            : new Observable();\r\n\r\n        return arrReduce.call(this, (result, item) => {\r\n            if (!(item instanceof SVGElement)) {\r\n                result.push(\r\n                    new Draggable(item, options, Ob)\r\n                );\r\n            } else {\r\n                if (checkElement(item)) {\r\n                    result.push(\r\n                        new DraggableSVG(item, options, Ob)\r\n                    );\r\n                }\r\n            }\r\n            return result;\r\n        }, []);\r\n    }\r\n}\n\nclass Cloneable extends SubjectModel {\r\n\r\n    constructor(el, options) {\r\n        super(el);\r\n        this.enable(options);\r\n    }\r\n\r\n    _init() {\r\n        const { \r\n            el, \r\n            options \r\n        } = this;\r\n        const $el = helper(el);\r\n\r\n        const {\r\n            style,\r\n            appendTo\r\n        } = options;\r\n\r\n        const css = {\r\n            position: 'absolute',\r\n            'z-index': '2147483647',\r\n            ...style\r\n        };\r\n\r\n        this.storage = {\r\n            css,\r\n            parent: isDef(appendTo) ? helper(appendTo)[0] : document.body\r\n        };\r\n\r\n        $el.on('mousedown', this._onMouseDown)\r\n            .on('touchstart', this._onTouchStart);\r\n\r\n        EVENTS.slice(0, 3).forEach((eventName) => {\r\n            this.eventDispatcher.registerEvent(eventName);\r\n        });\r\n    }\r\n\r\n    _processOptions(options) {\r\n        let _style = {},\r\n            _appendTo = null,\r\n            _stack = document,\r\n            _onInit = () => {},\r\n            _onMove = () => {},\r\n            _onDrop = () => {},\r\n            _onDestroy = () => {};\r\n        \r\n        if (isDef(options)) {\r\n            const {\r\n                style,\r\n                appendTo,\r\n                stack,\r\n                onInit,\r\n                onMove,\r\n                onDrop,\r\n                onDestroy\r\n            } = options;\r\n\r\n            _style = (isDef(style) && typeof style === 'object') ? style : _style;\r\n            _appendTo = appendTo || null;\r\n    \r\n            const dropZone = isDef(stack) \r\n                ? helper(stack)[0] \r\n                : document;\r\n    \r\n            _onInit = createMethod(onInit);\r\n            _onMove = createMethod(onMove);\r\n            _onDrop = isFunc(onDrop)\r\n                ? function(evt) {\r\n                    const {\r\n                        clone\r\n                    } = this.storage;\r\n    \r\n                    const result = objectsCollide(\r\n                        clone,\r\n                        dropZone\r\n                    );\r\n    \r\n                    if (result) {\r\n                        onDrop.call(this, evt, this.el, clone);\r\n                    }\r\n                }\r\n                : () => {};\r\n            _onDestroy = createMethod(onDestroy);\r\n        }\r\n        \r\n        this.options = {\r\n            style: _style,\r\n            appendTo: _appendTo,\r\n            stack: _stack\r\n        };\r\n\r\n        this.proxyMethods = {\r\n            onInit: _onInit,\r\n            onDrop: _onDrop,\r\n            onMove: _onMove,\r\n            onDestroy: _onDestroy\r\n        };\r\n    }\r\n\r\n    _start({ clientX, clientY }) {\r\n        const { \r\n            storage,\r\n            el\r\n        } = this;\r\n    \r\n        const {\r\n            parent,\r\n            css\r\n        } = storage; \r\n    \r\n        const { left, top } = getOffset(parent);\r\n    \r\n        css.left = `${(clientX - left)}px`;\r\n        css.top = `${(clientY - top)}px`;\r\n    \r\n        const clone = el.cloneNode(true);\r\n        helper(clone).css(css);\r\n    \r\n        storage.clientX = clientX;\r\n        storage.clientY = clientY;\r\n        storage.cx = clientX;\r\n        storage.cy = clientY;\r\n        storage.clone = clone;\r\n    \r\n        helper(parent)[0].appendChild(clone);\r\n        this._draw();\r\n    }\r\n\r\n    _moving({ clientX, clientY }) {    \r\n        const { storage } = this;\r\n    \r\n        storage.clientX = clientX;\r\n        storage.clientY = clientY;\r\n        storage.doDraw = true;\r\n        storage.doMove = true;\r\n    }\r\n    \r\n    _end(e) {\r\n        const { storage } = this;\r\n    \r\n        const {\r\n            clone,\r\n            frameId\r\n        } = storage;\r\n    \r\n        storage.doDraw = false;\r\n        cancelAnimFrame(frameId);\r\n    \r\n        if (isUndef(clone)) return;\r\n    \r\n        this.proxyMethods.onDrop.call(this, e);\r\n        clone.parentNode.removeChild(clone);\r\n    \r\n        delete storage.clone;\r\n    }\r\n\r\n    _animate() {\r\n        const { storage } = this;\r\n    \r\n        storage.frameId = requestAnimFrame(this._animate);\r\n\r\n        const {\r\n            doDraw,\r\n            clientX,\r\n            clientY,\r\n            cx,\r\n            cy\r\n        } = storage;\r\n\r\n        if (!doDraw) return;\r\n        storage.doDraw = false;\r\n\r\n        this._drag(\r\n            { \r\n                dx: clientX - cx,\r\n                dy: clientY - cy\r\n            }\r\n        );\r\n    }\r\n\r\n    _processMove(dx, dy) {\r\n        const {\r\n            clone\r\n        } = this.storage;\r\n\r\n        const translate = `translate(${dx}px, ${dy}px)`;\r\n\r\n        helper(clone).css({\r\n            transform: translate,\r\n            webkitTranform: translate,\r\n            mozTransform: translate,\r\n            msTransform: translate,\r\n            otransform: translate \r\n        });\r\n    }\r\n    \r\n    _destroy() {\r\n        const {\r\n            storage,\r\n            proxyMethods,\r\n            el\r\n        } = this;\r\n\r\n        if (isUndef(storage)) return;\r\n        helper(el)\r\n            .off('mousedown', this._onMouseDown)\r\n            .off('touchstart', this._onTouchStart);\r\n\r\n        proxyMethods.onDestroy.call(this, el);\r\n        delete this.storage;\r\n    }\r\n\r\n    disable() {\r\n        this._destroy();\r\n    }\r\n\r\n}\n\nfunction clone(options) {\n    if (this.length) {\n        return arrMap.call(this, item => {\n            return new Cloneable(item, options);\n        });\n    }\n}\n\nclass Subjx extends Helper {\r\n\r\n    drag() {\r\n        return drag.call(this, ...arguments);\r\n    }\r\n\r\n    clone() {\r\n        return clone.call(this, ...arguments);\r\n    }\r\n\r\n}\n\nfunction subjx(params) {\r\n    return new Subjx(params);\r\n}\r\n\r\nObject.defineProperty(subjx, 'createObservable', {\r\n    value: () => {\r\n        return new Observable();\r\n    }\r\n});\r\n\r\nObject.defineProperty(subjx, 'Subjx', {\r\n    value: Subjx\r\n});\r\n\r\nObject.defineProperty(subjx, 'Observable', {\r\n    value: Observable\r\n});\n\nmodule.exports = subjx;\n","'use strict';\r\n\r\nif (process.env.NODE_ENV === 'production') {\r\n    module.exports = require('./dist/js/subjx.common.js');\r\n} else {\r\n    module.exports = require('./dist/js/subjx.dev.common.js');\r\n}","import \"subjx/dist/style/subjx.css\";\n\nimport subjx from \"subjx\";\n\nvar zoom_value_formula = 1;\nlet scaleValue = 1;\n\n// self executing function here\n(function() {\n    // your page initialization code here\n    // the DOM will be available here\n\n    document.getElementById(\"cacluate_position\").onclick = calculatePosition;\n    document.getElementById(\"zoom_canvas\").onchange = changeZoomCanvas;\n\n    const zoom_element = document.getElementById(\"zoom_canvas\");\n    let zoom_value = parseInt(zoom_element.value)/100;\n    \n    defaultSelectedZoomCanvas(zoom_value);\n\n    checkAllImagesLoaded();\n    document.addEventListener('mousemove',moveCursor)\n\n})();\n\n\nfunction fitTextToImage()\n{\n    var divs = document.querySelectorAll('div[id^=\"imageContainer\"]');\n    divs.forEach((div) => {\n        let text_div=div.getElementsByClassName(\"image_text\")[0];\n        let image_div=div.getElementsByClassName(\"image_element\")[0];\n        text_div.style.width=image_div.clientWidth-20+\"px\";\n    });\n    console.log(divs)\n}\n\nfunction transformToFit() {\n    const images = document.querySelectorAll(\".image_element\");\n    console.log(\"images \", images);\n    let maxWidth = 0;\n    \n    images.forEach((image) => {\n      const width = image.clientWidth;\n      maxWidth = Math.max(maxWidth, width);\n      const height = image.clientHeight;\n      console.log(`Image width: ${width}px, height: ${height}px`);\n    });\n\n    let stack_container = document.getElementById(\"stack\");\n    let offsets_world = document.getElementById(\"world\");\n\n    scaleValue = stack_container.clientWidth / maxWidth;\n    console.log(\"scaleValue \", scaleValue);\n    if (scaleValue <= 1) {\n      scaleValue=scaleValue- 0.01;\n      offsets_world.style.transform = `scale(${scaleValue})`;\n    } else {\n      scaleValue=scaleValue- 0.1;\n      offsets_world.style.transform = `scale(${scaleValue})`;\n    }\n    \n    zoom_value_formula = 1 / scaleValue;\n\n  }\nfunction changeZoomCanvas(event) {\n    console.log(\"doSomething\", event);\n\n    const zoom_element = event.target;\n    console.log(\"zoom_element1 \", zoom_element);\n\n    let zoom_value = parseInt(zoom_element.value)/100;\n\n    defaultSelectedZoomCanvas(zoom_value)\n}\n\nfunction defaultSelectedZoomCanvas(zoom_value) {\n\n    let offsets_world = document.getElementById('world');\n    offsets_world.style.transformOrigin = '0px 0px';\n\n    console.log(\"isNaN(zoom_value) \", isNaN(zoom_value));\n    if(isNaN(zoom_value))\n    {\n        transformToFit();\n    }\n    else\n    {\n        zoom_value_formula = 1 / zoom_value;\n        console.log(\"zoom_value_formula \", zoom_value_formula);\n        offsets_world.style.transform = 'scale('+zoom_value+')';\n    }\n\n}\n\nfunction calculatePosition() {\n\n    console.log(\"xDraggable \", xDraggable);\n\n\n}\n\nlet clicked = false;\nlet elementToBeCloned = null;\nlet elementToBeClonedDup = null;\n\nconst options = {\n    container: '#world',\n    snap: {\n        x: 0,\n        y: 0,\n        angle: 0\n    },\n    cursorMove: 'move',\n    cursorRotate: 'crosshair',\n    cursorResize: 'pointer',\n    rotatable : false,\n\n    ...methods\n\n}\n\nconst methods = {\n    onInit(elements) {\n        // fires on tool activation\n        console.log(\"onInit \", elements)\n    },\n    onMove({\n        clientX,\n        clientY,\n        dx,\n        dy,\n        transform\n    }) {\n        // fires on moving\n        console.log(\"onMove \", clientX)\n    },\n    onResize({\n        clientX,\n        clientY,\n        dx,\n        dy,\n        transform,\n        width,\n        height\n    }) {\n        // fires on resizing\n        console.log(\"onResize \", clientX)\n    },\n    onRotate({\n        clientX,\n        clientY,\n        delta,\n        transform\n    }) {\n        // fires on rotation\n        console.log(\"onRotate \", clientX)\n    },\n    onDrop({\n        clientX,\n        clientY\n    }) {\n        // fires on drop\n        console.log(\"onDrop \", clientX)\n    },\n    onDestroy(el) {\n        // fires on tool deactivation\n        console.log(\"onDestroy \", el)\n    }\n}\n\nlet xDraggable = [];\n\nfunction cloneElement(e,el){\n\n        console.log(\"onDrop e \", e);\n        console.log(\"onDrop el \", el);\n        // console.log(\"onDrop clone \", clone);\n        let parent = document.getElementById(\"world\");\n\n        // console.log(xDraggable.length)\n        const stack = subjx('#world')[0],\n            offset = stack.getBoundingClientRect(),\n            drag_div = document.createElement('div');\n\n        // drag_div.setAttribute(\"id\", \"item_\"+(xDraggable_length+1));\n        drag_div.setAttribute(\"class\", \"draggable\");\n        drag_div.setAttribute(\"document_id\", e.target.id);\n        drag_div.style.top = `${(e.clientY - offset.top)*zoom_value_formula}px`;\n        drag_div.style.left = `${(e.clientX - offset.left)*zoom_value_formula}px`;\n\n        console.log(\"top \", e.clientY, \" \", offset.top, \" -> \", ((e.clientY - offset.top) * zoom_value_formula));\n        console.log(\"left \", e.clientX, \" \", offset.left, \" -> \", ((e.clientX - offset.left) * zoom_value_formula));\n\n        let drag_img = document.createElement('img');\n        drag_img.style.background = \"url('https://wesign.com/assets/images_dev/sign_box_2.png') 50% center / contain no-repeat, rgb(255, 214, 91)\";\n        drag_img.style.opacity = 0.8;\n        drag_img.style.border =  '1px solid rgb(255, 255, 118)';\n        drag_img.style.borderRadius =  '5px';\n        drag_img.style.width = '100%';\n        drag_img.style.height =  '100%';\n\n        const drag_element_name = el.getAttribute(\"drag_element_name\");\n        drag_img.id = makeId(drag_element_name);\n\n        drag_div.appendChild(drag_img);\n        parent.appendChild(drag_div);\n\n        xDraggable.push(\n            subjx(drag_div).drag(options)\n        );\n\n}\nfunction CloneElementUsingXY(clientX,clientY,target_id)\n{\n\n        // console.log(\"onDrop clone \", clone);\n        let parent = document.getElementById(\"world\");\n\n        // console.log(xDraggable.length)\n        const stack = subjx('#world')[0],\n            offset = stack.getBoundingClientRect(),\n            drag_div = document.createElement('div');\n\n        // drag_div.setAttribute(\"id\", \"item_\"+(xDraggable_length+1));\n        drag_div.setAttribute(\"class\", \"draggable\");\n        drag_div.setAttribute(\"document_id\", target_id);\n        drag_div.style.top = `${(clientY - offset.top)*zoom_value_formula}px`;\n        drag_div.style.left = `${(clientX - offset.left)*zoom_value_formula}px`;\n\n        console.log(\"top \", clientY, \" \", offset.top, \" -> \", ((clientY - offset.top) * zoom_value_formula));\n        console.log(\"left \", clientX, \" \", offset.left, \" -> \", ((clientX - offset.left) * zoom_value_formula));\n\n        let drag_img = document.createElement('img');\n        drag_img.style.background = \"url('https://wesign.com/assets/images_dev/sign_box_2.png') 50% center / contain no-repeat, rgb(255, 214, 91)\";\n        drag_img.style.opacity = 0.8;\n        drag_img.style.border =  '1px solid rgb(255, 255, 118)';\n        drag_img.style.borderRadius =  '5px';\n        drag_img.style.width = '100%';\n        drag_img.style.height =  '100%';\n\n        const drag_element_name = el.getAttribute(\"drag_element_name\");\n        drag_img.id = makeId(drag_element_name);\n        \n        drag_div.appendChild(drag_img);\n        parent.appendChild(drag_div);\n\n        xDraggable.push(\n            subjx(drag_div).drag(options)\n        );\n}\n\nsubjx('.clone').clone({\n    stack: '#container',\n    appendTo: '#stack',\n    onInit(el) {\n        // fires on tool activation;\n        console.log(\"clone init\")\n    },\n    onMove(dx, dy) {\n        // fires on moving\n        // console.log(\"fires on moving \", dx, dy)\n    },\n    onDrop(e, el, clone) {\n        // fires on drop\n        console.log(\"onDrop e \", e);\n        console.log(\"onDrop el \", el);\n        console.log(\"onDrop clone \", clone);\n        cloneElement(e,el);\n    },\n    onDestroy() {\n        // fires on tool deactivation\n    }\n});\n\nsubjx('#container').on('click', async (a) => {\n    console.log(\"a \", a);\n    console.log(\"elementToBeCloned \", elementToBeCloned);\n    if(clicked == true)\n    {\n        clicked = false;\n        cloneElement(a,elementToBeCloned);\n        let container=document.getElementById(\"container\");\n        container.removeChild(elementToBeClonedDup);\n    }\n});\n\n\nfunction moveCursor(event)\n{\n    // console.log(\"moveCursor \", event)\n    const mouseY= event.clientY;\n    const mouseX= event.clientX;\n    let element=document.getElementById(\"container\");\n    const isHover = e => e.parentElement.querySelector(':hover') === e;\n    if(clicked == true && isHover(element) && elementToBeClonedDup)\n    {\n        elementToBeClonedDup.style.left = mouseX + \"px\";\n        elementToBeClonedDup.style.top = mouseY + \"px\";\n        elementToBeClonedDup.style.display=\"block\";\n    }\n    else if(elementToBeClonedDup)\n    {\n        elementToBeClonedDup.style.display=\"none\";\n    }\n    \n}\n\nsubjx('.clone').on('click', async (a) => {\n    console.log(\"e \", a);\n    let el=a.target;\n    console.log(\"el \", el);\n    console.log(\"single\");\n    if(clicked == true)\n    {\n        clicked = false;\n        let container=document.getElementById(\"container\");\n        container.removeChild(elementToBeClonedDup);        \n    }\n    else\n    {\n        setTimeout(()=>{clicked = true;},1)\n        \n        elementToBeCloned = el;\n        elementToBeClonedDup=elementToBeCloned.cloneNode(true);\n        let container=document.getElementById(\"container\");\n        elementToBeClonedDup.style.display=\"none\";\n        elementToBeClonedDup.style.position=\"fixed\";\n        elementToBeClonedDup.style.pointerEvents=\"none\";\n\n        container.appendChild(elementToBeClonedDup)\n        \n    }\n\n});\n\nsubjx('.clone').on('dblclick', async () => {\n    function getStartEnd(element)\n    {\n        let elementRect= element.getBoundingClientRect();\n        let elementStart=elementRect.y;\n        let elementEnd=elementRect.y + elementRect.height;\n        return [elementStart,elementEnd]\n\n    }\n    console.log(\"double click\");\n    // console.log(document.activeElement)\n    var divs = document.querySelectorAll('img[id^=\"image_element\"]');\n    let container=document.getElementById('container')\n    let [containerStart,containerEnd]=getStartEnd(container)\n    let containerMid=containerStart+(containerEnd-containerStart)/2\n\n    let maxPercentage=0\n    let maxDiv=null;\n    divs.forEach((div) => {\n\n        let [elementStart,elementEnd]=getStartEnd(div)\n        console.log(getStartEnd(div))\n        elementStart=Math.max(elementStart,containerStart)\n        elementEnd=Math.min(elementEnd,containerEnd)\n        console.log('elementStart',elementStart)\n        console.log('elementEnd',elementEnd)\n        if(elementStart<elementEnd)\n        {\n            let elPercentage=elementEnd-elementStart\n            if(elPercentage>maxPercentage)\n            {\n                maxPercentage=elPercentage\n                maxDiv=div\n            }\n        }\n    });\n    console.log('max div')\n    console.log(maxDiv)\n    let maxDivRect=maxDiv.getBoundingClientRect();\n    let visibleStart=Math.max(containerStart,maxDivRect.y)\n    CloneElementUsingXY(maxDivRect.x,visibleStart,maxDiv.id)\n\n});\n\nsubjx(\".removePointer\").on('click',async (a)=>{\n    if(clicked == true)\n    {\n        clicked = false;\n        let container=document.getElementById(\"container\");\n        container.removeChild(elementToBeClonedDup);\n    }\n\n})\n\nfunction checkAllImagesLoaded() {\n    var imgs = document.images,\n    len = imgs.length,\n    counter = 0;\n\n    [].forEach.call( imgs, function( img ) {\n        if(img.complete)\n        incrementCounter();\n        else\n        img.addEventListener( 'load', incrementCounter, false );\n    } );\n\n    function incrementCounter() {\n        counter++;\n        if ( counter === len ) {\n            console.log( 'All images loaded!' );\n            fitToWidth();\n        }\n    }\n\n}\n\nfunction fitToWidth() {\n    // transformToFit()\n    fitTextToImage()\n}\n\nfunction makeId(prefix) {\n    var result = \"\";\n    var characters =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    var charactersLength = characters.length;\n    for (var i = 0; i < 10; i++) {\n      result += characters.charAt(Math.floor(Math.random() * charactersLength));\n    }\n    return prefix + \"-\" + result;\n}\n\n\n","var bundleURL = null;\nfunction getBundleURLCached() {\n  if (!bundleURL) {\n    bundleURL = getBundleURL();\n  }\n\n  return bundleURL;\n}\n\nfunction getBundleURL() {\n  // Attempt to find the URL of the current script and use that as the base URL\n  try {\n    throw new Error;\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\\/\\/[^)\\n]+/g);\n    if (matches) {\n      return getBaseURL(matches[0]);\n    }\n  }\n\n  return '/';\n}\n\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\\/\\/.+)?\\/[^/]+(?:\\?.*)?$/, '$1') + '/';\n}\n\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\n","var bundle = require('./bundle-url');\n\nfunction updateLink(link) {\n  var newLink = link.cloneNode();\n  newLink.onload = function () {\n    link.remove();\n  };\n  newLink.href = link.href.split('?')[0] + '?' + Date.now();\n  link.parentNode.insertBefore(newLink, link.nextSibling);\n}\n\nvar cssTimeout = null;\nfunction reloadCSS() {\n  if (cssTimeout) {\n    return;\n  }\n\n  cssTimeout = setTimeout(function () {\n    var links = document.querySelectorAll('link[rel=\"stylesheet\"]');\n    for (var i = 0; i < links.length; i++) {\n      if (bundle.getBaseURL(links[i].href) === bundle.getBundleURL()) {\n        updateLink(links[i]);\n      }\n    }\n\n    cssTimeout = null;\n  }, 50);\n}\n\nmodule.exports = reloadCSS;\n"]}
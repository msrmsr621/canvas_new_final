{"version":3,"sources":["node_modules/subjx/dist/js/subjx.dev.common.js","node_modules/subjx/index.js","src/index.js","node_modules/parcel-bundler/src/builtins/bundle-url.js","node_modules/parcel-bundler/src/builtins/css-loader.js","node_modules/parcel-bundler/src/builtins/hmr-runtime.js"],"names":["module","exports","require","_subjx2","_interopRequireDefault","obj","__esModule","default","_typeof","Symbol","iterator","constructor","prototype","_regeneratorRuntime","Op","Object","hasOwn","hasOwnProperty","defineProperty","key","desc","value","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","create","context","Context","makeInvokeMethod","tryCatch","fn","arg","type","call","ContinueSentinel","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","method","_invoke","AsyncIterator","PromiseImpl","invoke","resolve","reject","record","result","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","state","Error","doneResult","delegate","delegateResult","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","done","methodName","undefined","return","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","val","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","_catch","thrown","delegateYield","asyncGeneratorStep","gen","_next","_throw","_asyncToGenerator","args","arguments","apply","ownKeys","enumerableOnly","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","_objectSpread","target","source","_defineProperty","getOwnPropertyDescriptors","defineProperties","_toPropertyKey","_toPrimitive","String","input","hint","prim","toPrimitive","res","Number","zoom_value_formula","scaleValue","document","getElementById","onclick","cacluatePosition","onchange","changeZoomCanvas","selected_index","selectedIndex","console","log","defaultSelectedZoomCanvas","checkAllImagesLoaded","addEventListener","moveCursor","fitTextToImage","divs","querySelectorAll","div","text_div","getElementsByClassName","image_div","style","width","clientWidth","transformToFit","images","maxWidth","image","Math","max","height","clientHeight","concat","container","offsets_world","transform","event","transformOrigin","pagesOffsetObject","xDraggable","meta_data","margin_gap","array_xDraggable","index","draggable_element","draggable_element_main","page","temp_meta_data_top","parseInt","$","css","split","j","snapshots_name","current_page_image_height","image_height","current_page_image_width","image_width","image_document_element","querySelector","offsets","getBoundingClientRect","offsets_document_image","top","left","ceil","documents_top","clicked","elementToBeCloned","elementToBeClonedDup","xElem","subjx","options","snap","x","y","angle","cursorMove","cursorRotate","cursorResize","rotatable","methods","onInit","elements","onMove","_ref","clientX","clientY","dx","dy","onResize","_ref2","onRotate","_ref3","delta","onDrop","_ref4","onDestroy","el","drag","cloneElement","e","parent","stack","offset","drag_div","createElement","setAttribute","id","drag_img","background","opacity","border","borderRadius","appendChild","clone","appendTo","on","_ref5","_callee","a","_callee$","_context","removeChild","_x","mouseY","mouseX","_ref6","_callee2","_callee2$","_context2","cloneNode","position","pointerEvents","_x2","_callee3","_callee3$","_context3","activeElement","imgs","len","counter","img","incrementCounter","fitToWidth","scrollCheck","element","bottom","window","innerHeight","bundleURL","getBundleURLCached","getBundleURL","matches","match","getBaseURL","url","replace","bundle","updateLink","link","newLink","onload","remove","href","Date","now","parentNode","insertBefore","nextSibling","cssTimeout","reloadCSS","setTimeout","links","OVERLAY_ID","OldModule","Module","moduleName","hot","data","hotData","_acceptCallbacks","_disposeCallbacks","accept","dispose","checkedAssets","assetsToAccept","isParcelRequire","WebSocket","hostname","location","protocol","ws","onmessage","JSON","parse","handled","assets","asset","isNew","didAccept","hmrAcceptCheck","global","parcelRequire","every","generated","js","clear","hmrApply","v","hmrAcceptRun","reload","close","onclose","removeErrorOverlay","message","overlay","createErrorOverlay","body","stackTrace","innerText","innerHTML","getParents","modules","parents","k","d","dep","Array","isArray","Function","deps","cached","cache","some","cb"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGAA,IAAI2U,SAAS,GAAG,IAAI;AACpB,SAASC,kBAAkBA,CAAA,EAAG;EAC5B,IAAI,CAACD,SAAS,EAAE;IACdA,SAAS,GAAGE,YAAY,EAAE;EAC5B;EAEA,OAAOF,SAAS;AAClB;AAEA,SAASE,YAAYA,CAAA,EAAG;EACtB;EACA,IAAI;IACF,MAAM,IAAIhQ,KAAK;EACjB,CAAC,CAAC,OAAO7C,GAAG,EAAE;IACZ,IAAI8S,OAAO,GAAG,CAAC,EAAE,GAAG9S,GAAG,CAAC4P,KAAK,EAAEmD,KAAK,CAAC,+DAA+D,CAAC;IACrG,IAAID,OAAO,EAAE;MACX,OAAOE,UAAU,CAACF,OAAO,CAAC,CAAC,CAAC,CAAC;IAC/B;EACF;EAEA,OAAO,GAAG;AACZ;AAEA,SAASE,UAAUA,CAACC,GAAG,EAAE;EACvB,OAAO,CAAC,EAAE,GAAGA,GAAG,EAAEC,OAAO,CAAC,gFAAgF,EAAE,IAAI,CAAC,GAAG,GAAG;AACzH;AAEAjV,OAAO,CAAC4U,YAAY,GAAGD,kBAAkB;AACzC3U,OAAO,CAAC+U,UAAU,GAAGA,UAAU;;AC5B/B,IAAIG,MAAM,GAAGjV,OAAO,CAAC,cAAc,CAAC;AAEpC,SAASkV,UAAUA,CAACC,IAAI,EAAE;EACxB,IAAIC,OAAO,GAAGD,IAAI,CAAC7B,SAAS,EAAE;EAC9B8B,OAAO,CAACC,MAAM,GAAG,YAAY;IAC3BF,IAAI,CAACG,MAAM,EAAE;EACf,CAAC;EACDF,OAAO,CAACG,IAAI,GAAGJ,IAAI,CAACI,IAAI,CAACjH,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGkH,IAAI,CAACC,GAAG,EAAE;EACzDN,IAAI,CAACO,UAAU,CAACC,YAAY,CAACP,OAAO,EAAED,IAAI,CAACS,WAAW,CAAC;AACzD;AAEA,IAAIC,UAAU,GAAG,IAAI;AACrB,SAASC,SAASA,CAAA,EAAG;EACnB,IAAID,UAAU,EAAE;IACd;EACF;EAEAA,UAAU,GAAGE,UAAU,CAAC,YAAY;IAClC,IAAIC,KAAK,GAAG7K,QAAQ,CAACgB,gBAAgB,CAAC,wBAAwB,CAAC;IAC/D,KAAK,IAAItF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmP,KAAK,CAACpP,MAAM,EAAEC,CAAC,EAAE,EAAE;MACrC,IAAIoO,MAAM,CAACH,UAAU,CAACkB,KAAK,CAACnP,CAAC,CAAC,CAAC0O,IAAI,CAAC,KAAKN,MAAM,CAACN,YAAY,EAAE,EAAE;QAC9DO,UAAU,CAACc,KAAK,CAACnP,CAAC,CAAC,CAAC;MACtB;IACF;IAEAgP,UAAU,GAAG,IAAI;EACnB,CAAC,EAAE,EAAE,CAAC;AACR;AAEA/V,MAAM,CAACC,OAAO,GAAG+V,SAAS;;;;;;;;AJ7B1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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","file":"src.a2b27638.js","sourceRoot":"..","sourcesContent":["/*@license\n* Drag/Rotate/Resize Library\n* Released under the MIT license, 2018-2020\n* Karen Sarksyan\n* nichollascarter@gmail.com\n*/\n'use strict';\n\nconst requestAnimFrame = \r\n    window.requestAnimationFrame ||\r\n    window.mozRequestAnimationFrame ||\r\n    window.webkitRequestAnimationFrame ||\r\n    window.msRequestAnimationFrame ||\r\n    function (f) {\r\n        return setTimeout(f, 1000 / 60);\r\n    };\r\n\r\nconst cancelAnimFrame =\r\n    window.cancelAnimationFrame ||\r\n    window.mozCancelAnimationFrame ||\r\n    function (requestID) {\r\n        clearTimeout(requestID);\r\n    };\r\n\r\nconst {\r\n    forEach,\r\n    slice: arrSlice,\r\n    map: arrMap,\r\n    reduce: arrReduce\r\n} = Array.prototype;\r\n/* eslint-disable no-console */\r\nconst { warn } = console;\r\n/* eslint-disable no-console */\r\n\r\nfunction isDef(val) {\r\n    return val !== undefined && val !== null;\r\n}\r\n\r\nfunction isUndef(val) {\r\n    return val === undefined || val === null;\r\n}\r\n\r\nfunction isFunc(val) {\r\n    return typeof val === 'function';\r\n}\r\n\r\nfunction createMethod(fn) {\r\n    return isFunc(fn)\r\n        ? function () {\r\n            fn.call(this, ...arguments);\r\n        }\r\n        : () => { };\r\n}\n\nclass Helper {\n\n    constructor(params) {\n        if (typeof params === 'string') {\n            const selector = document.querySelectorAll(params);\n            this.length = selector.length;\n            for (let count = 0; count < this.length; count++) {\n                this[count] = selector[count];\n            }\n        } else if (typeof params === 'object' &&\n            (params.nodeType === 1 || params === document)) {\n            this[0] = params;\n            this.length = 1;\n        } else if (params instanceof Helper) {\n            this.length = params.length;\n            for (let count = 0; count < this.length; count++) {\n                this[count] = params[count];\n            }\n        } else if (isIterable(params)) {\n            this.length = 0;\n            for (let count = 0; count < this.length; count++) {\n                if (params.nodeType === 1) {\n                    this[count] = params[count];\n                    this.length++;\n                }\n            }\n        } else {\n            throw new Error(`Passed parameter must be selector/element/elementArray`);\n        }\n    }\n\n    css(prop) {\n        const _getStyle = obj => {\n            let len = obj.length;\n\n            while (len--) {\n                if (obj[len].currentStyle) {\n                    return obj[len].currentStyle[prop];\n                } else if (document.defaultView && document.defaultView.getComputedStyle) {\n                    return document.defaultView.getComputedStyle(obj[len], '')[prop];\n                } else {\n                    return obj[len].style[prop];\n                }\n            }\n        };\n\n        const _setStyle = (obj, options) => {\n            let len = obj.length;\n\n            while (len--) {\n                for (const property in options) {\n                    obj[len].style[property] = options[property];\n                }\n            }\n            return obj.style;\n        };\n\n        const methods = {\n            setStyle(options) {\n                return _setStyle(this, options);\n            },\n            getStyle() {\n                return _getStyle(this);\n            }\n        };\n\n        if (typeof prop === 'string') {\n            return methods.getStyle.apply(this, arrSlice.call(arguments, 1));\n        } else if (typeof prop === 'object' || !prop) {\n            return methods.setStyle.apply(this, arguments);\n        } else {\n            warn(`Method ${prop} does not exist`);\n        }\n        return false;\n    }\n\n    on() {\n        let len = this.length;\n\n        while (len--) {\n            if (!this[len].events) {\n                this[len].events = {};\n                this[len].events[arguments[0]] = [];\n            }\n\n            if (typeof (arguments[1]) !== 'string') {\n                if (document.addEventListener) {\n                    this[len].addEventListener(\n                        arguments[0], \n                        arguments[1], \n                        arguments[2] || { passive: false }\n                    );\n                } else if (document.attachEvent) {\n                    this[len].attachEvent(`on${arguments[0]}`, arguments[1]);\n                } else {\n                    this[len][`on${arguments[0]}`] = arguments[1];\n                }\n            } else {\n                listenerDelegate(\n                    this[len], \n                    arguments[0], \n                    arguments[1], \n                    arguments[2], \n                    arguments[3], \n                    true\n                );\n            }\n        }\n        return this;\n    }\n\n    off() {\n        let len = this.length;\n\n        while (len--) {\n            if (!this[len].events) {\n                this[len].events = {};\n                this[len].events[arguments[0]] = [];\n            }\n\n            if (typeof (arguments[1]) !== 'string') {\n                if (document.removeEventListener) {\n                    this[len].removeEventListener(arguments[0], arguments[1], arguments[2]);\n                } else if (document.detachEvent) {\n                    this[len].detachEvent(`on${arguments[0]}`, arguments[1]);\n                } else {\n                    this[len][`on${arguments[0]}`] = null;\n                }\n            } else {\n                listenerDelegate(this[len], arguments[0], arguments[1], arguments[2], arguments[3], false);\n            }\n        }\n\n        return this;\n    }\n\n    is(selector) {\n        if (isUndef(selector)) return false;\n        \n        const _sel = helper(selector);\n        let len = this.length;\n\n        while (len--) {\n            if (this[len] === _sel[len]) return true;\n        }\n        return false;\n    }\n\n}\n\nfunction listenerDelegate(el, evt, sel, handler, options, act) {\n    const doit = function (event) {\n        let t = event.target;\n        while (t && t !== this) {\n            if (t.matches(sel)) {\n                handler.call(t, event);\n            }\n            t = t.parentNode;\n        }\n    };\n\n    if (act === true) {\n        if (document.addEventListener) {\n            el.addEventListener(evt, doit, options || { passive: false });\n        } else if (document.attachEvent) {\n            el.attachEvent(`on${evt}`, doit);\n        } else {\n            el[`on${evt}`] = doit;\n        }\n    } else {\n        if (document.removeEventListener) {\n            el.removeEventListener(evt, doit, options || { passive: false });\n        } else if (document.detachEvent) {\n            el.detachEvent(`on${evt}`, doit);\n        } else {\n            el[`on${evt}`] = null;\n        }\n    }\n}\n\nfunction isIterable(obj) {\n    return isDef(obj) &&\n        typeof obj === 'object' &&\n        (\n            Array.isArray(obj) ||\n            (\n                isDef(window.Symbol) &&\n                typeof obj[window.Symbol.iterator] === 'function'\n            ) ||\n            isDef(obj.forEach) ||\n            (\n                typeof (obj.length) === \"number\" &&\n                (obj.length === 0 ||\n                    (obj.length > 0 &&\n                        (obj.length - 1) in obj)\n                )\n            )\n        );\n}\n\nfunction helper(params) {\n    return new Helper(params);\n}\n\nclass Observable {\r\n\r\n    constructor() {\n        this.observers = {};\n    }\r\n\r\n    subscribe(eventName, sub) {\n        const obs = this.observers;\r\n\r\n        if (isUndef(obs[eventName])) {\n            Object.defineProperty(obs, eventName, {\r\n                value: []\r\n            });\n        }\r\n\r\n        obs[eventName].push(sub);\r\n\r\n        return this;\n    }\r\n\r\n    unsubscribe(eventName, f) {\n        const obs = this.observers;\r\n\r\n        if (isDef(obs[eventName])) {\n            const index = obs[eventName].indexOf(f);\r\n            obs[eventName].splice(index, 1);\n        }\r\n\r\n        return this;\n    }\r\n\r\n    notify(eventName, source, data) {\n        if (isUndef(this.observers[eventName])) return;\r\n\r\n        this.observers[eventName].forEach(observer => {\n            if (source === observer) return;\r\n            switch (eventName) {\n\r\n                case 'onmove':\r\n                    observer.notifyMove(data);\r\n                    break;\r\n                case 'onrotate':\r\n                    observer.notifyRotate(data);\r\n                    break;\r\n                case 'onresize':\r\n                    observer.notifyResize(data);\r\n                    break;\r\n                case 'onapply':\r\n                    observer.notifyApply(data);\r\n                    break;\r\n                case 'ongetstate':\r\n                    observer.notifyGetState(data);\r\n                    break;\r\n            \n            }\n        });\n    }\r\n\n}\n\nclass Event {\r\n\r\n    constructor(name) {\r\n        this.name = name;\r\n        this.callbacks = [];\r\n    }\r\n\r\n    registerCallback(cb) {\r\n        this.callbacks.push(cb);\r\n    }\r\n\r\n    removeCallback(cb) {\r\n        const ix = this.callbacks(cb);\r\n        this.callbacks.splice(ix, 1);\r\n    }\r\n\r\n}\r\n\r\nclass EventDispatcher {\r\n\r\n    constructor() {\r\n        this.events = {};\r\n    }\r\n\r\n    registerEvent(eventName) {\r\n        this.events[eventName] = new Event(eventName);\r\n    }\r\n\r\n    emit(ctx, eventName, eventArgs) {\r\n        this.events[eventName].callbacks.forEach((cb) => {\r\n            cb.call(ctx, eventArgs);\r\n        });\r\n    };\r\n    \r\n    addEventListener(eventName, cb) {\r\n        this.events[eventName].registerCallback(cb);\r\n    }\r\n\r\n    removeEventListener(eventName, cb) {\r\n        this.events[eventName].removeCallback(cb);\r\n    }\r\n\r\n}\n\nclass SubjectModel {\r\n\r\n    constructor(el) {\r\n        this.el = el;\r\n        this.storage = null;\r\n        this.proxyMethods = null;\r\n\r\n        this.eventDispatcher = new EventDispatcher();\r\n\r\n        this._onMouseDown = this._onMouseDown.bind(this);\r\n        this._onTouchStart = this._onTouchStart.bind(this);\r\n        this._onMouseMove = this._onMouseMove.bind(this);\r\n        this._onTouchMove = this._onTouchMove.bind(this);\r\n        this._onMouseUp = this._onMouseUp.bind(this);\r\n        this._onTouchEnd = this._onTouchEnd.bind(this);\r\n        this._animate = this._animate.bind(this);\r\n    }\r\n\r\n    enable(options) {\r\n        this._processOptions(options);\r\n        this._init(this.el);\r\n        this.proxyMethods.onInit.call(this, this.el);\r\n    }\r\n\r\n    disable() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _init() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _destroy() {\r\n        throwNotImplementedError();\r\n    }\r\n    \r\n    _processOptions() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _start() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _moving() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _end() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _animate() {\r\n        throwNotImplementedError();\r\n    }\r\n\r\n    _drag({ dx, dy, ...rest }) {\r\n        const transform = this._processMove(dx, dy);\r\n\r\n        const finalArgs = {\r\n            dx,\r\n            dy,\r\n            transform,\r\n            ...rest\r\n        };\r\n\r\n        this.proxyMethods.onMove.call(this, finalArgs);\r\n        this._emitEvent('drag', finalArgs);\r\n    }\r\n\r\n    _draw() {\r\n        this._animate();\r\n    }\r\n\r\n    _onMouseDown(e) {\r\n        this._start(e);\r\n        helper(document)\r\n            .on('mousemove', this._onMouseMove)\r\n            .on('mouseup', this._onMouseUp);\r\n    }\r\n\r\n    _onTouchStart(e) {\r\n        this._start(e.touches[0]);\r\n        helper(document)\r\n            .on('touchmove', this._onTouchMove)\r\n            .on('touchend', this._onTouchEnd);\r\n    }\r\n\r\n    _onMouseMove(e) {\r\n        if (e.preventDefault) {\r\n            e.preventDefault();\r\n        }\r\n        this._moving(\r\n            e,\r\n            this.el\r\n        );\r\n    }\r\n\r\n    _onTouchMove(e) {\r\n        if (e.preventDefault) {\r\n            e.preventDefault();\r\n        }\r\n        this._moving(\r\n            e.touches[0],\r\n            this.el\r\n        );\r\n    }\r\n\r\n    _onMouseUp(e) {\r\n        helper(document)\r\n            .off('mousemove', this._onMouseMove)\r\n            .off('mouseup', this._onMouseUp);\r\n\r\n        this._end(\r\n            e,\r\n            this.el\r\n        );\r\n    }\r\n\r\n    _onTouchEnd(e) {\r\n        helper(document)\r\n            .off('touchmove', this._onTouchMove)\r\n            .off('touchend', this._onTouchEnd);\r\n\r\n        if (e.touches.length === 0) {\r\n            this._end(\r\n                e.changedTouches[0],\r\n                this.el\r\n            );\r\n        }\r\n    }\r\n\r\n    _emitEvent() {\r\n        this.eventDispatcher.emit(this, ...arguments);\r\n    }\r\n\r\n    on(name, cb) {\r\n        this.eventDispatcher.addEventListener(name, cb);\r\n        return this;\r\n    }\r\n\r\n    off(name, cb) {\r\n        this.eventDispatcher.removeEventListener(name, cb);\r\n        return this;\r\n    }\r\n\r\n}\r\n\r\nfunction throwNotImplementedError() {\r\n    throw Error(`Method not implemented`);\r\n}\n\nconst EVENTS = [\r\n    'dragStart',\r\n    'drag',\r\n    'dragEnd',\r\n    'resizeStart',\r\n    'resize',\r\n    'resizeEnd',\r\n    'rotateStart',\r\n    'rotate',\r\n    'rotateEnd',\r\n    'setPointStart',\r\n    'setPointEnd'\r\n];\n\nconst RAD = Math.PI / 180;\r\n\r\nfunction snapToGrid(value, snap) {\r\n    if (snap === 0) {\r\n        return value;\r\n    } else {\r\n        const result = snapCandidate(value, snap);\r\n\r\n        if (result - value < snap) {\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\nfunction snapCandidate(value, gridSize) {\r\n    if (gridSize === 0) return value;\r\n    return Math.round(value / gridSize) * gridSize;\r\n}\r\n\r\nfunction floatToFixed(val, size = 6) {\r\n    return Number(val.toFixed(size));\r\n}\n\nfunction getOffset(node) {\r\n    return node.getBoundingClientRect();\r\n}\r\n\r\nfunction getTransform(el) {\r\n    const transform = el.css('-webkit-transform') ||\r\n        el.css('-moz-transform') ||\r\n        el.css('-ms-transform') ||\r\n        el.css('-o-transform') ||\r\n        el.css('transform') ||\r\n        'none';\r\n    return transform;\r\n}\r\n\r\nfunction parseMatrix(value) {\r\n    const transform = value.match(/[+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g);\r\n\r\n    if (transform) {\r\n        return transform.map(item => {\r\n            return parseFloat(item);\r\n        });\r\n    } else {\r\n        return [1, 0, 0, 1, 0, 0];\r\n    }\r\n}\r\n\r\nfunction addClass(node, cls) {\r\n    if (!cls) return;\r\n\r\n    if (node.classList) {\r\n        if (cls.indexOf(' ') > -1) {\r\n            cls.split(/\\s+/).forEach(cl => {\r\n                return node.classList.add(cl);\r\n            });\r\n        } else {\r\n            return node.classList.add(cls);\r\n        }\r\n    }\r\n    return node;\r\n}\r\n\r\nfunction removeClass(node, cls) {\r\n    if (!cls) return;\r\n\r\n    if (node.classList) {\r\n        if (cls.indexOf(' ') > -1) {\r\n            cls.split(/\\s+/).forEach(cl => {\r\n                return node.classList.remove(cl);\r\n            });\r\n        } else {\r\n            return node.classList.remove(cls);\r\n        }\r\n    }\r\n    return node;\r\n}\r\n\r\nfunction objectsCollide(a, b) {\r\n    const {\r\n            top: aTop,\r\n            left: aLeft\r\n        } = getOffset(a),\r\n        {\r\n            top: bTop,\r\n            left: bLeft\r\n        } = getOffset(b),\r\n        _a = helper(a),\r\n        _b = helper(b);\r\n\r\n    return !(\r\n        ((aTop < bTop) ||\r\n            (aTop + parseFloat(_a.css('height'))) > (bTop + parseFloat(_b.css('height')))) ||\r\n        ((aLeft < bLeft) ||\r\n            (aLeft + parseFloat(_a.css('width'))) > (bLeft + parseFloat(_b.css('width'))))\r\n    );\r\n}\r\n\r\nfunction matrixToCSS(arr) {\r\n    const style = `matrix(${arr.join()})`;\r\n\r\n    return {\r\n        transform: style,\r\n        webkitTranform: style,\r\n        mozTransform: style,\r\n        msTransform: style,\r\n        otransform: style\r\n    };\r\n}\n\nclass Transformable extends SubjectModel {\r\n\r\n    constructor(el, options, observable) {\r\n        super(el);\r\n        if (this.constructor === Transformable) {\r\n            throw new TypeError('Cannot construct Transformable instances directly');\r\n        }\r\n        this.observable = observable;\r\n\r\n        EVENTS.forEach((eventName) => {\r\n            this.eventDispatcher.registerEvent(eventName);\r\n        });\r\n        \r\n        this.enable(options);\r\n    }\r\n\r\n    _cursorPoint() {\r\n        throw Error(`'_cursorPoint()' method not implemented`);\r\n    }\r\n\r\n    _rotate({ radians, ...rest }) {\r\n        const resultMtrx = this._processRotate(radians);\r\n        const finalArgs = {\r\n            transform: resultMtrx,\r\n            delta: radians,\r\n            ...rest\r\n        };\r\n        this.proxyMethods.onRotate.call(this, finalArgs);\r\n        this._emitEvent('rotate', finalArgs);\r\n    }\r\n\r\n    _resize({ dx, dy, ...rest }) {\r\n        const finalValues = this._processResize(dx, dy);\r\n        const finalArgs = {\r\n            ...finalValues,\r\n            dx,\r\n            dy,\r\n            ...rest\r\n        };\r\n        this.proxyMethods.onResize.call(this, finalArgs);\r\n        this._emitEvent('resize', finalArgs);\r\n    }\r\n\r\n    _processOptions(options) {\r\n        const { el } = this;\r\n\r\n        addClass(el, 'sjx-drag');\r\n\r\n        const _snap = {\r\n            x: 10,\r\n            y: 10,\r\n            angle: 10 * RAD\r\n        };\r\n\r\n        const _each = {\r\n            move: false,\r\n            resize: false,\r\n            rotate: false\r\n        };\r\n\r\n        let _restrict = null,\r\n            _proportions = false,\r\n            _axis = 'xy',\r\n            _cursorMove = 'auto',\r\n            _cursorResize = 'auto',\r\n            _cursorRotate = 'auto',\r\n            _themeColor = '#00a8ff',\r\n            _rotationPoint = false,\r\n            _draggable = true,\r\n            _resizable = true,\r\n            _rotatable = true,\r\n            _onInit = () => { },\r\n            _onMove = () => { },\r\n            _onRotate = () => { },\r\n            _onResize = () => { },\r\n            _onDrop = () => { },\r\n            _onDestroy = () => { };\r\n\r\n        let _container = el.parentNode;\r\n\r\n        if (isDef(options)) {\r\n            const {\r\n                snap,\r\n                each,\r\n                axis,\r\n                cursorMove,\r\n                cursorResize,\r\n                cursorRotate,\r\n                rotationPoint,\r\n                restrict,\r\n                draggable,\r\n                resizable,\r\n                rotatable,\r\n                onInit,\r\n                onDrop,\r\n                onMove,\r\n                onResize,\r\n                onRotate,\r\n                onDestroy,\r\n                container,\r\n                proportions,\r\n                themeColor\r\n            } = options;\r\n\r\n            if (isDef(snap)) {\r\n                const { x, y, angle } = snap;\r\n\r\n                _snap.x = isUndef(x) ? 10 : x;\r\n                _snap.y = isUndef(y) ? 10 : y;\r\n                _snap.angle = isUndef(angle)\r\n                    ? _snap.angle\r\n                    : angle * RAD;\r\n            }\r\n\r\n            if (isDef(each)) {\r\n                const { move, resize, rotate } = each;\r\n\r\n                _each.move = move || false;\r\n                _each.resize = resize || false;\r\n                _each.rotate = rotate || false;\r\n            }\r\n\r\n            if (isDef(restrict)) {\r\n                _restrict = restrict === 'parent'\r\n                    ? el.parentNode\r\n                    : helper(restrict)[0] || document;\r\n            }\r\n\r\n            _themeColor = themeColor || '#00a8ff';\r\n            _cursorMove = cursorMove || 'auto';\r\n            _cursorResize = cursorResize || 'auto';\r\n            _cursorRotate = cursorRotate || 'auto';\r\n            _axis = axis || 'xy';\r\n\r\n            _container = isDef(container) && helper(container)[0]\r\n                ? helper(container)[0]\r\n                : _container;\r\n\r\n            _rotationPoint = rotationPoint || false;\r\n            _proportions = proportions || false;\r\n\r\n            _draggable = isDef(draggable) ? draggable : true;\r\n            _resizable = isDef(resizable) ? resizable : true;\r\n            _rotatable = isDef(rotatable) ? rotatable : true;\r\n\r\n            _onInit = createMethod(onInit);\r\n            _onDrop = createMethod(onDrop);\r\n            _onMove = createMethod(onMove);\r\n            _onResize = createMethod(onResize);\r\n            _onRotate = createMethod(onRotate);\r\n            _onDestroy = createMethod(onDestroy);\r\n        }\r\n\r\n        this.options = {\r\n            axis: _axis,\r\n            themeColor: _themeColor,\r\n            cursorMove: _cursorMove,\r\n            cursorRotate: _cursorRotate,\r\n            cursorResize: _cursorResize,\r\n            rotationPoint: _rotationPoint,\r\n            restrict: _restrict,\r\n            container: _container,\r\n            snap: _snap,\r\n            each: _each,\r\n            proportions: _proportions,\r\n            draggable: _draggable,\r\n            resizable: _resizable,\r\n            rotatable: _rotatable\r\n        };\r\n\r\n        this.proxyMethods = {\r\n            onInit: _onInit,\r\n            onDrop: _onDrop,\r\n            onMove: _onMove,\r\n            onResize: _onResize,\r\n            onRotate: _onRotate,\r\n            onDestroy: _onDestroy\r\n        };\r\n\r\n        this.subscribe(_each);\r\n    }\r\n\r\n    _animate() {\r\n        const self = this;\r\n        const {\r\n            observable,\r\n            storage,\r\n            options\r\n        } = self;\r\n\r\n        if (isUndef(storage)) return;\r\n\r\n        storage.frame = requestAnimFrame(self._animate);\r\n\r\n        if (!storage.doDraw) return;\r\n        storage.doDraw = false;\r\n\r\n        let {\r\n            dox,\r\n            doy,\r\n            clientX,\r\n            clientY,\r\n            doDrag,\r\n            doResize,\r\n            doRotate,\r\n            doSetCenter,\r\n            revX,\r\n            revY\r\n        } = storage;\r\n\r\n        const {\r\n            snap,\r\n            each: {\r\n                move: moveEach,\r\n                resize: resizeEach,\r\n                rotate: rotateEach\r\n            },\r\n            restrict,\r\n            draggable,\r\n            resizable,\r\n            rotatable\r\n        } = options;\r\n\r\n        if (doResize && resizable) {\r\n            const {\r\n                transform,\r\n                cx,\r\n                cy\r\n            } = storage;\r\n\r\n            const { x, y } = this._pointToElement(\r\n                {\r\n                    x: clientX,\r\n                    y: clientY\r\n                }\r\n            );\r\n\r\n            let dx = dox\r\n                ? snapToGrid(x - cx, snap.x / transform.scX)\r\n                : 0;\r\n\r\n            let dy = doy\r\n                ? snapToGrid(y - cy, snap.y / transform.scY)\r\n                : 0;\r\n\r\n            dx = dox ? (revX ? - dx : dx) : 0,\r\n            dy = doy ? (revY ? - dy : dy) : 0;\r\n\r\n            const args = {\r\n                dx,\r\n                dy,\r\n                clientX,\r\n                clientY\r\n            };\r\n\r\n            self._resize(args);\r\n\r\n            if (resizeEach) {\r\n                observable.notify(\r\n                    'onresize',\r\n                    self,\r\n                    args\r\n                );\r\n            }\r\n        }\r\n\r\n        if (doDrag && draggable) {\r\n            const {\r\n                restrictOffset,\r\n                elementOffset,\r\n                nx,\r\n                ny\r\n            } = storage;\r\n\r\n            if (isDef(restrict)) {\r\n                if ((clientX - restrictOffset.left) < nx - elementOffset.left) {\r\n                    clientX = nx - elementOffset.left + restrictOffset.left;\r\n                }\r\n\r\n                if ((clientY - restrictOffset.top) < ny - elementOffset.top) {\r\n                    clientY = ny - elementOffset.top + restrictOffset.top;\r\n                }\r\n            }\r\n\r\n            const dx = dox\r\n                ? snapToGrid(clientX - nx, snap.x)\r\n                : 0;\r\n\r\n            const dy = doy\r\n                ? snapToGrid(clientY - ny, snap.y)\r\n                : 0;\r\n\r\n            const args = {\r\n                dx,\r\n                dy,\r\n                clientX,\r\n                clientY\r\n            };\r\n\r\n            self._drag(\r\n                args\r\n            );\r\n\r\n            if (moveEach) {\r\n                observable.notify('onmove',\r\n                    self,\r\n                    args\r\n                );\r\n            }\r\n        }\r\n\r\n        if (doRotate && rotatable) {\r\n            const {\r\n                pressang,\r\n                center\r\n            } = storage;\r\n\r\n            const radians = Math.atan2(\r\n                clientY - center.y,\r\n                clientX - center.x\r\n            ) - pressang;\r\n\r\n            const args = {\r\n                clientX,\r\n                clientY\r\n            };\r\n\r\n            self._rotate(\r\n                {\r\n                    radians: snapToGrid(radians, snap.angle),\r\n                    ...args\r\n                }\r\n            );\r\n\r\n            if (rotateEach) {\r\n                observable.notify('onrotate',\r\n                    self,\r\n                    {\r\n                        radians,\r\n                        ...args\r\n                    }\r\n                );\r\n            }\r\n        }\r\n\r\n        if (doSetCenter && rotatable) {\r\n            const {\r\n                bx,\r\n                by\r\n            } = storage;\r\n\r\n            const { x, y } = this._pointToControls(\r\n                {\r\n                    x: clientX,\r\n                    y: clientY\r\n                }\r\n            );\r\n\r\n            self._moveCenterHandle(\r\n                x - bx,\r\n                y - by\r\n            );\r\n        }\r\n    }\r\n\r\n    _start(e) {\r\n        const {\r\n            observable,\r\n            storage,\r\n            options: { axis, restrict, each },\r\n            el\r\n        } = this;\r\n\r\n        const computed = this._compute(e);\r\n\r\n        Object.keys(computed).forEach(prop => {\r\n            storage[prop] = computed[prop];\r\n        });\r\n\r\n        const {\r\n            onRightEdge,\r\n            onBottomEdge,\r\n            onTopEdge,\r\n            onLeftEdge,\r\n            handle,\r\n            factor,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        } = computed;\r\n\r\n        const doResize =\r\n            onRightEdge ||\r\n            onBottomEdge ||\r\n            onTopEdge ||\r\n            onLeftEdge;\r\n\r\n        const {\r\n            handles\r\n        } = storage;\r\n\r\n        const {\r\n            rotator,\r\n            center,\r\n            radius\r\n        } = handles;\r\n\r\n        if (isDef(radius)) {\r\n            removeClass(radius, 'sjx-hidden');\r\n        }\r\n\r\n        const doRotate = handle.is(rotator),\r\n            doSetCenter = isDef(center)\r\n                ? handle.is(center)\r\n                : false;\r\n\r\n        const doDrag = !(doRotate || doResize || doSetCenter);\r\n\r\n        const {\r\n            clientX,\r\n            clientY\r\n        } = e;\r\n\r\n        const {\r\n            x,\r\n            y\r\n        } = this._cursorPoint(\r\n            {\r\n                clientX,\r\n                clientY\r\n            }\r\n        );\r\n\r\n        const {\r\n            x: nx,\r\n            y: ny\r\n        } = this._pointToElement({ x, y });\r\n\r\n        const {\r\n            x: bx,\r\n            y: by\r\n        } = this._pointToControls({ x, y });\r\n\r\n        const newStorageValues = {\r\n            clientX,\r\n            clientY,\r\n            nx: x,\r\n            ny: y,\r\n            cx: nx,\r\n            cy: ny,\r\n            bx,\r\n            by,\r\n            doResize,\r\n            doDrag,\r\n            doRotate,\r\n            doSetCenter,\r\n            onExecution: true,\r\n            cursor: null,\r\n            elementOffset: getOffset(el),\r\n            restrictOffset: isDef(restrict)\r\n                ? getOffset(restrict)\r\n                : null,\r\n            dox: /\\x/.test(axis) && (doResize\r\n                ?\r\n                handle.is(handles.ml) ||\r\n                handle.is(handles.mr) ||\r\n                handle.is(handles.tl) ||\r\n                handle.is(handles.tr) ||\r\n                handle.is(handles.bl) ||\r\n                handle.is(handles.br)\r\n                : true),\r\n            doy: /\\y/.test(axis) && (doResize\r\n                ?\r\n                handle.is(handles.br) ||\r\n                handle.is(handles.bl) ||\r\n                handle.is(handles.bc) ||\r\n                handle.is(handles.tr) ||\r\n                handle.is(handles.tl) ||\r\n                handle.is(handles.tc)\r\n                : true)\r\n        };\r\n\r\n        this.storage = {\r\n            ...storage,\r\n            ...newStorageValues\r\n        };\r\n\r\n        const eventArgs = {\r\n            clientX,\r\n            clientY\r\n        };\r\n\r\n        if (doResize) {\r\n            this._emitEvent('resizeStart', eventArgs);\r\n        } else if (doRotate) {\r\n            this._emitEvent('rotateStart', eventArgs);\r\n        } else if (doDrag) {\r\n            this._emitEvent('dragStart', eventArgs);\r\n        }\r\n\r\n        const {\r\n            move,\r\n            resize,\r\n            rotate\r\n        } = each;\r\n\r\n        const actionName = doResize\r\n            ? 'resize'\r\n            : (doRotate? 'rotate' : 'drag');\r\n        \r\n        const triggerEvent = \r\n            (doResize && resize) ||\r\n            (doRotate && rotate) ||\r\n            (doDrag && move);\r\n\r\n        observable.notify(\r\n            'ongetstate',\r\n            this,\r\n            {   \r\n                clientX,\r\n                clientY,\r\n                actionName,\r\n                triggerEvent,\r\n                factor,\r\n                revX,\r\n                revY,\r\n                doW,\r\n                doH\r\n            }\r\n        );\r\n        \r\n        this._draw();\r\n    }\r\n\r\n    _moving(e) {\r\n        const {\r\n            storage,\r\n            options\r\n        } = this;\r\n\r\n        const {\r\n            x,\r\n            y\r\n        } = this._cursorPoint(e);\r\n\r\n        storage.e = e;\r\n        storage.clientX = x;\r\n        storage.clientY = y;\r\n        storage.doDraw = true;\r\n\r\n        let {\r\n            doRotate,\r\n            doDrag,\r\n            doResize,\r\n            cursor\r\n        } = storage;\r\n\r\n        const {\r\n            cursorMove,\r\n            cursorResize,\r\n            cursorRotate\r\n        } = options;\r\n\r\n        if (isUndef(cursor)) {\r\n            if (doDrag) {\r\n                cursor = cursorMove;\r\n            } else if (doRotate) {\r\n                cursor = cursorRotate;\r\n            } else if (doResize) {\r\n                cursor = cursorResize;\r\n            }\r\n            helper(document.body).css({ cursor });\r\n        }\r\n    }\r\n\r\n    _end({ clientX, clientY }) {\r\n        const {\r\n            options: { each },\r\n            observable,\r\n            storage,\r\n            proxyMethods\r\n        } = this;\r\n\r\n        const {\r\n            doResize,\r\n            doDrag,\r\n            doRotate,\r\n            //doSetCenter,\r\n            frame,\r\n            handles: { radius }\r\n        } = storage;\r\n\r\n        const actionName = doResize\r\n            ? 'resize'\r\n            : (doDrag ? 'drag' : 'rotate');\r\n\r\n        storage.doResize = false;\r\n        storage.doDrag = false;\r\n        storage.doRotate = false;\r\n        storage.doSetCenter = false;\r\n        storage.doDraw = false;\r\n        storage.onExecution = false;\r\n        storage.cursor = null;\r\n\r\n        this._apply(actionName);\r\n\r\n        const eventArgs = {\r\n            clientX, \r\n            clientY\r\n        };\r\n\r\n        proxyMethods.onDrop.call(this, eventArgs);\r\n\r\n        if (doResize) {\r\n            this._emitEvent('resizeEnd', eventArgs);\r\n        } else if (doRotate) {\r\n            this._emitEvent('rotateEnd', eventArgs);\r\n        } else if (doDrag) {\r\n            this._emitEvent('dragEnd', eventArgs);\r\n        }\r\n\r\n        const {\r\n            move,\r\n            resize,\r\n            rotate\r\n        } = each;\r\n\r\n        const triggerEvent = \r\n            (doResize && resize) ||\r\n            (doRotate && rotate) ||\r\n            (doDrag && move);\r\n\r\n        observable.notify(\r\n            'onapply',\r\n            this,\r\n            {\r\n                clientX, \r\n                clientY,\r\n                actionName,\r\n                triggerEvent\r\n            }\r\n        );\r\n\r\n        cancelAnimFrame(frame);\r\n\r\n        helper(document.body).css({ cursor: 'auto' });\r\n        if (isDef(radius)) {\r\n            addClass(radius, 'sjx-hidden');\r\n        }  \r\n    }\r\n\r\n    _compute(e) {\r\n        const {\r\n            handles\r\n        } = this.storage;\r\n\r\n        const handle = helper(e.target);\r\n\r\n        const {\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH,\r\n            ...rest\r\n        } = this._checkHandles(handle, handles);\r\n\r\n        const _computed = this._getState({\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        });\r\n\r\n        const {\r\n            x: clientX,\r\n            y: clientY\r\n        } = this._cursorPoint(e);\r\n\r\n        const pressang = Math.atan2(\r\n            clientY - _computed.center.y,\r\n            clientX - _computed.center.x\r\n        );\r\n\r\n        return {\r\n            ..._computed,\r\n            ...rest,\r\n            handle,\r\n            pressang\r\n        };\r\n    }\r\n\r\n    _checkHandles(handle, handles) {\r\n        const { tl, tc, tr, bl, br, bc, ml, mr } = handles;\r\n        const isTL = isDef(tl) ? handle.is(tl) : false,\r\n            isTC = isDef(tc) ? handle.is(tc) : false,\r\n            isTR = isDef(tr) ? handle.is(tr) : false,\r\n            isBL = isDef(bl) ? handle.is(bl) : false,\r\n            isBC = isDef(bc) ? handle.is(bc) : false,\r\n            isBR = isDef(br) ? handle.is(br) : false,\r\n            isML = isDef(ml) ? handle.is(ml) : false,\r\n            isMR = isDef(mr) ? handle.is(mr) : false;\r\n\r\n        //reverse axis\r\n        const revX = isTL || isML || isBL || isTC,\r\n            revY = isTL || isTR || isTC || isML;\r\n\r\n        const onTopEdge = isTC || isTR || isTL,\r\n            onLeftEdge = isTL || isML || isBL,\r\n            onRightEdge = isTR || isMR || isBR,\r\n            onBottomEdge = isBR || isBC || isBL;\r\n\r\n        const doW = isML || isMR,\r\n            doH = isTC || isBC;\r\n\r\n        return {\r\n            revX,\r\n            revY,\r\n            onTopEdge,\r\n            onLeftEdge,\r\n            onRightEdge,\r\n            onBottomEdge,\r\n            doW,\r\n            doH\r\n        };\r\n    }\r\n\r\n    notifyMove() {\r\n        this._drag(...arguments);\r\n    }\r\n\r\n    notifyRotate({ radians, ...rest }) {\r\n        const {\r\n            snap: { angle }\r\n        } = this.options;\r\n\r\n        this._rotate(\r\n            {\r\n                radians: snapToGrid(radians, angle),\r\n                ...rest\r\n            }\r\n        );\r\n    }\r\n\r\n    notifyResize() {\r\n        this._resize(...arguments);\r\n    }\r\n\r\n    notifyApply({ clientX, clientY, actionName, triggerEvent }) {\r\n        this.proxyMethods.onDrop.call(this, { clientX, clientY });\r\n        if (triggerEvent) {\r\n            this._apply(actionName);\r\n            this._emitEvent(`${actionName}End`, { clientX, clientY });\r\n        }\r\n    }\r\n\r\n    notifyGetState({ clientX, clientY, actionName, triggerEvent, ...rest}) {\r\n        if (triggerEvent) {\r\n            const recalc = this._getState(\r\n                rest\r\n            );\r\n    \r\n            this.storage = {\r\n                ...this.storage,\r\n                ...recalc\r\n            };\r\n            this._emitEvent(`${actionName}Start`, { clientX, clientY });\r\n        }\r\n    }\r\n\r\n    subscribe({ resize, move, rotate }) {\r\n        const { observable: ob } = this;\r\n\r\n        if (move || resize || rotate) {\r\n            ob.subscribe('ongetstate', this)\r\n                .subscribe('onapply', this);\r\n        }\r\n\r\n        if (move) {\r\n            ob.subscribe('onmove', this);\r\n        }\r\n        if (resize) {\r\n            ob.subscribe('onresize', this);\r\n        }\r\n        if (rotate) {\r\n            ob.subscribe('onrotate', this);\r\n        }\r\n    }\r\n\r\n    unsubscribe() {\r\n        const { observable: ob } = this;\r\n\r\n        ob.unsubscribe('ongetstate', this)\r\n            .unsubscribe('onapply', this)\r\n            .unsubscribe('onmove', this)\r\n            .unsubscribe('onresize', this)\r\n            .unsubscribe('onrotate', this);\r\n    }\r\n\r\n    disable() {\r\n        const {\r\n            storage,\r\n            proxyMethods,\r\n            el\r\n        } = this;\r\n\r\n        if (isUndef(storage)) return;\r\n\r\n        // unexpected case\r\n        if (storage.onExecution) {\r\n            this._end();\r\n            helper(document)\r\n                .off('mousemove', this._onMouseMove)\r\n                .off('mouseup', this._onMouseUp)\r\n                .off('touchmove', this._onTouchMove)\r\n                .off('touchend', this._onTouchEnd);\r\n        }\r\n\r\n        removeClass(el, 'sjx-drag');\r\n\r\n        this._destroy();\r\n        this.unsubscribe();\r\n\r\n        proxyMethods.onDestroy.call(this, el);\r\n        delete this.storage;\r\n    }\r\n\r\n    exeDrag({ dx, dy }) {\r\n        const { draggable } = this.options;\r\n        if (!draggable) return;\r\n    \r\n        this.storage = {\r\n            ...this.storage,\r\n            ...this._getState({ \r\n                revX: false, \r\n                revY: false, \r\n                doW: false, \r\n                doH: false \r\n            })\r\n        };\r\n\r\n        this._drag({ dx, dy });\r\n        this._apply('drag');\r\n    }\r\n\r\n    exeResize({ dx, dy, revX, revY, doW, doH }) {\r\n        const { resizable } = this.options;\r\n        if (!resizable) return;\r\n\r\n        this.storage = {\r\n            ...this.storage,\r\n            ...this._getState({ \r\n                revX: revX || false,\r\n                revY: revY || false,\r\n                doW: doW || false,\r\n                doH: doH || false\r\n            })\r\n        };\r\n\r\n        this._resize({ dx, dy });\r\n        this._apply('resize');\r\n    }\r\n\r\n    exeRotate({ delta }) {\r\n        const { rotatable } = this.options;\r\n        if (!rotatable) return;\r\n\r\n        this.storage = {\r\n            ...this.storage,\r\n            ...this._getState({ \r\n                revX: false, \r\n                revY: false, \r\n                doW: false, \r\n                doH: false \r\n            })\r\n        };\r\n\r\n        this._rotate({ radians: delta });\r\n        this._apply('rotate');\r\n    }\r\n\r\n}\n\nfunction matrixTransform({ x, y }, matrix) {\r\n    const [a, b, c, d, e, f] = matrix;\r\n\r\n    return {\r\n        x: a * x + c * y + e,\r\n        y: b * x + d * y + f\r\n    };\r\n}\r\n\r\n//http://blog.acipo.com/matrix-inversion-in-javascript/\r\nfunction matrixInvert(ctm) {\r\n    // I use Guassian Elimination to calculate the inverse:\r\n    // (1) 'augment' the matrix (left) by the identity (on the right)\r\n    // (2) Turn the matrix on the left into the identity by elemetry row ops\r\n    // (3) The matrix on the right is the inverse (was the identity matrix)\r\n    // There are 3 elemtary row ops: (I combine b and c in my code)\r\n    // (a) Swap 2 rows\r\n    // (b) Multiply a row by a scalar\r\n    // (c) Add 2 rows\r\n\r\n    const M = [\r\n        [ctm[0], ctm[2], ctm[4]],\r\n        [ctm[1], ctm[3], ctm[5]],\r\n        [0, 0, 1]\r\n    ];\r\n\r\n    //if the matrix isn't square: exit (error)\r\n    if (M.length !== M[0].length) {\r\n        return;\r\n    }\r\n\r\n    //create the identity matrix (I), and a copy (C) of the original\r\n    const dim = M.length;\r\n\r\n    const I = [],\r\n        C = [];\r\n\r\n    for (let i = 0; i < dim; i += 1) {\r\n        // Create the row\r\n        I[I.length] = [];\r\n        C[C.length] = [];\r\n        for (let j = 0; j < dim; j += 1) {\r\n            //if we're on the diagonal, put a 1 (for identity)\r\n            if (i == j) {\r\n                I[i][j] = 1;\r\n            } else {\r\n                I[i][j] = 0;\r\n            }\r\n\r\n            // Also, make the copy of the original\r\n            C[i][j] = M[i][j];\r\n        }\r\n    }\r\n\r\n    // Perform elementary row operations\r\n    for (let i = 0; i < dim; i += 1) {\r\n        // get the element e on the diagonal\r\n        let e = C[i][i];\r\n\r\n        // if we have a 0 on the diagonal (we'll need to swap with a lower row)\r\n        if (e === 0) {\r\n            //look through every row below the i'th row\r\n            for (let ii = i + 1; ii < dim; ii += 1) {\r\n                //if the ii'th row has a non-0 in the i'th col\r\n                if (C[ii][i] !== 0) {\r\n                    //it would make the diagonal have a non-0 so swap it\r\n                    for (let j = 0; j < dim; j++) {\r\n                        e = C[i][j]; //temp store i'th row\r\n                        C[i][j] = C[ii][j]; //replace i'th row by ii'th\r\n                        C[ii][j] = e; //repace ii'th by temp\r\n                        e = I[i][j]; //temp store i'th row\r\n                        I[i][j] = I[ii][j]; //replace i'th row by ii'th\r\n                        I[ii][j] = e; //repace ii'th by temp\r\n                    }\r\n                    //don't bother checking other rows since we've swapped\r\n                    break;\r\n                }\r\n            }\r\n            //get the new diagonal\r\n            e = C[i][i];\r\n            //if it's still 0, not invertable (error)\r\n            if (e === 0) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Scale this row down by e (so we have a 1 on the diagonal)\r\n        for (let j = 0; j < dim; j++) {\r\n            C[i][j] = C[i][j] / e; //apply to original matrix\r\n            I[i][j] = I[i][j] / e; //apply to identity\r\n        }\r\n\r\n        // Subtract this row (scaled appropriately for each row) from ALL of\r\n        // the other rows so that there will be 0's in this column in the\r\n        // rows above and below this one\r\n        for (let ii = 0; ii < dim; ii++) {\r\n            // Only apply to other rows (we want a 1 on the diagonal)\r\n            if (ii == i) {\r\n                continue;\r\n            }\r\n\r\n            // We want to change this element to 0\r\n            e = C[ii][i];\r\n\r\n            // Subtract (the row above(or below) scaled by e) from (the\r\n            // current row) but start at the i'th column and assume all the\r\n            // stuff left of diagonal is 0 (which it should be if we made this\r\n            // algorithm correctly)\r\n            for (let j = 0; j < dim; j++) {\r\n                C[ii][j] -= e * C[i][j]; //apply to original matrix\r\n                I[ii][j] -= e * I[i][j]; //apply to identity\r\n            }\r\n        }\r\n    }\r\n\r\n    //we've done all operations, C should be the identity\r\n    //matrix I should be the inverse:\r\n    return [\r\n        I[0][0], I[1][0],\r\n        I[0][1], I[1][1],\r\n        I[0][2], I[1][2]\r\n    ];\r\n}\r\n\r\nfunction multiplyMatrix(\r\n    [a1, b1, c1, d1, e1, f1], \r\n    [a2, b2, c2, d2, e2, f2]\r\n) {\r\n    const m1 = [\r\n        [a1, c1, e1],\r\n        [b1, d1, f1],\r\n        [0, 0, 1]\r\n    ];\r\n\r\n    const m2 = [\r\n        [a2, c2, e2],\r\n        [b2, d2, f2],\r\n        [0, 0, 1]\r\n    ];\r\n\r\n    const result = [];\r\n\r\n    for (let j = 0; j < m2.length; j++) {\r\n        result[j] = [];\r\n        for (let k = 0; k < m1[0].length; k++) {\r\n            let sum = 0;\r\n            for (let i = 0; i < m1.length; i++) {\r\n                sum += m1[i][k] * m2[j][i];\r\n            }\r\n            result[j].push(sum);\r\n        }\r\n    }\r\n\r\n    return [\r\n        result[0][0], result[1][0],\r\n        result[0][1], result[1][1],\r\n        result[0][2], result[1][2]\r\n    ];\r\n}\r\n\r\nfunction rotatedTopLeft(\r\n    x,\r\n    y,\r\n    width,\r\n    height,\r\n    rotationAngle,\r\n    revX,\r\n    revY,\r\n    doW,\r\n    doH\r\n) {\r\n    const hw = parseFloat(width) / 2,\r\n        hh = parseFloat(height) / 2;\r\n\r\n    const cx = x + hw,\r\n        cy = y + hh;\r\n\r\n    const dx = x - cx,\r\n        dy = y - cy;\r\n\r\n    const originalTopLeftAngle = Math.atan2(doW ? 0 : dy, doH ? 0 : dx);\r\n    const rotatedTopLeftAngle = originalTopLeftAngle + rotationAngle;\r\n\r\n    const radius = Math.sqrt(Math.pow(doH ? 0 : hw, 2) + Math.pow(doW ? 0 : hh, 2));\r\n\r\n    let cos = Math.cos(rotatedTopLeftAngle),\r\n        sin = Math.sin(rotatedTopLeftAngle);\r\n\r\n    cos = revX === true ? -cos : cos;\r\n    sin = revY === true ? -sin : sin;\r\n\r\n    const rx = cx + radius * cos,\r\n        ry = cy + radius * sin;\r\n\r\n    return {\r\n        left: floatToFixed(rx),\r\n        top: floatToFixed(ry)\r\n    };\r\n}\n\nconst MIN_SIZE = 2;\r\nconst CENTER_DELTA = 7;\r\n\r\nclass Draggable extends Transformable {\r\n\r\n    _init(el) {\r\n        const {\r\n            rotationPoint,\r\n            container,\r\n            resizable,\r\n            rotatable\r\n        } = this.options;\r\n\r\n        const {\r\n            left,\r\n            top,\r\n            width,\r\n            height\r\n        } = el.style;\r\n\r\n        const wrapper = document.createElement('div');\r\n        addClass(wrapper, 'sjx-wrapper');\r\n        container.appendChild(wrapper);\r\n\r\n        const $el = helper(el);\r\n\r\n        const w = width || $el.css('width'),\r\n            h = height || $el.css('height'),\r\n            t = top || $el.css('top'),\r\n            l = left || $el.css('left');\r\n\r\n        const css = {\r\n            top: t,\r\n            left: l,\r\n            width: w,\r\n            height: h,\r\n            transform: getTransform($el)\r\n        };\r\n\r\n        const controls = document.createElement('div');\r\n        addClass(controls, 'sjx-controls');\r\n\r\n        const resizingHandles = {\r\n            tl: ['sjx-hdl', 'sjx-hdl-t', 'sjx-hdl-l', 'sjx-hdl-tl'],\r\n            tr: ['sjx-hdl', 'sjx-hdl-t', 'sjx-hdl-r', 'sjx-hdl-tr'],\r\n            br: ['sjx-hdl', 'sjx-hdl-b', 'sjx-hdl-r', 'sjx-hdl-br'],\r\n            bl: ['sjx-hdl', 'sjx-hdl-b', 'sjx-hdl-l', 'sjx-hdl-bl'],\r\n            tc: ['sjx-hdl', 'sjx-hdl-t', 'sjx-hdl-c', 'sjx-hdl-tc'],\r\n            bc: ['sjx-hdl', 'sjx-hdl-b', 'sjx-hdl-c', 'sjx-hdl-bc'],\r\n            ml: ['sjx-hdl', 'sjx-hdl-m', 'sjx-hdl-l', 'sjx-hdl-ml'],\r\n            mr: ['sjx-hdl', 'sjx-hdl-m', 'sjx-hdl-r', 'sjx-hdl-mr']\r\n        };\r\n\r\n        const rotationHandles = {\r\n            normal: ['sjx-normal'],\r\n            rotator: ['sjx-hdl', 'sjx-hdl-m', 'sjx-rotator']\r\n        };\r\n\r\n        const handles = {\r\n            ...(rotatable && rotationHandles),\r\n            ...(resizable && resizingHandles),\r\n            center: rotationPoint && rotatable ? ['sjx-hdl', 'sjx-hdl-m', 'sjx-hdl-c', 'sjx-hdl-mc'] : undefined\r\n        };\r\n\r\n        Object.keys(handles).forEach(key => {\r\n            const data = handles[key];\r\n            if (isUndef(data)) return;\r\n            const handler = createHandler(data);\r\n            handles[key] = handler;\r\n            controls.appendChild(handler);\r\n        });\r\n\r\n        if (isDef(handles.center)) {\r\n            const cHandle = helper(handles.center);\r\n            cHandle.css({\r\n                left: `${el.getAttribute('data-cx')}px`,\r\n                top: `${el.getAttribute('data-cy')}px`\r\n            });\r\n        }\r\n\r\n        wrapper.appendChild(controls);\r\n\r\n        const $controls = helper(controls);\r\n        $controls.css(css);\r\n\r\n        this.storage = {\r\n            controls,\r\n            handles,\r\n            radius: undefined,\r\n            parent: el.parentNode\r\n        };\r\n\r\n        $controls\r\n            .on('mousedown', this._onMouseDown)\r\n            .on('touchstart', this._onTouchStart);\r\n    }\r\n\r\n    _destroy() {\r\n        const {\r\n            controls\r\n        } = this.storage;\r\n\r\n        helper(controls)\r\n            .off('mousedown', this._onMouseDown)\r\n            .off('touchstart', this._onTouchStart);\r\n\r\n        const wrapper = controls.parentNode;\r\n        wrapper.parentNode.removeChild(wrapper);\r\n    }\r\n\r\n    _pointToElement({ x, y }) {\r\n        const {\r\n            transform\r\n        } = this.storage;\r\n\r\n        const ctm = [...transform.matrix];\r\n        ctm[4] = ctm[5] = 0;\r\n\r\n        return this._applyMatrixToPoint(\r\n            matrixInvert(ctm),\r\n            x,\r\n            y\r\n        );\r\n    }\r\n\r\n    _pointToControls(data) {\r\n        return this._pointToElement(data);\r\n    }\r\n\r\n    _applyMatrixToPoint(matrix, x, y) {\r\n        return matrixTransform(\r\n            {\r\n                x,\r\n                y\r\n            },\r\n            matrix\r\n        );\r\n    }\r\n\r\n    _cursorPoint({ clientX, clientY }) {\r\n        const {\r\n            container\r\n        } = this.options;\r\n\r\n        const globalMatrix = parseMatrix(\r\n            getTransform(helper(container))\r\n        );\r\n\r\n        return matrixTransform(\r\n            {\r\n                x: clientX,\r\n                y: clientY\r\n            },\r\n            matrixInvert(\r\n                globalMatrix\r\n            )\r\n        );\r\n    }\r\n\r\n    _apply() {\r\n        const {\r\n            el,\r\n            storage\r\n        } = this;\r\n\r\n        const {\r\n            // cached,\r\n            controls,\r\n            // transform,\r\n            handles\r\n        } = storage;\r\n\r\n        const $controls = helper(controls);\r\n\r\n        const cw = parseFloat($controls.css('width')),\r\n            ch = parseFloat($controls.css('height'));\r\n\r\n        const hW = cw / 2,\r\n            hH = ch / 2;\r\n\r\n        const {\r\n            center: cHandle\r\n        } = handles;\r\n\r\n        const isDefCenter = isDef(cHandle);\r\n\r\n        const centerX = isDefCenter\r\n            ? parseFloat(helper(cHandle).css('left'))\r\n            : hW;\r\n        const centerY = isDefCenter\r\n            ? parseFloat(helper(cHandle).css('top'))\r\n            : hH;\r\n\r\n        el.setAttribute('data-cx', centerX);\r\n        el.setAttribute('data-cy', centerY);\r\n\r\n        // if (isUndef(cached)) return;\r\n\r\n        // const $el = helper(el);\r\n\r\n        // const { dx, dy } = cached;\r\n\r\n        // const css = matrixToCSS(transform.matrix);\r\n\r\n        // const left = parseFloat(\r\n        //     el.style.left || $el.css('left')\r\n        // );\r\n\r\n        // const top = parseFloat(\r\n        //     el.style.top || $el.css('top')\r\n        // );\r\n\r\n        // css.left = `${left + dx}px`;\r\n        // css.top = `${top + dy}px`;\r\n\r\n        // $el.css(css);\r\n        // $controls.css(css);\r\n\r\n        this.storage.cached = null;\r\n    }\r\n\r\n    _processResize(dx, dy) {\r\n        const {\r\n            el,\r\n            storage,\r\n            options: { proportions }\r\n        } = this;\r\n\r\n        const {\r\n            controls,\r\n            coords,\r\n            cw,\r\n            ch,\r\n            transform,\r\n            refang,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        } = storage;\r\n\r\n        const ratio = doW || (!doW && !doH)\r\n            ? (cw + dx) / cw\r\n            : (ch + dy) / ch;\r\n\r\n        const newWidth = proportions ? cw * ratio : cw + dx,\r\n            newHeight = proportions ? ch * ratio : ch + dy;\r\n\r\n        if (newWidth < MIN_SIZE || newHeight < MIN_SIZE) return;\r\n\r\n        const matrix = [...transform.matrix];\r\n\r\n        const newCoords = rotatedTopLeft(\r\n            matrix[4],\r\n            matrix[5],\r\n            newWidth,\r\n            newHeight,\r\n            refang,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        );\r\n\r\n        const nx = coords.left - newCoords.left,\r\n            ny = coords.top - newCoords.top;\r\n\r\n        matrix[4] += nx;\r\n        matrix[5] += ny;\r\n\r\n        const css = matrixToCSS(matrix);\r\n\r\n        css.width = `${newWidth}px`;\r\n        css.height = `${newHeight}px`;\r\n\r\n        helper(controls).css(css);\r\n        helper(el).css(css);\r\n\r\n        storage.cached = {\r\n            dx: nx,\r\n            dy: ny\r\n        };\r\n        \r\n        return {\r\n            width: newWidth,\r\n            height: newHeight,\r\n            ox: nx,\r\n            oy: ny\r\n        };\r\n    }\r\n\r\n    _processMove(dx, dy) {\r\n        const {\r\n            el,\r\n            storage\r\n        } = this;\r\n\r\n        const {\r\n            controls,\r\n            transform: {\r\n                matrix,\r\n                parentMatrix\r\n            }\r\n        } = storage;\r\n\r\n        const pctm = [...parentMatrix];\r\n        pctm[4] = pctm[5] = 0;\r\n\r\n        const nMatrix = [...matrix];\r\n\r\n        nMatrix[4] = matrix[4] + dx;\r\n        nMatrix[5] = matrix[5] + dy;\r\n\r\n        const css = matrixToCSS(nMatrix);\r\n\r\n        helper(controls).css(css);\r\n        helper(el).css(css);\r\n\r\n        storage.cached = {\r\n            dx,\r\n            dy\r\n        };\r\n\r\n        return nMatrix;\r\n    }\r\n\r\n    _processRotate(radians) {\r\n        const {\r\n            el,\r\n            storage: {\r\n                controls,\r\n                transform,\r\n                center\r\n            }\r\n        } = this;\r\n\r\n        const {\r\n            matrix,\r\n            parentMatrix\r\n        } = transform;\r\n\r\n        const cos = floatToFixed(Math.cos(radians), 4),\r\n            sin = floatToFixed(Math.sin(radians), 4);\r\n\r\n        const translateMatrix = [\r\n            1,\r\n            0,\r\n            0,\r\n            1,\r\n            center.cx,\r\n            center.cy\r\n        ];\r\n\r\n        const rotMatrix = [\r\n            cos,\r\n            sin,\r\n            -sin,\r\n            cos,\r\n            0,\r\n            0\r\n        ];\r\n\r\n        const pctm = [...parentMatrix];\r\n        pctm[4] = pctm[5] = 0;\r\n\r\n        const resRotMatrix = multiplyMatrix(\r\n            matrixInvert(pctm),\r\n            multiplyMatrix(rotMatrix, pctm)\r\n        );\r\n\r\n        const nMatrix = multiplyMatrix(\r\n            multiplyMatrix(translateMatrix, resRotMatrix),\r\n            matrixInvert(translateMatrix)\r\n        );\r\n\r\n        const resMatrix = multiplyMatrix(nMatrix, matrix);\r\n\r\n        const css = matrixToCSS(resMatrix);\r\n\r\n        helper(controls).css(css);\r\n        helper(el).css(css);\r\n\r\n        return resMatrix;\r\n    }\r\n\r\n    _getState(params) {\r\n        const {\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        } = params;\r\n\r\n        const factor = revX !== revY\r\n            ? -1\r\n            : 1;\r\n\r\n        const {\r\n            el,\r\n            storage: {\r\n                handles,\r\n                controls,\r\n                parent\r\n            },\r\n            options: { container }\r\n        } = this;\r\n\r\n        const {\r\n            center: cHandle\r\n        } = handles;\r\n\r\n        const $controls = helper(controls);\r\n\r\n        const containerMatrix = parseMatrix(\r\n            getTransform(helper(container))\r\n        );\r\n\r\n        const matrix = parseMatrix(\r\n            getTransform(helper(controls))\r\n        );\r\n\r\n        const pMatrix = parseMatrix(\r\n            getTransform(helper(parent))\r\n        );\r\n\r\n        const refang = Math.atan2(\r\n            matrix[1], matrix[0]\r\n        ) * factor;\r\n\r\n        const parentMatrix = parent !== container\r\n            ? multiplyMatrix(\r\n                pMatrix,\r\n                containerMatrix\r\n            )\r\n            : containerMatrix;\r\n\r\n        const transform = {\r\n            matrix,\r\n            parentMatrix,\r\n            scX: Math.sqrt(matrix[0] * matrix[0] + matrix[1] * matrix[1]),\r\n            scY: Math.sqrt(matrix[2] * matrix[2] + matrix[3] * matrix[3])\r\n        };\r\n\r\n        const cw = parseFloat($controls.css('width')),\r\n            ch = parseFloat($controls.css('height'));\r\n\r\n        // getting current coordinates considering rotation angle                                                                                                  \r\n        const coords = rotatedTopLeft(\r\n            matrix[4],\r\n            matrix[5],\r\n            cw,\r\n            ch,\r\n            refang,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        );\r\n\r\n        const hW = cw / 2,\r\n            hH = ch / 2;\r\n\r\n        const offset_ = getOffset(el),\r\n            isDefCenter = isDef(cHandle);\r\n\r\n        const centerX = isDefCenter\r\n            ? parseFloat(helper(cHandle).css('left'))\r\n            : hW;\r\n        const centerY = isDefCenter\r\n            ? parseFloat(helper(cHandle).css('top'))\r\n            : hH;\r\n\r\n        const cDelta = isDefCenter ? CENTER_DELTA : 0;\r\n\r\n        const { x: el_x, y: el_y } = matrixTransform(\r\n            {\r\n                x: offset_.left,\r\n                y: offset_.top\r\n            },\r\n            matrixInvert(parentMatrix)\r\n        );\r\n\r\n        return {\r\n            transform,\r\n            cw,\r\n            ch,\r\n            coords,\r\n            center: {\r\n                x: el_x + centerX - cDelta,\r\n                y: el_y + centerY - cDelta,\r\n                cx: -centerX + hW - cDelta,\r\n                cy: -centerY + hH - cDelta,\r\n                hx: centerX,\r\n                hy: centerY\r\n            },\r\n            factor,\r\n            refang,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        };\r\n    }\r\n\r\n    _moveCenterHandle(x, y) {\r\n        const { \r\n            handles: { center }, \r\n            center: { hx, hy }\r\n        } = this.storage;\r\n\r\n        const left = `${hx + x}px`,\r\n            top = `${hy + y}px`;\r\n\r\n        helper(center).css(\r\n            {\r\n                left,\r\n                top\r\n            }\r\n        );\r\n    }\r\n\r\n    resetCenterPoint() {\r\n        const {\r\n            handles: { center }\r\n        } = this.storage;\r\n\r\n        helper(center).css(\r\n            {\r\n                left: null,\r\n                top: null\r\n            }\r\n        );\r\n    }\r\n\r\n    fitControlsToSize() {}\r\n\r\n    get controls() {\r\n        return this.storage.controls;\r\n    }\r\n\r\n}\r\n\r\nfunction createHandler(classList) {\r\n    const element = document.createElement('div');\r\n    classList.forEach(cls => {\r\n        addClass(element, cls);\r\n    });\r\n    return element;\r\n}\n\nconst svgPoint = createSVGElement('svg').createSVGPoint();\r\nconst floatRE = /[+-]?\\d+(\\.\\d+)?/g;\r\n\r\nconst ALLOWED_ELEMENTS = [\r\n    'circle', 'ellipse',\r\n    'image', 'line',\r\n    'path', 'polygon',\r\n    'polyline', 'rect',\r\n    'text', 'g'\r\n];\r\n\r\nfunction checkChildElements(element) {\r\n    const arrOfElements = [];\r\n\r\n    if (isGroup(element)) {\r\n        forEach.call(element.childNodes, item => {\r\n            if (item.nodeType === 1) {\r\n                const tagName = item.tagName.toLowerCase();\r\n\r\n                if (ALLOWED_ELEMENTS.indexOf(tagName) !== -1) {\r\n                    if (tagName === 'g') {\r\n                        arrOfElements.push(...checkChildElements(item));\r\n                    }\r\n                    arrOfElements.push(item);\r\n                }\r\n            }\r\n        });\r\n    } else {\r\n        arrOfElements.push(element);\r\n    }\r\n\r\n    return arrOfElements;\r\n}\r\n\r\nfunction createSVGElement(name) {\r\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\r\n}\r\n\r\nfunction createSVGMatrix() {\r\n    return createSVGElement('svg').createSVGMatrix();\r\n}\r\n\r\nfunction getTransformToElement(toElement, g) {\r\n    const gTransform = g.getScreenCTM() || createSVGMatrix();\r\n    return gTransform.inverse().multiply(\r\n        toElement.getScreenCTM() || createSVGMatrix()\r\n    );\r\n}\r\n\r\nfunction matrixToString(m) {\r\n    const { a, b, c, d, e, f } = m;\r\n    return `matrix(${a},${b},${c},${d},${e},${f})`;\r\n}\r\n\r\nfunction pointTo(ctm, x, y) {\r\n    svgPoint.x = x;\r\n    svgPoint.y = y;\r\n    return svgPoint.matrixTransform(ctm);\r\n}\r\n\r\nfunction cloneMatrix(b) {\r\n    const a = createSVGMatrix();\r\n\r\n    a.a = b.a;\r\n    a.b = b.b;\r\n    a.c = b.c;\r\n    a.d = b.d;\r\n    a.e = b.e;\r\n    a.f = b.f;\r\n\r\n    return a;\r\n}\r\n\r\nfunction checkElement(el) {\r\n    const tagName = el.tagName.toLowerCase();\r\n\r\n    if (ALLOWED_ELEMENTS.indexOf(tagName) === -1) {\r\n        warn(\r\n            'Selected element is not allowed to transform. Allowed elements:\\n' +\r\n            'circle, ellipse, image, line, path, polygon, polyline, rect, text, g'\r\n        );\r\n        return false;\r\n    } else {\r\n        return true;\r\n    }\r\n}\r\n\r\nfunction isIdentity(matrix) {\r\n    const { a, b, c, d, e, f } = matrix;\r\n    return a === 1 &&\r\n        b === 0 &&\r\n        c === 0 &&\r\n        d === 1 &&\r\n        e === 0 &&\r\n        f === 0;\r\n}\r\n\r\nfunction createPoint(svg, x, y) {\r\n    if (isUndef(x) || isUndef(y)) {\r\n        return null;\r\n    }\r\n    const pt = svg.createSVGPoint();\r\n    pt.x = x;\r\n    pt.y = y;\r\n    return pt;\r\n}\r\n\r\nfunction isGroup(element) {\r\n    return element.tagName.toLowerCase() === 'g';\r\n}\r\n\r\nfunction parsePoints(pts) {\r\n    return pts.match(floatRE).reduce(\r\n        (result, value, index, array) => {\r\n            if (index % 2 === 0) {\r\n                result.push(array.slice(index, index + 2));\r\n            }\r\n            return result;\r\n        },\r\n        []\r\n    );\r\n}\n\nconst dRE = /\\s*([achlmqstvz])([^achlmqstvz]*)\\s*/gi;\r\nconst sepRE = /\\s*,\\s*|\\s+/g;\r\n\r\nfunction parsePath(path) {\r\n    let match = dRE.lastIndex = 0;\r\n\r\n    const serialized = [];\r\n\r\n    while ((match = dRE.exec(path))) {\r\n        const cmd = match[1];\r\n        const upCmd = cmd.toUpperCase();\r\n\r\n        // normalize the data\r\n        const data = match[2]\r\n            .replace(/([^e])-/g, '$1 -')\r\n            .replace(/ +/g, ' ');\r\n\r\n        serialized.push({\r\n            relative: cmd !== upCmd,\r\n            key: upCmd,\r\n            cmd: cmd,\r\n            values: data.trim().split(sepRE).map(val => {\r\n                if (!isNaN(val)) {\r\n                    return Number(val);\r\n                }\r\n            })\r\n        });\r\n    }\r\n\r\n    return serialized;\r\n}\r\n\r\nfunction movePath(params) {\r\n    const {\r\n        path,\r\n        dx,\r\n        dy\r\n    } = params;\r\n\r\n    try {\r\n        const serialized = parsePath(path);\r\n\r\n        let str = '';\r\n        let space = ' ';\r\n\r\n        let firstCommand = true;\r\n\r\n        for (let i = 0, len = serialized.length; i < len; i++) {\r\n            const item = serialized[i];\r\n\r\n            const {\r\n                values,\r\n                key: cmd,\r\n                relative\r\n            } = item;\r\n\r\n            const coordinates = [];\r\n\r\n            switch (cmd) {\r\n\r\n                case 'M': {\r\n                    for (let k = 0, len = values.length; k < len; k += 2) {\r\n                        let [x, y] = values.slice(k, k + 2);\r\n\r\n                        if (!(relative && !firstCommand)) {\r\n                            x += dx;\r\n                            y += dy;\r\n                        }\r\n\r\n                        coordinates.push(\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        firstCommand = false;\r\n                    }\r\n                    break;\r\n                }              \r\n                case 'A': {\r\n                    for (let k = 0, len = values.length; k < len; k += 7) {\r\n                        const set = values.slice(k, k + 7);\r\n\r\n                        if (!relative) {\r\n                            set[5] += dx;\r\n                            set[6] += dy;\r\n                        }\r\n\r\n                        coordinates.push(...set);\r\n                    }\r\n                    break;\r\n                }\r\n                case 'C': {\r\n                    for (let k = 0, len = values.length; k < len; k += 6) {\r\n                        const set = values.slice(k, k + 6);\r\n\r\n                        if (!relative) {\r\n                            set[0] += dx;\r\n                            set[1] += dy;\r\n                            set[2] += dx;\r\n                            set[3] += dy;\r\n                            set[4] += dx;\r\n                            set[5] += dy;\r\n                        }\r\n\r\n                        coordinates.push(...set);\r\n                    }\r\n                    break;\r\n                }\r\n                case 'H': {\r\n                    for (let k = 0, len = values.length; k < len; k += 1) {\r\n                        const set = values.slice(k, k + 1);\r\n\r\n                        if (!relative) {\r\n                            set[0] += dx;\r\n                        }\r\n\r\n                        coordinates.push(set[0]);\r\n                    }\r\n\r\n                    break;\r\n                }\r\n                case 'V': {\r\n                    for (let k = 0, len = values.length; k < len; k += 1) {\r\n                        const set = values.slice(k, k + 1);\r\n\r\n                        if (!relative) {\r\n                            set[0] += dy;\r\n                        }\r\n                        coordinates.push(set[0]);\r\n                    }\r\n\r\n                    break;\r\n                }\r\n                case 'L':\r\n                case 'T': {\r\n                    for (let k = 0, len = values.length; k < len; k += 2) {\r\n                        let [x, y] = values.slice(k, k + 2);\r\n\r\n                        if (!relative) {\r\n                            x += dx;\r\n                            y += dy;\r\n                        }\r\n\r\n                        coordinates.push(\r\n                            x,\r\n                            y\r\n                        );\r\n                    }\r\n                    break;\r\n                }\r\n                case 'Q':\r\n                case 'S': {\r\n                    for (let k = 0, len = values.length; k < len; k += 4) {\r\n                        let [x1, y1, x2, y2] = values.slice(k, k + 4);\r\n\r\n                        if (!relative) {\r\n                            x1 += dx;\r\n                            y1 += dy;\r\n                            x2 += dx;\r\n                            y2 += dy;\r\n                        }\r\n\r\n                        coordinates.push(\r\n                            x1,\r\n                            y1,\r\n                            x2,\r\n                            y2\r\n                        );\r\n                    }\r\n                    break;\r\n                }\r\n                case 'Z': {\r\n                    values[0] = '';\r\n                    space = '';\r\n                    break;\r\n                }\r\n\r\n            }\r\n\r\n            str += item.cmd + coordinates.join(',') + space;\r\n        }\r\n\r\n        return str;\r\n    } catch (err) {\r\n        warn('Path parsing error: ' + err);\r\n    }\r\n}\r\n\r\nfunction resizePath(params) {\r\n    const {\r\n        path,\r\n        localCTM\r\n    } = params;\r\n\r\n    try {\r\n        const serialized = parsePath(path);\r\n\r\n        let str = '';\r\n        let space = ' ';\r\n\r\n        const res = [];\r\n\r\n        let firstCommand = true;\r\n\r\n        for (let i = 0, len = serialized.length; i < len; i++) {\r\n            const item = serialized[i];\r\n\r\n            const {\r\n                values,\r\n                key: cmd,\r\n                relative\r\n            } = item;\r\n\r\n            switch (cmd) {\r\n\r\n                case 'A': {\r\n                //A rx ry x-axis-rotation large-arc-flag sweep-flag x y\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 7) {\r\n                        const [rx, ry, x_axis_rot, large_arc_flag, sweep_flag, x, y] =\r\n                            values.slice(k, k + 7);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n\r\n                        mtrx.e = mtrx.f = 0;\r\n\r\n                        const {\r\n                            x: newRx,\r\n                            y: newRy\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            rx,\r\n                            ry\r\n                        );\r\n\r\n                        coordinates.unshift(\r\n                            floatToFixed(newRx),\r\n                            floatToFixed(newRy),\r\n                            x_axis_rot,\r\n                            large_arc_flag,\r\n                            sweep_flag\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'C': {\r\n                //C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 6) {\r\n                        const [x1, y1, x2, y2, x, y] = values.slice(k, k + 6);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX1,\r\n                            y: resY1\r\n                        } = pointTo(\r\n                            mtrx,                          \r\n                            x1,\r\n                            y1\r\n                        );\r\n\r\n                        const {\r\n                            x: resX2,\r\n                            y: resY2\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x2,\r\n                            y2\r\n                        );\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX1),\r\n                            floatToFixed(resY1),\r\n                            floatToFixed(resX2),\r\n                            floatToFixed(resY2),\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                // this command makes impossible free transform within group\r\n                // todo: use proportional resizing only or need to be converted to L\r\n                case 'H': {\r\n                // H x (or h dx)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 1) {\r\n                        const [x] = values.slice(k, k + 1);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            0\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                // this command makes impossible free transform within group\r\n                // todo: use proportional resizing only or need to be converted to L\r\n                case 'V': {\r\n                // V y (or v dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 1) {\r\n                        const [y] = values.slice(k, k + 1);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            0,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resY)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'T':\r\n                case 'L': {\r\n                // T x y (or t dx dy)\r\n                // L x y (or l dx dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 2) {\r\n                        const [x, y] = values.slice(k, k + 2);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'M': {\r\n                // M x y (or dx dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 2) {\r\n                        const [x, y] = values.slice(k, k + 2);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative && !firstCommand) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n\r\n                        firstCommand = false;\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'Q': {\r\n                //Q x1 y1, x y (or q dx1 dy1, dx dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 4) {\r\n                        const [x1, y1, x, y] = values.slice(k, k + 4);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX1,\r\n                            y: resY1\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x1,\r\n                            y1\r\n                        );\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX1),\r\n                            floatToFixed(resY1),\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'S': {\r\n                //S x2 y2, x y (or s dx2 dy2, dx dy)\r\n                    const coordinates = [];\r\n\r\n                    for (let k = 0, len = values.length; k < len; k += 4) {\r\n                        const [x2, y2, x, y] = values.slice(k, k + 4);\r\n\r\n                        const mtrx = cloneMatrix(localCTM);\r\n\r\n                        if (relative) {\r\n                            mtrx.e = mtrx.f = 0;\r\n                        }\r\n\r\n                        const {\r\n                            x: resX2,\r\n                            y: resY2\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x2,\r\n                            y2\r\n                        );\r\n\r\n                        const {\r\n                            x: resX,\r\n                            y: resY\r\n                        } = pointTo(\r\n                            mtrx,\r\n                            x,\r\n                            y\r\n                        );\r\n\r\n                        coordinates.push(\r\n                            floatToFixed(resX2),\r\n                            floatToFixed(resY2),\r\n                            floatToFixed(resX),\r\n                            floatToFixed(resY)\r\n                        );\r\n                    }\r\n\r\n                    res.push(coordinates);\r\n                    break;\r\n                }\r\n                case 'Z': {\r\n                    res.push(['']);\r\n                    space = '';\r\n                    break;\r\n                }\r\n\r\n            }\r\n\r\n            str += item.cmd + res[i].join(',') + space;\r\n        }\r\n\r\n        return str;\r\n    } catch (err) {\r\n        warn('Path parsing error: ' + err);\r\n    }\r\n}\n\nconst MIN_SIZE$1 = 5;\r\nconst ROT_OFFSET = 50;\r\n\r\nclass DraggableSVG extends Transformable {\r\n\r\n    _init(el) {\r\n        const {\r\n            rotationPoint,\r\n            container,\r\n            themeColor,\r\n            resizable,\r\n            rotatable\r\n        } = this.options;\r\n\r\n        const wrapper = createSVGElement('g');\r\n        addClass(wrapper, 'sjx-svg-wrapper');\r\n        container.appendChild(wrapper);\r\n\r\n        const {\r\n            width: cw,\r\n            height: ch,\r\n            x: cx,\r\n            y: cy\r\n        } = el.getBBox();\r\n\r\n        const elCTM = getTransformToElement(el, container);\r\n        const box = createSVGElement('rect');\r\n\r\n        const attrs = [\r\n            ['width', cw],\r\n            ['height', ch],\r\n            ['x', cx],\r\n            ['y', cy],\r\n            ['fill', themeColor],\r\n            ['fill-opacity', 0.1],\r\n            ['stroke', themeColor],\r\n            ['stroke-dasharray', '3 3'],\r\n            ['vector-effect', 'non-scaling-stroke'],\r\n            ['transform', matrixToString(elCTM)]\r\n        ];\r\n\r\n        attrs.forEach(([key, value]) => {\r\n            box.setAttribute(key, value);\r\n        });\r\n\r\n        const handlesGroup = createSVGElement('g'),\r\n            normalLineGroup = createSVGElement('g'),\r\n            group = createSVGElement('g');\r\n\r\n        addClass(group, 'sjx-svg-box-group');\r\n        addClass(handlesGroup, 'sjx-svg-handles');\r\n        addClass(normalLineGroup, 'sjx-svg-normal-group');\r\n\r\n        group.appendChild(box);\r\n        wrapper.appendChild(group);\r\n        wrapper.appendChild(normalLineGroup);\r\n        wrapper.appendChild(handlesGroup);\r\n\r\n        const {\r\n            x: bX,\r\n            y: bY,\r\n            width: bW,\r\n            height: bH\r\n        } = box.getBBox();\r\n\r\n        const centerX = el.getAttribute('data-cx'),\r\n            centerY = el.getAttribute('data-cy');\r\n\r\n        const boxCTM = getTransformToElement(box, box.parentNode),\r\n            boxCenter = pointTo(boxCTM, bX + bW / 2, bY + bH / 2),\r\n            boxTL = pointTo(boxCTM, bX, bY),\r\n            boxTR = pointTo(boxCTM, bX + bW, bY),\r\n            boxMR = pointTo(boxCTM, bX + bW, bY + bH / 2);\r\n\r\n        const resizingHandles = {\r\n            tl: boxTL,\r\n            tr: boxTR,\r\n            br: pointTo(boxCTM, bX + bW, bY + bH),\r\n            bl: pointTo(boxCTM, bX, bY + bH),\r\n            tc: pointTo(boxCTM, bX + bW / 2, bY),\r\n            bc: pointTo(boxCTM, bX + bW / 2, bY + bH),\r\n            ml: pointTo(boxCTM, bX, bY + bH / 2),\r\n            mr: boxMR\r\n        };\r\n\r\n        let rotationHandles = {},\r\n            rotator = null;\r\n\r\n        if (rotatable) {\r\n            const theta = Math.atan2(\r\n                boxTL.y - boxTR.y,\r\n                boxTL.x - boxTR.x\r\n            );\r\n\r\n            rotator = {\r\n                x: boxMR.x - ROT_OFFSET * Math.cos(theta),\r\n                y: boxMR.y - ROT_OFFSET * Math.sin(theta)\r\n            }; \r\n\r\n            const normalLine = createSVGElement('line');\r\n\r\n            normalLine.x1.baseVal.value = boxMR.x;\r\n            normalLine.y1.baseVal.value = boxMR.y;\r\n            normalLine.x2.baseVal.value = rotator.x;\r\n            normalLine.y2.baseVal.value = rotator.y;\r\n\r\n            setLineStyle(normalLine, themeColor);\r\n            normalLineGroup.appendChild(normalLine);\r\n\r\n            let radius = null;\r\n\r\n            if (rotationPoint) {\r\n                radius = createSVGElement('line');\r\n\r\n                addClass(radius, 'sjx-hidden');\r\n\r\n                radius.x1.baseVal.value = boxCenter.x;\r\n                radius.y1.baseVal.value = boxCenter.y;\r\n                radius.x2.baseVal.value = centerX || boxCenter.x;\r\n                radius.y2.baseVal.value = centerY || boxCenter.y;\r\n\r\n                setLineStyle(radius, '#fe3232');\r\n                radius.setAttribute('opacity', 0.5);\r\n\r\n                normalLineGroup.appendChild(radius);\r\n            }\r\n\r\n            rotationHandles = {\r\n                normal: normalLine,\r\n                radius\r\n            };\r\n        }\r\n\r\n        const handles = {\r\n            ...(resizable && resizingHandles),\r\n            rotator,\r\n            center: rotationPoint && rotatable ? createPoint(container, centerX, centerY) || boxCenter : undefined\r\n        };\r\n\r\n        Object.keys(handles).forEach(key => {\r\n            const data = handles[key];\r\n            if (isUndef(data)) return;\r\n            const { x, y } = data;\r\n            const color = key === 'center'\r\n                ? '#fe3232'\r\n                : themeColor;\r\n\r\n            handles[key] = createHandler$1(\r\n                x,\r\n                y,\r\n                color,\r\n                key\r\n            );\r\n            handlesGroup.appendChild(handles[key]);\r\n        });\r\n\r\n        this.storage = {\r\n            wrapper,\r\n            box,\r\n            handles: {\r\n                ...handles,\r\n                ...rotationHandles\r\n            },\r\n            parent: el.parentNode,\r\n            center: {}\r\n        };\r\n\r\n        helper(wrapper)\r\n            .on('mousedown', this._onMouseDown)\r\n            .on('touchstart', this._onTouchStart);\r\n    }\r\n\r\n    _destroy() {\r\n        const {\r\n            wrapper\r\n        } = this.storage;\r\n\r\n        helper(wrapper)\r\n            .off('mousedown', this._onMouseDown)\r\n            .off('touchstart', this._onTouchStart);\r\n\r\n        wrapper.parentNode.removeChild(wrapper);\r\n    }\r\n\r\n    _cursorPoint({ clientX, clientY }) {\r\n        const {\r\n            container\r\n        } = this.options;\r\n\r\n        return pointTo(\r\n            container.getScreenCTM().inverse(),\r\n            clientX,\r\n            clientY\r\n        );\r\n    }\r\n\r\n    _pointToElement({ x, y }) {\r\n        const {\r\n            transform\r\n        } = this.storage;\r\n\r\n        const { ctm } = transform;\r\n        const matrix = ctm.inverse();\r\n\r\n        matrix.e = matrix.f = 0;\r\n\r\n        return this._applyMatrixToPoint(\r\n            matrix,\r\n            x,\r\n            y\r\n        );\r\n    }\r\n\r\n    _pointToControls({ x, y }) {\r\n        const {\r\n            transform\r\n        } = this.storage;\r\n\r\n        const { boxCTM } = transform;\r\n        const matrix = boxCTM.inverse();\r\n\r\n        matrix.e = matrix.f = 0;\r\n\r\n        return this._applyMatrixToPoint(\r\n            matrix,\r\n            x,\r\n            y\r\n        );\r\n    }\r\n\r\n    _applyMatrixToPoint(matrix, x, y) {\r\n        const {\r\n            container\r\n        } = this.options;\r\n\r\n        const pt = container.createSVGPoint();\r\n        pt.x = x;\r\n        pt.y = y;\r\n        return pt.matrixTransform(matrix);\r\n    }\r\n\r\n    _apply(actionName) {\r\n        const {\r\n            el: element,\r\n            storage,\r\n            options: { container }\r\n        } = this;\r\n\r\n        const {\r\n            box,\r\n            handles,\r\n            cached,\r\n            transform \r\n        } = storage;\r\n\r\n        const {\r\n            matrix,\r\n            boxCTM,\r\n            bBox,\r\n            ctm\r\n        } = transform;\r\n\r\n        const eBBox = element.getBBox();\r\n\r\n        const {\r\n            x: elX,\r\n            y: elY,\r\n            width: elW,\r\n            height: elH\r\n        } = eBBox;\r\n\r\n        const rotationPoint = isDef(handles.center)\r\n            ? pointTo(\r\n                boxCTM,\r\n                handles.center.cx.baseVal.value,\r\n                handles.center.cy.baseVal.value\r\n            )\r\n            : pointTo(\r\n                matrix,\r\n                elX + elW / 2,\r\n                elY + elH / 2\r\n            );\r\n\r\n        element.setAttribute('data-cx', rotationPoint.x);\r\n        element.setAttribute('data-cy', rotationPoint.y);\r\n\r\n        if (isUndef(cached)) return;\r\n\r\n        const {\r\n            scaleX,\r\n            scaleY,\r\n            dx,\r\n            dy,\r\n            ox,\r\n            oy\r\n        } = cached;\r\n\r\n        if (actionName === 'drag') {\r\n            if (dx === 0 && dy === 0) return;\r\n\r\n            const eM = createSVGMatrix();\r\n\r\n            eM.e = dx;\r\n            eM.f = dy;\r\n\r\n            const translateMatrix = eM.multiply(matrix)\r\n                .multiply(eM.inverse());\r\n\r\n            element.setAttribute(\r\n                'transform',\r\n                matrixToString(translateMatrix)\r\n            );\r\n\r\n            if (isGroup(element)) {\r\n                const els = checkChildElements(element);\r\n\r\n                els.forEach(child => {\r\n                    const pt = container.createSVGPoint();\r\n                    const ctm = getTransformToElement(element.parentNode, container).inverse();\r\n                    pt.x = ox;\r\n                    pt.y = oy;\r\n                    ctm.e = ctm.f = 0;\r\n                    const newPT = pt.matrixTransform(ctm);\r\n\r\n                    const eM = createSVGMatrix();\r\n\r\n                    eM.e = dx;\r\n                    eM.f = dy;\r\n\r\n                    const translateMatrix = eM.multiply(\r\n                        getTransformToElement(child, child.parentNode)\r\n                    ).multiply(eM.inverse());\r\n\r\n                    if (!isIdentity(translateMatrix)) {\r\n                        child.setAttribute(\r\n                            'transform',\r\n                            matrixToString(translateMatrix)\r\n                        );\r\n                    }\r\n\r\n                    if (!isGroup(child)) {\r\n                        applyTranslate(child, {\r\n                            x: newPT.x,\r\n                            y: newPT.y\r\n                        });\r\n                    }\r\n                });\r\n            } else {\r\n                applyTranslate(element, {\r\n                    x: dx,\r\n                    y: dy\r\n                });\r\n            }\r\n        }\r\n\r\n        if (actionName === 'resize') {\r\n            const {\r\n                x,\r\n                y,\r\n                width: newWidth,\r\n                height: newHeight\r\n            } = box.getBBox();\r\n\r\n            applyTransformToHandles(\r\n                storage,\r\n                {\r\n                    x,\r\n                    y,\r\n                    width: newWidth,\r\n                    height: newHeight,\r\n                    boxMatrix: null\r\n                }\r\n            );\r\n\r\n            if (isGroup(element)) {\r\n                const els = checkChildElements(element);\r\n\r\n                els.forEach(child => {\r\n                    if (!isGroup(child)) {\r\n                        applyResize(child, {\r\n                            scaleX,\r\n                            scaleY,\r\n                            defaultCTM: child.__ctm__,\r\n                            bBox: bBox,\r\n                            container,\r\n                            storage\r\n                        });\r\n                    }\r\n                });\r\n            } else {\r\n                applyResize(element, {\r\n                    scaleX,\r\n                    scaleY,\r\n                    defaultCTM: ctm,\r\n                    bBox: bBox,\r\n                    container,\r\n                    storage\r\n                });\r\n            }\r\n\r\n            element.setAttribute(\r\n                'transform',\r\n                matrixToString(matrix)\r\n            );\r\n        }\r\n\r\n        this.storage.cached = null;\r\n    }\r\n\r\n    _processResize(dx, dy) {\r\n        const {\r\n            el,\r\n            storage,\r\n            options: { proportions }\r\n        } = this;\r\n\r\n        const {\r\n            left,\r\n            top,\r\n            cw,\r\n            ch,\r\n            transform,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        } = storage;\r\n\r\n        const {\r\n            matrix,\r\n            scMatrix,\r\n            trMatrix,\r\n            scaleX: ptX,\r\n            scaleY: ptY\r\n        } = transform;\r\n\r\n        let {\r\n            width: newWidth,\r\n            height: newHeight\r\n        } = el.getBBox(); //box\r\n\r\n        const ratio = doW || (!doW && !doH)\r\n            ? (cw + dx) / cw\r\n            : (ch + dy) / ch;\r\n\r\n        newWidth = proportions ? cw * ratio : cw + dx;\r\n        newHeight = proportions ? ch * ratio : ch + dy;\r\n\r\n        if (Math.abs(newWidth) < MIN_SIZE$1 || Math.abs(newHeight) < MIN_SIZE$1) return;\r\n\r\n        const scaleX = newWidth / cw,\r\n            scaleY = newHeight / ch;\r\n\r\n        // setup scale matrix\r\n        scMatrix.a = scaleX;\r\n        scMatrix.b = 0;\r\n        scMatrix.c = 0;\r\n        scMatrix.d = scaleY;\r\n        scMatrix.e = 0;\r\n        scMatrix.f = 0;\r\n\r\n        // translate compensation matrix\r\n        trMatrix.e = ptX;\r\n        trMatrix.f = ptY;\r\n\r\n        //now must to do: translate(x y) scale(sx sy) translate(-x -y)\r\n        const scaleMatrix = trMatrix\r\n            .multiply(scMatrix)\r\n            .multiply(trMatrix.inverse());\r\n\r\n        const res = matrix.multiply(scaleMatrix);\r\n\r\n        el.setAttribute(\r\n            'transform',\r\n            matrixToString(res)\r\n        );\r\n\r\n        const deltaW = newWidth - cw,\r\n            deltaH = newHeight - ch;\r\n\r\n        const newX = left - deltaW * (doH ? 0.5 : (revX ? 1 : 0)),\r\n            newY = top - deltaH * (doW ? 0.5 : (revY ? 1 : 0));\r\n\r\n        this.storage.cached = {\r\n            scaleX,\r\n            scaleY\r\n        };\r\n\r\n        const finalValues = {\r\n            x: newX,\r\n            y: newY,\r\n            width: newWidth,\r\n            height: newHeight\r\n        };\r\n\r\n        applyTransformToHandles(\r\n            storage,\r\n            {\r\n                ...finalValues,\r\n                boxMatrix: null\r\n            }\r\n        );\r\n\r\n        return finalValues;\r\n    }\r\n\r\n    _processMove(dx, dy) {\r\n        const {\r\n            transform,\r\n            wrapper,\r\n            center\r\n        } = this.storage;\r\n\r\n        const {\r\n            matrix,\r\n            trMatrix,\r\n            scMatrix,\r\n            wrapperMatrix,\r\n            parentMatrix\r\n        } = transform;\r\n\r\n        scMatrix.e = dx;\r\n        scMatrix.f = dy;\r\n\r\n        const moveWrapperMtrx = scMatrix.multiply(wrapperMatrix);\r\n\r\n        wrapper.setAttribute(\r\n            'transform',\r\n            matrixToString(moveWrapperMtrx)\r\n        );\r\n\r\n        parentMatrix.e = parentMatrix.f = 0;\r\n        const { x, y } = pointTo(\r\n            parentMatrix.inverse(),\r\n            dx,\r\n            dy\r\n        );\r\n\r\n        trMatrix.e = x;\r\n        trMatrix.f = y;\r\n\r\n        const moveElementMtrx = trMatrix.multiply(matrix);\r\n\r\n        this.el.setAttribute(\r\n            'transform',\r\n            matrixToString(moveElementMtrx)\r\n        );\r\n\r\n        this.storage.cached = {\r\n            dx: x,\r\n            dy: y,\r\n            ox: dx,\r\n            oy: dy\r\n        };\r\n\r\n        if (center.isShifted) {\r\n            const radiusMatrix = wrapperMatrix.inverse();\r\n            radiusMatrix.e = radiusMatrix.f = 0;\r\n            const { x: nx, y: ny } = pointTo(\r\n                radiusMatrix,\r\n                dx,\r\n                dy\r\n            );\r\n\r\n            this._moveCenterHandle(-nx, -ny);\r\n        }\r\n\r\n        return moveElementMtrx;\r\n    }\r\n\r\n    _processRotate(radians) {\r\n        const {\r\n            center,\r\n            transform,\r\n            wrapper\r\n        } = this.storage;\r\n\r\n        const {\r\n            matrix,\r\n            wrapperMatrix,\r\n            parentMatrix,\r\n            trMatrix,\r\n            scMatrix,\r\n            rotMatrix\r\n        } = transform;\r\n\r\n        const cos = floatToFixed(Math.cos(radians)),\r\n            sin = floatToFixed(Math.sin(radians));\r\n\r\n        // rotate(a cx cy) is equivalent to translate(cx cy) rotate(a) translate(-cx -cy)\r\n        trMatrix.e = center.x;\r\n        trMatrix.f = center.y;\r\n\r\n        rotMatrix.a = cos;\r\n        rotMatrix.b = sin;\r\n        rotMatrix.c = - sin;\r\n        rotMatrix.d = cos;\r\n\r\n        const wrapMatrix = trMatrix.multiply(rotMatrix)\r\n            .multiply(trMatrix.inverse())\r\n            .multiply(wrapperMatrix);\r\n\r\n        wrapper.setAttribute(\r\n            'transform',\r\n            matrixToString(wrapMatrix)\r\n        );\r\n\r\n        scMatrix.e = center.el_x;\r\n        scMatrix.f = center.el_y;\r\n\r\n        parentMatrix.e = parentMatrix.f = 0;\r\n        const resRotMatrix = parentMatrix.inverse()\r\n            .multiply(rotMatrix)\r\n            .multiply(parentMatrix);\r\n\r\n        const rotateMatrix = scMatrix.multiply(resRotMatrix)\r\n            .multiply(scMatrix.inverse());\r\n\r\n        const elMatrix = rotateMatrix.multiply(matrix);\r\n\r\n        this.el.setAttribute(\r\n            'transform',\r\n            matrixToString(elMatrix)\r\n        );\r\n\r\n        return elMatrix;\r\n    }\r\n\r\n    _getState({ revX, revY, doW, doH }) {\r\n        const {\r\n            el: element,\r\n            storage,\r\n            options: { container }\r\n        } = this;\r\n\r\n        const {\r\n            box,\r\n            wrapper,\r\n            parent,\r\n            handles: { center: cHandle }\r\n        } = storage;\r\n\r\n        const eBBox = element.getBBox();\r\n\r\n        const {\r\n            x: el_x,\r\n            y: el_y,\r\n            width: el_w,\r\n            height: el_h\r\n        } = eBBox;\r\n\r\n        const {\r\n            width: cw,\r\n            height: ch,\r\n            x: c_left,\r\n            y: c_top\r\n        } = box.getBBox();\r\n\r\n        const elMatrix = getTransformToElement(element, parent),\r\n            ctm = getTransformToElement(element, container),\r\n            boxCTM = getTransformToElement(box.parentNode, container);\r\n\r\n        const parentMatrix = getTransformToElement(parent, container);\r\n\r\n        const scaleX = el_x + el_w * (doH ? 0.5 : revX ? 1 : 0),\r\n            scaleY = el_y + el_h * (doW ? 0.5 : revY ? 1 : 0);\r\n\r\n        const transform = {\r\n            matrix: elMatrix,\r\n            ctm,\r\n            boxCTM,\r\n            parentMatrix,\r\n            wrapperMatrix: getTransformToElement(wrapper, wrapper.parentNode),\r\n            trMatrix: createSVGMatrix(),\r\n            scMatrix: createSVGMatrix(),\r\n            rotMatrix: createSVGMatrix(),\r\n            scaleX,\r\n            scaleY,\r\n            scX: Math.sqrt(ctm.a * ctm.a + ctm.b * ctm.b),\r\n            scY: Math.sqrt(ctm.c * ctm.c + ctm.d * ctm.d),\r\n            bBox: eBBox\r\n        };\r\n\r\n        const boxCenterX = c_left + cw / 2,\r\n            boxCenterY = c_top + ch / 2;\r\n\r\n        const centerX = cHandle\r\n                ? cHandle.cx.baseVal.value\r\n                : boxCenterX,\r\n            centerY = cHandle\r\n                ? cHandle.cy.baseVal.value\r\n                : boxCenterY;\r\n\r\n        // c-handle's coordinates\r\n        const { x: bcx, y: bcy } = pointTo(\r\n            boxCTM,\r\n            centerX,\r\n            centerY\r\n        );\r\n\r\n        // element's center coordinates\r\n        const { x: elcx, y: elcy } = isDef(cHandle)\r\n            ? pointTo(\r\n                parentMatrix.inverse(),\r\n                bcx,\r\n                bcy\r\n            )\r\n            : pointTo(\r\n                elMatrix,\r\n                el_x + el_w / 2,\r\n                el_y + el_h / 2\r\n            );\r\n\r\n        // box's center coordinates\r\n        const { x: rcx, y: rcy } = pointTo(\r\n            getTransformToElement(box, container),\r\n            boxCenterX,\r\n            boxCenterY\r\n        );\r\n\r\n        checkChildElements(element).forEach(child => {\r\n            child.__ctm__ = getTransformToElement(child, container);\r\n        });\r\n\r\n        return {\r\n            transform,\r\n            cw,\r\n            ch,\r\n            center: {\r\n                x: cHandle ? bcx : rcx,\r\n                y: cHandle ? bcy : rcy,\r\n                el_x: elcx,\r\n                el_y: elcy,\r\n                hx: cHandle ? cHandle.cx.baseVal.value : null,\r\n                hy: cHandle ? cHandle.cy.baseVal.value : null,\r\n                isShifted: (floatToFixed(rcx, 3) !== floatToFixed(bcx, 3)) &&\r\n                    (floatToFixed(rcy, 3) !== floatToFixed(bcy, 3))\r\n            },\r\n            left: c_left,\r\n            top: c_top,\r\n            revX,\r\n            revY,\r\n            doW,\r\n            doH\r\n        };\r\n    }\r\n\r\n    _moveCenterHandle(x, y) {\r\n        const {\r\n            handles: { center, radius },\r\n            center: { hx, hy }\r\n        } = this.storage;\r\n\r\n        if (isUndef(center)) return;\r\n\r\n        const mx = hx + x,\r\n            my = hy + y;\r\n\r\n        center.cx.baseVal.value = mx;\r\n        center.cy.baseVal.value = my;\r\n\r\n        radius.x2.baseVal.value = mx;\r\n        radius.y2.baseVal.value = my;\r\n    }\r\n\r\n    resetCenterPoint() {\r\n        const {\r\n            box,\r\n            handles: { center, radius }\r\n        } = this.storage;\r\n\r\n        const {\r\n            width: cw,\r\n            height: ch,\r\n            x: c_left,\r\n            y: c_top\r\n        } = box.getBBox();\r\n\r\n        const matrix = getTransformToElement(box, box.parentNode);\r\n\r\n        const { x: cx, y: cy } = pointTo(\r\n            matrix,\r\n            c_left + cw / 2,\r\n            c_top + ch / 2\r\n        );\r\n\r\n        center.cx.baseVal.value = cx;\r\n        center.cy.baseVal.value = cy;\r\n        center.isShifted = false;\r\n\r\n        radius.x2.baseVal.value = cx;\r\n        radius.y2.baseVal.value = cy;\r\n    }\r\n\r\n    fitControlsToSize() {\r\n        const { \r\n            el, \r\n            storage: { box, wrapper }, \r\n            options: { container }\r\n        } = this;\r\n\r\n        const {\r\n            width,\r\n            height,\r\n            x,\r\n            y\r\n        } = el.getBBox();\r\n\r\n        const containerMatrix = getTransformToElement(\r\n            el,\r\n            container\r\n        );\r\n        \r\n        wrapper.removeAttribute('transform');\r\n        box.setAttribute('transform', matrixToString(containerMatrix));\r\n\r\n        applyTransformToHandles(\r\n            this.storage,\r\n            {\r\n                x,\r\n                y,\r\n                width,\r\n                height,\r\n                boxMatrix: containerMatrix\r\n            }\r\n        );\r\n    }\r\n\r\n    get controls() {\r\n        return this.storage.wrapper;\r\n    }\r\n\r\n}\r\n\r\nfunction applyTranslate(element, { x, y }) {\r\n    const attrs = [];\r\n\r\n    switch (element.tagName.toLowerCase()) {\r\n\r\n        case 'text': {\r\n            const resX = isDef(element.x.baseVal[0])\r\n                ? element.x.baseVal[0].value + x\r\n                : (Number(element.getAttribute('x')) || 0) + x;\r\n            const resY = isDef(element.y.baseVal[0])\r\n                ? element.y.baseVal[0].value + y\r\n                : (Number(element.getAttribute('y')) || 0) + y;\r\n\r\n            attrs.push(\r\n                ['x', resX],\r\n                ['y', resY]\r\n            );\r\n            break;\r\n        }\r\n        case 'use':\r\n        case 'image':\r\n        case 'rect': {\r\n            const resX = isDef(element.x.baseVal.value)\r\n                ? element.x.baseVal.value + x\r\n                : (Number(element.getAttribute('x')) || 0) + x;\r\n            const resY = isDef(element.y.baseVal.value)\r\n                ? element.y.baseVal.value + y\r\n                : (Number(element.getAttribute('y')) || 0) + y;\r\n\r\n            attrs.push(\r\n                ['x', resX],\r\n                ['y', resY]\r\n            );\r\n            break;\r\n        }\r\n        case 'circle':\r\n        case 'ellipse': {\r\n            const resX = element.cx.baseVal.value + x,\r\n                resY = element.cy.baseVal.value + y;\r\n\r\n            attrs.push(\r\n                ['cx', resX],\r\n                ['cy', resY]\r\n            );\r\n            break;\r\n        }\r\n        case 'line': {\r\n            const resX1 = element.x1.baseVal.value + x,\r\n                resY1 = element.y1.baseVal.value + y,\r\n                resX2 = element.x2.baseVal.value + x,\r\n                resY2 = element.y2.baseVal.value + y;\r\n\r\n            attrs.push(\r\n                ['x1', resX1],\r\n                ['y1', resY1],\r\n                ['x2', resX2],\r\n                ['y2', resY2]\r\n            );\r\n            break;\r\n        }\r\n        case 'polygon':\r\n        case 'polyline': {\r\n            const points = parsePoints(element.getAttribute('points'));\r\n            const result = points.map(item => {\r\n                item[0] = Number(item[0]) + x;\r\n                item[1] = Number(item[1]) + y;\r\n\r\n                return item.join(' ');\r\n            }).join(' ');\r\n\r\n            attrs.push(\r\n                ['points', result]\r\n            );\r\n            break;\r\n        }\r\n        case 'path': {\r\n            const path = element.getAttribute('d');\r\n\r\n            attrs.push(['d', movePath(\r\n                {\r\n                    path,\r\n                    dx: x,\r\n                    dy: y\r\n                }\r\n            )]);\r\n            break;\r\n        }\r\n\r\n    }\r\n\r\n    attrs.forEach(item => {\r\n        element.setAttribute(item[0], item[1]);\r\n    });\r\n}\r\n\r\nfunction applyResize(element, data) {\r\n    const {\r\n        scaleX,\r\n        scaleY,\r\n        bBox,\r\n        defaultCTM,\r\n        container\r\n    } = data;\r\n\r\n    const {\r\n        width: boxW,\r\n        height: boxH\r\n    } = bBox;\r\n\r\n    const attrs = [];\r\n\r\n    const ctm = getTransformToElement(element, container);\r\n    const localCTM = defaultCTM.inverse().multiply(ctm);\r\n\r\n    switch (element.tagName.toLowerCase()) {\r\n\r\n        case 'text': {\r\n            const x = isDef(element.x.baseVal[0])\r\n                ? element.x.baseVal[0].value\r\n                : (Number(element.getAttribute('x')) || 0);\r\n            const y = isDef(element.y.baseVal[0])\r\n                ? element.y.baseVal[0].value\r\n                : (Number(element.getAttribute('y')) || 0);\r\n\r\n            const {\r\n                x: resX,\r\n                y: resY\r\n            } = pointTo(\r\n                localCTM,\r\n                x,\r\n                y\r\n            );\r\n\r\n            attrs.push(\r\n                ['x', resX + (scaleX < 0 ? boxW : 0)],\r\n                ['y', resY + (scaleY < 0 ? boxH : 0)]\r\n            );\r\n            break;\r\n        }\r\n        case 'circle': {\r\n            const r = element.r.baseVal.value,\r\n                cx = element.cx.baseVal.value,\r\n                cy = element.cy.baseVal.value,\r\n                newR = r * (Math.abs(scaleX) + Math.abs(scaleY)) / 2;\r\n\r\n            const {\r\n                x: resX,\r\n                y: resY\r\n            } = pointTo(\r\n                localCTM,\r\n                cx,\r\n                cy\r\n            );\r\n\r\n            attrs.push(\r\n                ['r', newR],\r\n                ['cx', resX],\r\n                ['cy', resY]\r\n            );\r\n            break;\r\n        }\r\n        case 'image':\r\n        case 'rect': {\r\n            const width = element.width.baseVal.value,\r\n                height = element.height.baseVal.value,\r\n                x = element.x.baseVal.value,\r\n                y = element.y.baseVal.value;\r\n\r\n            const {\r\n                x: resX,\r\n                y: resY\r\n            } = pointTo(\r\n                localCTM,\r\n                x,\r\n                y\r\n            );\r\n\r\n            const newWidth = Math.abs(width * scaleX),\r\n                newHeight = Math.abs(height * scaleY);\r\n\r\n            attrs.push(\r\n                ['x', resX - (scaleX < 0 ? newWidth : 0)],\r\n                ['y', resY - (scaleY < 0 ? newHeight : 0)],\r\n                ['width', newWidth],\r\n                ['height', newHeight]\r\n            );\r\n            break;\r\n        }\r\n        case 'ellipse': {\r\n            const rx = element.rx.baseVal.value,\r\n                ry = element.ry.baseVal.value,\r\n                cx = element.cx.baseVal.value,\r\n                cy = element.cy.baseVal.value;\r\n\r\n            const {\r\n                x: cx1,\r\n                y: cy1\r\n            } = pointTo(\r\n                localCTM,\r\n                cx,\r\n                cy\r\n            );\r\n\r\n            const scaleMatrix = createSVGMatrix();\r\n\r\n            scaleMatrix.a = scaleX;\r\n            scaleMatrix.d = scaleY;\r\n\r\n            const {\r\n                x: nRx,\r\n                y: nRy\r\n            } = pointTo(\r\n                scaleMatrix,\r\n                rx,\r\n                ry\r\n            );\r\n\r\n            attrs.push(\r\n                ['rx', Math.abs(nRx)],\r\n                ['ry', Math.abs(nRy)],\r\n                ['cx', cx1],\r\n                ['cy', cy1]\r\n            );\r\n            break;\r\n        }\r\n        case 'line': {\r\n            const resX1 = element.x1.baseVal.value,\r\n                resY1 = element.y1.baseVal.value,\r\n                resX2 = element.x2.baseVal.value,\r\n                resY2 = element.y2.baseVal.value;\r\n\r\n            const {\r\n                x: resX1_,\r\n                y: resY1_\r\n            } = pointTo(\r\n                localCTM,\r\n                resX1,\r\n                resY1\r\n            );\r\n\r\n            const {\r\n                x: resX2_,\r\n                y: resY2_\r\n            } = pointTo(\r\n                localCTM,\r\n                resX2,\r\n                resY2\r\n            );\r\n\r\n            attrs.push(\r\n                ['x1', resX1_],\r\n                ['y1', resY1_],\r\n                ['x2', resX2_],\r\n                ['y2', resY2_]\r\n            );\r\n            break;\r\n        }\r\n        case 'polygon':\r\n        case 'polyline': {\r\n            const points = parsePoints(element.getAttribute('points'));\r\n            const result = points.map(item => {\r\n                const {\r\n                    x,\r\n                    y\r\n                } = pointTo(\r\n                    localCTM,\r\n                    Number(item[0]),\r\n                    Number(item[1])\r\n                );\r\n\r\n                item[0] = x;\r\n                item[1] = y;\r\n\r\n                return item.join(' ');\r\n            }).join(' ');\r\n\r\n            attrs.push(['points', result]);\r\n            break;\r\n        }\r\n        case 'path': {\r\n            const path = element.getAttribute('d');\r\n\r\n            attrs.push(['d', resizePath(\r\n                {\r\n                    path,\r\n                    localCTM\r\n                }\r\n            )]);\r\n            break;\r\n        }\r\n\r\n    }\r\n\r\n    attrs.forEach(([key, value]) => {\r\n        element.setAttribute(key, value);\r\n    });\r\n}\r\n\r\nfunction applyTransformToHandles(\r\n    storage,\r\n    data\r\n) {\r\n    const {\r\n        box,\r\n        handles,\r\n        center\r\n    } = storage;\r\n\r\n    let {\r\n        x,\r\n        y,\r\n        width,\r\n        height,\r\n        boxMatrix\r\n    } = data;\r\n\r\n    const hW = width / 2,\r\n        hH = height / 2;\r\n\r\n    const forced = boxMatrix !== null;\r\n\r\n    const boxCTM = !forced\r\n        ? getTransformToElement(\r\n            box,\r\n            box.parentNode\r\n        )\r\n        : boxMatrix;\r\n\r\n    const boxCenter = pointTo(boxCTM, x + hW, y + hH);\r\n\r\n    const attrs = {\r\n        tl: pointTo(boxCTM, x, y),\r\n        tr: pointTo(boxCTM, x + width, y),\r\n        br: pointTo(boxCTM, x + width, y + height),\r\n        bl: pointTo(boxCTM, x, y + height),\r\n        tc: pointTo(boxCTM, x + hW, y),\r\n        bc: pointTo(boxCTM, x + hW, y + height),\r\n        ml: pointTo(boxCTM, x, y + hH),\r\n        mr: pointTo(boxCTM, x + width, y + hH),\r\n        rotator: {},\r\n        center: isDef(handles.center) && !center.isShifted ? boxCenter : undefined\r\n    };\r\n\r\n    // if (forced) { \r\n    //     attrs.center = pointTo(\r\n    //         boxCTM, \r\n    //         center.x, \r\n    //         center.y\r\n    //     );\r\n    //     console.log(attrs.center);\r\n    // }\r\n\r\n    const theta = Math.atan2(\r\n        attrs.tl.y - attrs.tr.y,\r\n        attrs.tl.x - attrs.tr.x\r\n    );\r\n\r\n    attrs.rotator.x = attrs.mr.x - ROT_OFFSET * Math.cos(theta);\r\n    attrs.rotator.y = attrs.mr.y - ROT_OFFSET * Math.sin(theta);\r\n\r\n    const {\r\n        normal,\r\n        radius\r\n    } = handles;\r\n\r\n    if (isDef(normal)) {\r\n        normal.x1.baseVal.value = attrs.mr.x;\r\n        normal.y1.baseVal.value = attrs.mr.y;\r\n        normal.x2.baseVal.value = attrs.rotator.x;\r\n        normal.y2.baseVal.value = attrs.rotator.y;\r\n    }\r\n   \r\n    if (isDef(radius)) {\r\n        radius.x1.baseVal.value = boxCenter.x;\r\n        radius.y1.baseVal.value = boxCenter.y;\r\n        if (!center.isShifted) {\r\n            radius.x2.baseVal.value = boxCenter.x;\r\n            radius.y2.baseVal.value = boxCenter.y;\r\n        }\r\n    }\r\n\r\n    x += width < 0 ? width : 0;\r\n    y += height < 0 ? height : 0;\r\n\r\n    const boxAttrs = {\r\n        x,\r\n        y,\r\n        width: Math.abs(width),\r\n        height: Math.abs(height)\r\n    };\r\n\r\n    Object.keys(boxAttrs).forEach(attr => {\r\n        box.setAttribute(attr, boxAttrs[attr]);\r\n    });\r\n\r\n    Object.keys(attrs).forEach(key => {\r\n        const hdl = handles[key];\r\n        const attr = attrs[key];\r\n        if (isUndef(attr) || isUndef(hdl)) return;\r\n        hdl.setAttribute('cx', attr.x);\r\n        hdl.setAttribute('cy', attr.y);\r\n    });\r\n}\r\n\r\nfunction createHandler$1(l, t, color, key) {\r\n    const handler = createSVGElement('circle');\r\n    addClass(handler, `sjx-svg-hdl-${key}`);\r\n\r\n    const items = {\r\n        cx: l,\r\n        cy: t,\r\n        r: 5.5,\r\n        fill: color,\r\n        stroke: '#fff',\r\n        'fill-opacity': 1,\r\n        'vector-effect': 'non-scaling-stroke',\r\n        'stroke-width': 1\r\n    };\r\n\r\n    Object.keys(items).map(key => {\r\n        handler.setAttribute(key, items[key]);\r\n    });\r\n\r\n    return handler;\r\n}\r\n\r\nfunction setLineStyle(line, color) {\r\n    line.setAttribute('stroke', color);\r\n    line.setAttribute('stroke-dasharray', '3 3');\r\n    line.setAttribute('vector-effect', 'non-scaling-stroke');\r\n}\n\n// factory method for creating draggable elements\r\nfunction drag(options, obInstance) {\r\n    if (this.length) {\r\n        const Ob = (isDef(obInstance) && obInstance instanceof Observable)\r\n            ? obInstance\r\n            : new Observable();\r\n\r\n        return arrReduce.call(this, (result, item) => {\r\n            if (!(item instanceof SVGElement)) {\r\n                result.push(\r\n                    new Draggable(item, options, Ob)\r\n                );\r\n            } else {\r\n                if (checkElement(item)) {\r\n                    result.push(\r\n                        new DraggableSVG(item, options, Ob)\r\n                    );\r\n                }\r\n            }\r\n            return result;\r\n        }, []);\r\n    }\r\n}\n\nclass Cloneable extends SubjectModel {\r\n\r\n    constructor(el, options) {\r\n        super(el);\r\n        this.enable(options);\r\n    }\r\n\r\n    _init() {\r\n        const { \r\n            el, \r\n            options \r\n        } = this;\r\n        const $el = helper(el);\r\n\r\n        const {\r\n            style,\r\n            appendTo\r\n        } = options;\r\n\r\n        const css = {\r\n            position: 'absolute',\r\n            'z-index': '2147483647',\r\n            ...style\r\n        };\r\n\r\n        this.storage = {\r\n            css,\r\n            parent: isDef(appendTo) ? helper(appendTo)[0] : document.body\r\n        };\r\n\r\n        $el.on('mousedown', this._onMouseDown)\r\n            .on('touchstart', this._onTouchStart);\r\n\r\n        EVENTS.slice(0, 3).forEach((eventName) => {\r\n            this.eventDispatcher.registerEvent(eventName);\r\n        });\r\n    }\r\n\r\n    _processOptions(options) {\r\n        let _style = {},\r\n            _appendTo = null,\r\n            _stack = document,\r\n            _onInit = () => {},\r\n            _onMove = () => {},\r\n            _onDrop = () => {},\r\n            _onDestroy = () => {};\r\n        \r\n        if (isDef(options)) {\r\n            const {\r\n                style,\r\n                appendTo,\r\n                stack,\r\n                onInit,\r\n                onMove,\r\n                onDrop,\r\n                onDestroy\r\n            } = options;\r\n\r\n            _style = (isDef(style) && typeof style === 'object') ? style : _style;\r\n            _appendTo = appendTo || null;\r\n    \r\n            const dropZone = isDef(stack) \r\n                ? helper(stack)[0] \r\n                : document;\r\n    \r\n            _onInit = createMethod(onInit);\r\n            _onMove = createMethod(onMove);\r\n            _onDrop = isFunc(onDrop)\r\n                ? function(evt) {\r\n                    const {\r\n                        clone\r\n                    } = this.storage;\r\n    \r\n                    const result = objectsCollide(\r\n                        clone,\r\n                        dropZone\r\n                    );\r\n    \r\n                    if (result) {\r\n                        onDrop.call(this, evt, this.el, clone);\r\n                    }\r\n                }\r\n                : () => {};\r\n            _onDestroy = createMethod(onDestroy);\r\n        }\r\n        \r\n        this.options = {\r\n            style: _style,\r\n            appendTo: _appendTo,\r\n            stack: _stack\r\n        };\r\n\r\n        this.proxyMethods = {\r\n            onInit: _onInit,\r\n            onDrop: _onDrop,\r\n            onMove: _onMove,\r\n            onDestroy: _onDestroy\r\n        };\r\n    }\r\n\r\n    _start({ clientX, clientY }) {\r\n        const { \r\n            storage,\r\n            el\r\n        } = this;\r\n    \r\n        const {\r\n            parent,\r\n            css\r\n        } = storage; \r\n    \r\n        const { left, top } = getOffset(parent);\r\n    \r\n        css.left = `${(clientX - left)}px`;\r\n        css.top = `${(clientY - top)}px`;\r\n    \r\n        const clone = el.cloneNode(true);\r\n        helper(clone).css(css);\r\n    \r\n        storage.clientX = clientX;\r\n        storage.clientY = clientY;\r\n        storage.cx = clientX;\r\n        storage.cy = clientY;\r\n        storage.clone = clone;\r\n    \r\n        helper(parent)[0].appendChild(clone);\r\n        this._draw();\r\n    }\r\n\r\n    _moving({ clientX, clientY }) {    \r\n        const { storage } = this;\r\n    \r\n        storage.clientX = clientX;\r\n        storage.clientY = clientY;\r\n        storage.doDraw = true;\r\n        storage.doMove = true;\r\n    }\r\n    \r\n    _end(e) {\r\n        const { storage } = this;\r\n    \r\n        const {\r\n            clone,\r\n            frameId\r\n        } = storage;\r\n    \r\n        storage.doDraw = false;\r\n        cancelAnimFrame(frameId);\r\n    \r\n        if (isUndef(clone)) return;\r\n    \r\n        this.proxyMethods.onDrop.call(this, e);\r\n        clone.parentNode.removeChild(clone);\r\n    \r\n        delete storage.clone;\r\n    }\r\n\r\n    _animate() {\r\n        const { storage } = this;\r\n    \r\n        storage.frameId = requestAnimFrame(this._animate);\r\n\r\n        const {\r\n            doDraw,\r\n            clientX,\r\n            clientY,\r\n            cx,\r\n            cy\r\n        } = storage;\r\n\r\n        if (!doDraw) return;\r\n        storage.doDraw = false;\r\n\r\n        this._drag(\r\n            { \r\n                dx: clientX - cx,\r\n                dy: clientY - cy\r\n            }\r\n        );\r\n    }\r\n\r\n    _processMove(dx, dy) {\r\n        const {\r\n            clone\r\n        } = this.storage;\r\n\r\n        const translate = `translate(${dx}px, ${dy}px)`;\r\n\r\n        helper(clone).css({\r\n            transform: translate,\r\n            webkitTranform: translate,\r\n            mozTransform: translate,\r\n            msTransform: translate,\r\n            otransform: translate \r\n        });\r\n    }\r\n    \r\n    _destroy() {\r\n        const {\r\n            storage,\r\n            proxyMethods,\r\n            el\r\n        } = this;\r\n\r\n        if (isUndef(storage)) return;\r\n        helper(el)\r\n            .off('mousedown', this._onMouseDown)\r\n            .off('touchstart', this._onTouchStart);\r\n\r\n        proxyMethods.onDestroy.call(this, el);\r\n        delete this.storage;\r\n    }\r\n\r\n    disable() {\r\n        this._destroy();\r\n    }\r\n\r\n}\n\nfunction clone(options) {\n    if (this.length) {\n        return arrMap.call(this, item => {\n            return new Cloneable(item, options);\n        });\n    }\n}\n\nclass Subjx extends Helper {\r\n\r\n    drag() {\r\n        return drag.call(this, ...arguments);\r\n    }\r\n\r\n    clone() {\r\n        return clone.call(this, ...arguments);\r\n    }\r\n\r\n}\n\nfunction subjx(params) {\r\n    return new Subjx(params);\r\n}\r\n\r\nObject.defineProperty(subjx, 'createObservable', {\r\n    value: () => {\r\n        return new Observable();\r\n    }\r\n});\r\n\r\nObject.defineProperty(subjx, 'Subjx', {\r\n    value: Subjx\r\n});\r\n\r\nObject.defineProperty(subjx, 'Observable', {\r\n    value: Observable\r\n});\n\nmodule.exports = subjx;\n","'use strict';\r\n\r\nif (process.env.NODE_ENV === 'production') {\r\n    module.exports = require('./dist/js/subjx.common.js');\r\n} else {\r\n    module.exports = require('./dist/js/subjx.dev.common.js');\r\n}","import \"subjx/dist/style/subjx.css\";\r\n\r\nimport subjx from \"subjx\";\r\n\r\nvar zoom_value_formula = 1;\r\nlet scaleValue = 1;\r\n\r\n// self executing function here\r\n(function() {\r\n    // your page initialization code here\r\n    // the DOM will be available here\r\n\r\n    document.getElementById(\"cacluate_position\").onclick = cacluatePosition;\r\n    document.getElementById(\"zoom_canvas\").onchange = changeZoomCanvas;\r\n\r\n    const selected_index = document.getElementById(\"zoom_canvas\").selectedIndex;\r\n    console.log(\"selected_index \", selected_index)\r\n    defaultSelectedZoomCanvas(selected_index);\r\n\r\n    checkAllImagesLoaded();\r\n    document.addEventListener('mousemove',moveCursor)\r\n    \r\n\r\n\r\n})();\r\nfunction fitTextToImage()\r\n{\r\n    // const images = document.querySelectorAll(\".image_element\");\r\n    console.log(\"divs\")\r\n    var divs = document.querySelectorAll('div[id^=\"imageContainer\"]');\r\n    divs.forEach((div) => {\r\n        let text_div=div.getElementsByClassName(\"image_text\")[0];\r\n        let image_div=div.getElementsByClassName(\"image_element\")[0];\r\n        text_div.style.width=image_div.clientWidth-20+\"px\";\r\n\r\n        \r\n    });\r\n    console.log(divs)\r\n}\r\nfunction transformToFit() {\r\n    const images = document.querySelectorAll(\".image_element\");\r\n    console.log(\"images \", images);\r\n    let maxWidth = 0;\r\n    images.forEach((image) => {\r\n      const width = image.clientWidth;\r\n      maxWidth = Math.max(maxWidth, width);\r\n      const height = image.clientHeight;\r\n      console.log(`Image width: ${width}px, height: ${height}px`);\r\n    });\r\n    let container = document.getElementById(\"stack\");\r\n    let offsets_world = document.getElementById(\"world\");\r\n    \r\n    // if(maxWidth>container.clientWidth){\r\n      scaleValue = container.clientWidth / maxWidth;\r\n    if (scaleValue <= 1) {\r\n      // scaleValue = container.clientWidth / maxWidth - 0.01;\r\n      scaleValue=scaleValue- 0.01;\r\n      offsets_world.style.transform = `scale(${scaleValue})`;\r\n    } else {\r\n      // scaleValue = container.clientWidth / maxWidth - 0.2;\r\n      scaleValue=scaleValue- 0.1;\r\n      offsets_world.style.transform = `scale(${scaleValue})`;\r\n    }\r\n    zoom_value_formula = 1 / scaleValue;\r\n    // }\r\n    // else{\r\n    //     scaleValue=maxWidth;\r\n    // offsets_world.style.transform = `scale(${scaleValue})`;\r\n    // }\r\n  \r\n    // if(scaleValue>0){\r\n    // zoom_value_formula = 1/scaleValue;\r\n    // }\r\n    // console.log(container.clientWidth/maxWidth-0.01)\r\n  }\r\nfunction changeZoomCanvas(event) {\r\n    console.log(\"doSomething\", event);\r\n\r\n    const selected_index = event.target.selectedIndex;\r\n    console.log(\"selected_index \", selected_index);\r\n\r\n    defaultSelectedZoomCanvas(selected_index)\r\n}\r\n\r\nfunction defaultSelectedZoomCanvas(selected_index) {\r\n\r\n    let offsets_world = document.getElementById('world');\r\n\r\n    offsets_world.style.transformOrigin = '0px 0px';\r\n    if (selected_index == 0) {\r\n        zoom_value_formula = 2.5;\r\n        offsets_world.style.transform = 'scale(0.4)';\r\n    } else if (selected_index == 1) {\r\n        zoom_value_formula = 2;\r\n        offsets_world.style.transform = 'scale(0.5)';\r\n    } else if (selected_index == 2) {\r\n        zoom_value_formula = 1.667;\r\n        offsets_world.style.transform = 'scale(0.6)';\r\n    } else if (selected_index == 3) {\r\n        zoom_value_formula = 1.43;\r\n        offsets_world.style.transform = 'scale(0.7)';\r\n    } else if (selected_index == 4) {\r\n        zoom_value_formula = 1.25;\r\n        offsets_world.style.transform = 'scale(0.8)';\r\n    } else if (selected_index == 5) {\r\n        zoom_value_formula = 1.1;\r\n        offsets_world.style.transform = 'scale(0.9)';\r\n    } else if (selected_index == 6) {\r\n        // zoom_value_formula = 1;\r\n        // offsets_world.style.transform = 'scale(1)';\r\n        transformToFit()\r\n    } else if (selected_index == 7) {\r\n        zoom_value_formula = 0.82;\r\n        offsets_world.style.transform = 'scale(1.2)';\r\n    }\r\n}\r\n\r\nfunction cacluatePosition() {\r\n\r\n    var pagesOffsetObject = [{\"height\":3329.05078125,\"snapshots_name\":\"1448/samplepdf-1632023123525/images/sample-1.png\",\"image_height\":3303.70361328125,\"image_width\":2553.70361328125},{\"height\":3329.05078125,\"snapshots_name\":\"1448/samplepdf-1632023123525/images/sample-2.png\",\"image_height\":3303.70361328125,\"image_width\":2553.70361328125},{\"height\":1065.0462646484375,\"snapshots_name\":\"1448/SampleJPGImagekbmbjpg-1632023123544/images/SampleJPGImage_200kbmb-1.png\",\"image_height\":1039.6990966796875,\"image_width\":1039.6990966796875}];\r\n\r\n    console.log(xDraggable);\r\n\r\n    let meta_data = [];\r\n    let margin_gap = 24;\r\n\r\n    const array_xDraggable = xDraggable;\r\n    for (let index = 1; index < array_xDraggable.length; index++) \r\n    {\r\n        const draggable_element = array_xDraggable[index][0];\r\n        \r\n        console.log(\"draggable_element \", draggable_element);\r\n\r\n        const draggable_element_main = draggable_element[\"el\"];\r\n\r\n        let page = 0;\r\n\r\n        const temp_meta_data_top =\r\n        parseInt($(draggable_element_main).css(\"top\").slice(0, -2)) +\r\n        (parseInt($(draggable_element_main).css(\"transform\").split(\",\")[5])\r\n            ? parseInt($(draggable_element_main).css(\"transform\").split(\",\")[5])\r\n            : 0);\r\n\r\n\r\n        for (let j = 0; j < pagesOffsetObject.length; j++) \r\n        {\r\n            const snapshots_name = pagesOffsetObject[j].snapshots_name;\r\n            console.log(\"snapshots_name \", snapshots_name);\r\n\r\n            const current_page_image_height = pagesOffsetObject[j].image_height;\r\n            const current_page_image_width = pagesOffsetObject[j].image_width;\r\n\r\n            let image_document_element = document.querySelector(\"[snapshots_name='\"+snapshots_name+\"']\").querySelectorAll('img')[0];\r\n            console.log(\"image_document_element \", image_document_element);\r\n\r\n            let offsets = draggable_element_main.getBoundingClientRect();\r\n            console.log(\"offsets \", offsets);\r\n\r\n            let offsets_document_image = image_document_element.getBoundingClientRect();\r\n            console.log(\"offsets \", offsets);\r\n\r\n            let top = (offsets.top - offsets_document_image.top)*zoom_value_formula;\r\n            const left = (offsets.left - offsets_document_image.left)*zoom_value_formula;\r\n            const width = offsets.width * zoom_value_formula;\r\n            const height = offsets.height * zoom_value_formula;\r\n            const image_width = offsets_document_image.width * zoom_value_formula;\r\n            const image_height = offsets_document_image.height * zoom_value_formula;\r\n\r\n            page = j + 1;\r\n                meta_data.push({\r\n                    top: Math.ceil(top),\r\n                    left: Math.ceil(left),\r\n                    width: Math.ceil(width),\r\n                    height: Math.ceil(height),\r\n                    page: page,\r\n                    documents_top: Math.ceil(temp_meta_data_top),\r\n                });\r\n                break;\r\n        }\r\n\r\n        // let element_object = {\r\n        //     top : top,\r\n        //     left : left,\r\n        //     // snapshots_name : snapshots_name,\r\n        //     // document_key : document_key,\r\n        //     width : width,\r\n        //     height : height,\r\n        //     // image_width : image_width, \r\n        //     // image_height : image_height\r\n        // }\r\n\r\n        // meta_data.push(element_object);\r\n\r\n        if(array_xDraggable.length-1 == index)\r\n        {\r\n            console.log(\"meta_data \", meta_data);\r\n        }\r\n        \r\n    }\r\n  \r\n}\r\nlet clicked = false;\r\nlet elementToBeCloned = null;\r\nlet elementToBeClonedDup = null;\r\nconst xElem = subjx(\".draggable\");\r\nconst options = {\r\n    container: '#world',\r\n    snap: {\r\n        x: 0,\r\n        y: 0,\r\n        angle: 0\r\n    },\r\n    cursorMove: 'move',\r\n    cursorRotate: 'crosshair',\r\n    cursorResize: 'pointer',\r\n    rotatable : false,\r\n\r\n    ...methods\r\n\r\n}\r\n\r\nconst methods = {\r\n    onInit(elements) {\r\n        // fires on tool activation\r\n        console.log(\"onInit \", elements)\r\n    },\r\n    onMove({\r\n        clientX,\r\n        clientY,\r\n        dx,\r\n        dy,\r\n        transform\r\n    }) {\r\n        // fires on moving\r\n        console.log(\"onMove \", clientX)\r\n    },\r\n    onResize({\r\n        clientX,\r\n        clientY,\r\n        dx,\r\n        dy,\r\n        transform,\r\n        width,\r\n        height\r\n    }) {\r\n        // fires on resizing\r\n        console.log(\"onResize \", clientX)\r\n    },\r\n    onRotate({\r\n        clientX,\r\n        clientY,\r\n        delta,\r\n        transform\r\n    }) {\r\n        // fires on rotation\r\n        console.log(\"onRotate \", clientX)\r\n    },\r\n    onDrop({\r\n        clientX,\r\n        clientY\r\n    }) {\r\n        // fires on drop\r\n        console.log(\"onDrop \", clientX)\r\n    },\r\n    onDestroy(el) {\r\n        // fires on tool deactivation\r\n        console.log(\"onDestroy \", el)\r\n    }\r\n}\r\nlet xDraggable = xElem.drag(options);\r\n// console.log(xDraggable.controls);\r\nfunction cloneElement(e,el){\r\n    console.log(\"onDrop e \", e);\r\n        console.log(\"onDrop el \", el);\r\n        // console.log(\"onDrop clone \", clone);\r\n        let parent = document.getElementById(\"world\");\r\n\r\n        // console.log(xDraggable.length)\r\n        const stack = subjx('#world')[0],\r\n            offset = stack.getBoundingClientRect(),\r\n            drag_div = document.createElement('div');\r\n\r\n        // const xDraggable_length = xDraggable.length;\r\n\r\n        // drag_div.setAttribute(\"id\", \"item_\"+(xDraggable_length+1));\r\n        drag_div.setAttribute(\"class\", \"draggable\");\r\n        drag_div.setAttribute(\"document_id\", e.target.id);\r\n        drag_div.style.top = `${(e.clientY - offset.top)*zoom_value_formula}px`;\r\n        drag_div.style.left = `${(e.clientX - offset.left)*zoom_value_formula}px`;\r\n\r\n        console.log(\"top \", e.clientY, \" \", offset.top, \" -> \", ((e.clientY - offset.top) * zoom_value_formula));\r\n        console.log(\"left \", e.clientX, \" \", offset.left, \" -> \", ((e.clientX - offset.left) * zoom_value_formula));\r\n\r\n        // drag_div.style.top = \"150px\";\r\n        // drag_div.style.left = \"600px\";\r\n\r\n        let drag_img = document.createElement('img');\r\n        drag_img.style.background = \"url('https://wesign.com/assets/images_dev/sign_box_2.png') 50% center / contain no-repeat, rgb(255, 214, 91)\";\r\n        drag_img.style.opacity = 0.8;\r\n        drag_img.style.border =  '1px solid rgb(255, 255, 118)';\r\n        drag_img.style.borderRadius =  '5px';\r\n        drag_img.style.width = '100%';\r\n        drag_img.style.height =  '100%';\r\n\r\n\r\n        drag_div.appendChild(drag_img);\r\n        parent.appendChild(drag_div);\r\n\r\n        xDraggable.push(\r\n            subjx(drag_div).drag(options)\r\n        );\r\n\r\n}\r\nsubjx('.clone').clone({\r\n    stack: '#container',\r\n    appendTo: '#stack',\r\n    onInit(el) {\r\n        // fires on tool activation;\r\n        console.log(\"clone init\")\r\n    },\r\n    onMove(dx, dy) {\r\n        // fires on moving\r\n        // console.log(\"fires on moving \", dx, dy)\r\n    },\r\n    onDrop(e, el, clone) {\r\n        // fires on drop\r\n        console.log(\"onDrop e \", e);\r\n        console.log(\"onDrop el \", el);\r\n        console.log(\"onDrop clone \", clone);\r\n        cloneElement(e,el);\r\n        // let parent = document.getElementById(\"world\");\r\n\r\n        // // console.log(xDraggable.length)\r\n        // const stack = subjx('#world')[0],\r\n        //     offset = stack.getBoundingClientRect(),\r\n        //     drag_div = document.createElement('div');\r\n\r\n        // // const xDraggable_length = xDraggable.length;\r\n\r\n        // // drag_div.setAttribute(\"id\", \"item_\"+(xDraggable_length+1));\r\n        // drag_div.setAttribute(\"class\", \"draggable\");\r\n        // drag_div.setAttribute(\"document_id\", e.target.id);\r\n        // drag_div.style.top = `${(e.clientY - offset.top)*zoom_value_formula}px`;\r\n        // drag_div.style.left = `${(e.clientX - offset.left)*zoom_value_formula}px`;\r\n\r\n        // console.log(\"top \", e.clientY, \" \", offset.top, \" -> \", ((e.clientY - offset.top) * zoom_value_formula));\r\n        // console.log(\"left \", e.clientX, \" \", offset.left, \" -> \", ((e.clientX - offset.left) * zoom_value_formula));\r\n\r\n        // // drag_div.style.top = \"150px\";\r\n        // // drag_div.style.left = \"600px\";\r\n\r\n        // let drag_img = document.createElement('img');\r\n        // drag_img.style.background = \"url('https://wesign.com/assets/images_dev/sign_box_2.png') 50% center / contain no-repeat, rgb(255, 214, 91)\";\r\n        // drag_img.style.opacity = 0.8;\r\n        // drag_img.style.border =  '1px solid rgb(255, 255, 118)';\r\n        // drag_img.style.borderRadius =  '5px';\r\n        // drag_img.style.width = '100%';\r\n        // drag_img.style.height =  '100%';\r\n\r\n\r\n        // drag_div.appendChild(drag_img);\r\n        // parent.appendChild(drag_div);\r\n\r\n        // xDraggable.push(\r\n        //     subjx(drag_div).drag(options)\r\n        // );\r\n    },\r\n    onDestroy() {\r\n        // fires on tool deactivation\r\n    }\r\n});\r\nsubjx('#container').on('click', async (a) => {\r\n    if(clicked == true)\r\n    {\r\n        clicked = false;\r\n        cloneElement(a,elementToBeCloned);\r\n        // document.removeChild(elementToBeClonedDup);\r\n        let container=document.getElementById(\"container\");\r\n    container.removeChild(elementToBeClonedDup);\r\n    }\r\n});\r\n// subjx('.clone').clone({\r\n\r\n// })\r\n\r\nfunction moveCursor(event)\r\n{\r\n    // console.log(\"moveCursor \", event)\r\n    const mouseY= event.clientY;\r\n    const mouseX= event.clientX;\r\n    // elementToBeCloned.style. = mouseY;\r\n    if(clicked == true)\r\n    {\r\n        elementToBeClonedDup.style.left = mouseX + \"px\";\r\n    elementToBeClonedDup.style.top = mouseY + \"px\";\r\n    // clicked = false;\r\n    \r\n\r\n    }\r\n    \r\n}\r\n\r\nsubjx('.clone').on('click', async (a) => {\r\n    console.log(\"e \", a);\r\n    let el=a.target;\r\n    console.log(\"el \", el);\r\n    console.log(\"single\");\r\n    \r\n    if(clicked == false)\r\n    {\r\n        clicked = true;\r\n        elementToBeCloned = el;\r\n        \r\n        elementToBeClonedDup=elementToBeCloned.cloneNode(true);\r\n        // elementToBeClonedDup.style.position = \"absolute\";\r\n        // console.log(elementToBeClonedDup.style) \r\n        // console.log(elementToBeClonedDup)\r\n        // elementToBeClonedDup.style.transition=\"all 200ms ease-out\";\r\n        // elementToBeClonedDup.style.pointerEvents=\"none\";\r\n        let container=document.getElementById(\"container\");\r\n        // container.appendChild(elementToBeClonedDup);\r\n        // elementToBeClonedDup.style.zIndex=\"-1\";\r\n        // elementToBeClonedDup.style.width=\"100px\";\r\n        // elementToBeClonedDup.style.height=\"100px\";\r\n        elementToBeClonedDup.style.position=\"fixed\";\r\n        elementToBeClonedDup.style.pointerEvents=\"none\";\r\n\r\n        container.appendChild(elementToBeClonedDup)\r\n        \r\n    }\r\n    \r\n\r\n});\r\n\r\nsubjx('.clone').on('dblclick', async () => {\r\n    console.log(\"double click\");\r\n    console.log(document.activeElement)\r\n});\r\n\r\n\r\nfunction checkAllImagesLoaded() {\r\n    var imgs = document.images,\r\n    len = imgs.length,\r\n    counter = 0;\r\n\r\n    [].forEach.call( imgs, function( img ) {\r\n        if(img.complete)\r\n        incrementCounter();\r\n        else\r\n        img.addEventListener( 'load', incrementCounter, false );\r\n    } );\r\n\r\n    function incrementCounter() {\r\n        counter++;\r\n        if ( counter === len ) {\r\n            console.log( 'All images loaded!' );\r\n            fitToWidth();\r\n        }\r\n    }\r\n\r\n}\r\n\r\nfunction fitToWidth() {\r\n    transformToFit()\r\n    fitTextToImage()\r\n    scrollCheck();\r\n    \r\n\r\n}\r\nfunction scrollCheck()\r\n{\r\n    console.log(\"scrollCheck\")\r\n    let container=document.getElementById(\"stack\");\r\n    console.log(\"container \", container)\r\n    container.addEventListener('scroll', function() {\r\n        var element = document.querySelector('#image_element01');\r\n        var position = element.getBoundingClientRect();\r\n        console.log(\"position \", position)\r\n    \r\n        // checking whether fully visible\r\n        if(position.top >= 0 && position.bottom <= window.innerHeight) {\r\n            console.log('Element is fully visible in screen');\r\n        }\r\n    \r\n        // checking for partial visibility\r\n        if(position.top < window.innerHeight && position.bottom >= 0) {\r\n            console.log('Element is partially visible in screen');\r\n        }\r\n    });\r\n}\r\n\r\n\r\n","var bundleURL = null;\nfunction getBundleURLCached() {\n  if (!bundleURL) {\n    bundleURL = getBundleURL();\n  }\n\n  return bundleURL;\n}\n\nfunction getBundleURL() {\n  // Attempt to find the URL of the current script and use that as the base URL\n  try {\n    throw new Error;\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\\/\\/[^)\\n]+/g);\n    if (matches) {\n      return getBaseURL(matches[0]);\n    }\n  }\n\n  return '/';\n}\n\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\\/\\/.+)?\\/[^/]+(?:\\?.*)?$/, '$1') + '/';\n}\n\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\n","var bundle = require('./bundle-url');\n\nfunction updateLink(link) {\n  var newLink = link.cloneNode();\n  newLink.onload = function () {\n    link.remove();\n  };\n  newLink.href = link.href.split('?')[0] + '?' + Date.now();\n  link.parentNode.insertBefore(newLink, link.nextSibling);\n}\n\nvar cssTimeout = null;\nfunction reloadCSS() {\n  if (cssTimeout) {\n    return;\n  }\n\n  cssTimeout = setTimeout(function () {\n    var links = document.querySelectorAll('link[rel=\"stylesheet\"]');\n    for (var i = 0; i < links.length; i++) {\n      if (bundle.getBaseURL(links[i].href) === bundle.getBundleURL()) {\n        updateLink(links[i]);\n      }\n    }\n\n    cssTimeout = null;\n  }, 50);\n}\n\nmodule.exports = reloadCSS;\n","var OVERLAY_ID = '__parcel__error__overlay__';\n\nvar OldModule = module.bundle.Module;\n\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData,\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n\n  module.bundle.hotData = null;\n}\n\nmodule.bundle.Module = Module;\nvar checkedAssets, assetsToAccept;\n\nvar parent = module.bundle.parent;\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = process.env.HMR_HOSTNAME || location.hostname;\n  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';\n  var ws = new WebSocket(protocol + '://' + hostname + ':' + process.env.HMR_PORT + '/');\n  ws.onmessage = function(event) {\n    checkedAssets = {};\n    assetsToAccept = [];\n\n    var data = JSON.parse(event.data);\n\n    if (data.type === 'update') {\n      var handled = false;\n      data.assets.forEach(function(asset) {\n        if (!asset.isNew) {\n          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);\n          if (didAccept) {\n            handled = true;\n          }\n        }\n      });\n\n      // Enable HMR for CSS by default.\n      handled = handled || data.assets.every(function(asset) {\n        return asset.type === 'css' && asset.generated.js;\n      });\n\n      if (handled) {\n        console.clear();\n\n        data.assets.forEach(function (asset) {\n          hmrApply(global.parcelRequire, asset);\n        });\n\n        assetsToAccept.forEach(function (v) {\n          hmrAcceptRun(v[0], v[1]);\n        });\n      } else if (location.reload) { // `location` global exists in a web worker context but lacks `.reload()` function.\n        location.reload();\n      }\n    }\n\n    if (data.type === 'reload') {\n      ws.close();\n      ws.onclose = function () {\n        location.reload();\n      }\n    }\n\n    if (data.type === 'error-resolved') {\n      console.log('[parcel] ✨ Error resolved');\n\n      removeErrorOverlay();\n    }\n\n    if (data.type === 'error') {\n      console.error('[parcel] 🚨  ' + data.error.message + '\\n' + data.error.stack);\n\n      removeErrorOverlay();\n\n      var overlay = createErrorOverlay(data);\n      document.body.appendChild(overlay);\n    }\n  };\n}\n\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n  if (overlay) {\n    overlay.remove();\n  }\n}\n\nfunction createErrorOverlay(data) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n\n  // html encode message and stack trace\n  var message = document.createElement('div');\n  var stackTrace = document.createElement('pre');\n  message.innerText = data.error.message;\n  stackTrace.innerText = data.error.stack;\n\n  overlay.innerHTML = (\n    '<div style=\"background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;\">' +\n      '<span style=\"background: red; padding: 2px 4px; border-radius: 2px;\">ERROR</span>' +\n      '<span style=\"top: 2px; margin-left: 5px; position: relative;\">🚨</span>' +\n      '<div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">' + message.innerHTML + '</div>' +\n      '<pre>' + stackTrace.innerHTML + '</pre>' +\n    '</div>'\n  );\n\n  return overlay;\n\n}\n\nfunction getParents(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return [];\n  }\n\n  var parents = [];\n  var k, d, dep;\n\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n      if (dep === id || (Array.isArray(dep) && dep[dep.length - 1] === id)) {\n        parents.push(k);\n      }\n    }\n  }\n\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n\n  return parents;\n}\n\nfunction hmrApply(bundle, asset) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (modules[asset.id] || !bundle.parent) {\n    var fn = new Function('require', 'module', 'exports', asset.generated.js);\n    asset.isNew = !modules[asset.id];\n    modules[asset.id] = [fn, asset.deps];\n  } else if (bundle.parent) {\n    hmrApply(bundle.parent, asset);\n  }\n}\n\nfunction hmrAcceptCheck(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (!modules[id] && bundle.parent) {\n    return hmrAcceptCheck(bundle.parent, id);\n  }\n\n  if (checkedAssets[id]) {\n    return;\n  }\n  checkedAssets[id] = true;\n\n  var cached = bundle.cache[id];\n\n  assetsToAccept.push([bundle, id]);\n\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    return true;\n  }\n\n  return getParents(global.parcelRequire, id).some(function (id) {\n    return hmrAcceptCheck(global.parcelRequire, id)\n  });\n}\n\nfunction hmrAcceptRun(bundle, id) {\n  var cached = bundle.cache[id];\n  bundle.hotData = {};\n  if (cached) {\n    cached.hot.data = bundle.hotData;\n  }\n\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData);\n    });\n  }\n\n  delete bundle.cache[id];\n  bundle(id);\n\n  cached = bundle.cache[id];\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      cb();\n    });\n    return true;\n  }\n}\n"]}